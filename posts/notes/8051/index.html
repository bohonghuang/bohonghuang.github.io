<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">8051 - 黄博宏的个人主页</title><meta name="Description" content=""><meta property="og:title" content="8051" />
<meta property="og:description" content="CPU 微控制器的核心，包括运算器和控制器两大部分： 运算器 运算器的任务是数据的处理和加工。由以下几个部分通过内部总线连接而成： 算术逻辑单元 ALU (Arithmetic Logic Unit)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bohonghuang.github.io/posts/notes/8051/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-06-18T19:12:13+08:00" /><meta property="og:site_name" content="黄博宏的个人主页" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="8051"/>
<meta name="twitter:description" content="CPU 微控制器的核心，包括运算器和控制器两大部分： 运算器 运算器的任务是数据的处理和加工。由以下几个部分通过内部总线连接而成： 算术逻辑单元 ALU (Arithmetic Logic Unit)"/>
<meta name="application-name" content="黄博宏的个人笔记">
<meta name="apple-mobile-web-app-title" content="黄博宏的个人笔记">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="https://bohonghuang.github.io/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="https://bohonghuang.github.io/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://bohonghuang.github.io/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="https://bohonghuang.github.io/apple-touch-icon.png"><link rel="mask-icon" href="https://bohonghuang.github.io/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://bohonghuang.github.io/posts/notes/8051/" /><link rel="prev" href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/" /><link rel="next" href="https://bohonghuang.github.io/posts/notes/c&#43;&#43;/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="https://bohonghuang.github.io/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "8051",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/bohonghuang.github.io\/posts\/notes\/8051\/"
        },"image": ["https:\/\/bohonghuang.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "单片机, 汇编语言","wordcount":  13812 ,
        "url": "https:\/\/bohonghuang.github.io\/posts\/notes\/8051\/","datePublished": "2022-03-29T00:00:00+00:00","dateModified": "2022-06-18T19:12:13+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "黄博宏"},"author": {
                "@type": "Person",
                "name": "黄博宏"
            },"description": ""
    }
    </script></head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('auto' === 'light' || 'auto' === 'dark' || 'auto' === 'black') setTheme('auto'), saveTheme('auto'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="https://bohonghuang.github.io/" title="黄博宏的个人主页">黄博宏的个人主页</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="https://bohonghuang.github.io/posts/blog/" title="我的个人博客"> 博客 </a><a class="menu-item" href="https://bohonghuang.github.io/posts/notes/" title="我的个人笔记"> 笔记 </a><a class="menu-item" href="https://bohonghuang.github.io/tags/"> 标签 </a><a class="menu-item" href="https://bohonghuang.github.io/categories/"> 分类 </a><a class="menu-item" href="https://github.com/BohongHuang/bohonghuang.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="https://bohonghuang.github.io/" title="黄博宏的个人主页">黄博宏的个人主页</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="https://bohonghuang.github.io/posts/blog/" title="我的个人博客">博客</a><a class="menu-item" href="https://bohonghuang.github.io/posts/notes/" title="我的个人笔记">笔记</a><a class="menu-item" href="https://bohonghuang.github.io/tags/" title="">标签</a><a class="menu-item" href="https://bohonghuang.github.io/categories/" title="">分类</a><a class="menu-item" href="https://github.com/BohongHuang/bohonghuang.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">8051</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="https://github.com/BohongHuang" title="Author" target="_blank" rel="noopener noreffer author" class="author">黄博宏</a>
                </span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-03-29">2022-03-29</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2022-06-18">2022-06-18</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 13812 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 28 分钟&nbsp;<span id="/posts/notes/8051/" class="leancloud_visitors" data-flag-title="8051">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#cpu--微机原理与接口技术-dot-md"><a href="HAHAHUGOSHORTCODE-s0-HBHB">CPU</a></a></li>
    <li><a href="#时钟">时钟</a>
      <ul>
        <li><a href="#时钟周期">时钟周期</a></li>
        <li><a href="#状态周期">状态周期</a></li>
        <li><a href="#机器周期">机器周期</a></li>
        <li><a href="#指令周期">指令周期</a></li>
      </ul>
    </li>
    <li><a href="#存储器--微机原理与接口技术-dot-md"><a href="HAHAHUGOSHORTCODE-s6-HBHB">存储器</a></a></li>
    <li><a href="#引脚">引脚</a></li>
    <li><a href="#中断">中断</a>
      <ul>
        <li><a href="#中断优先级">中断优先级</a></li>
        <li><a href="#中断嵌套">中断嵌套</a></li>
        <li><a href="#中断向量表">中断向量表</a></li>
      </ul>
    </li>
    <li><a href="#定时器">定时器</a></li>
    <li><a href="#串口">串口</a></li>
    <li><a href="#低功耗">低功耗</a>
      <ul>
        <li><a href="#空闲模式">空闲模式</a></li>
        <li><a href="#掉电模式">掉电模式</a></li>
      </ul>
    </li>
    <li><a href="#指令">指令</a>
      <ul>
        <li><a href="#寻址方式">寻址方式</a>
          <ul>
            <li><a href="#立即寻址">立即寻址</a></li>
            <li><a href="#直接寻址">直接寻址</a></li>
            <li><a href="#寄存器寻址">寄存器寻址</a></li>
            <li><a href="#寄存器间接寻址">寄存器间接寻址</a></li>
            <li><a href="#变址寻址">变址寻址</a></li>
            <li><a href="#相对寻址">相对寻址</a></li>
            <li><a href="#位寻址">位寻址</a></li>
          </ul>
        </li>
        <li><a href="#数据写入指令">数据写入指令</a>
          <ul>
            <li><a href="#mov"><code>MOV</code></a></li>
            <li><a href="#movx"><code>MOVX</code></a></li>
            <li><a href="#movc"><code>MOVC</code></a></li>
          </ul>
        </li>
        <li><a href="#栈操作指令">栈操作指令</a>
          <ul>
            <li><a href="#push"><code>PUSH</code></a></li>
            <li><a href="#pop"><code>POP</code></a></li>
          </ul>
        </li>
        <li><a href="#数据交换指令">数据交换指令</a>
          <ul>
            <li><a href="#xch"><code>XCH</code></a></li>
            <li><a href="#xchd"><code>XCHD</code></a></li>
            <li><a href="#swap"><code>SWAP</code></a></li>
          </ul>
        </li>
        <li><a href="#算术运算指令">算术运算指令</a>
          <ul>
            <li><a href="#add"><code>ADD</code></a></li>
            <li><a href="#addc"><code>ADDC</code></a></li>
            <li><a href="#subb"><code>SUBB</code></a></li>
            <li><a href="#inc"><code>INC</code></a></li>
            <li><a href="#dec"><code>DEC</code></a></li>
            <li><a href="#mul"><code>MUL</code></a></li>
            <li><a href="#div"><code>DIV</code></a></li>
            <li><a href="#da"><code>DA</code></a></li>
          </ul>
        </li>
        <li><a href="#逻辑运算指令">逻辑运算指令</a>
          <ul>
            <li><a href="#anl"><code>ANL</code></a></li>
            <li><a href="#orl"><code>ORL</code></a></li>
            <li><a href="#xrl"><code>XRL</code></a></li>
            <li><a href="#clr"><code>CLR</code></a></li>
            <li><a href="#cpl"><code>CPL</code></a></li>
          </ul>
        </li>
        <li><a href="#移位运算指令">移位运算指令</a>
          <ul>
            <li><a href="#rl"><code>RL</code></a></li>
            <li><a href="#rr"><code>RR</code></a></li>
            <li><a href="#rlc"><code>RLC</code></a></li>
            <li><a href="#rrc"><code>RRC</code></a></li>
          </ul>
        </li>
        <li><a href="#无条件跳转指令">无条件跳转指令</a>
          <ul>
            <li><a href="#ljmp"><code>LJMP</code></a></li>
            <li><a href="#ajmp"><code>AJMP</code></a></li>
            <li><a href="#sjmp"><code>SJMP</code></a></li>
            <li><a href="#jmp"><code>JMP</code></a></li>
          </ul>
        </li>
        <li><a href="#条件跳转指令">条件跳转指令</a>
          <ul>
            <li><a href="#jz"><code>JZ</code></a></li>
            <li><a href="#jnz"><code>JNZ</code></a></li>
            <li><a href="#cjne"><code>CJNE</code></a></li>
            <li><a href="#djnz"><code>DJNZ</code></a></li>
            <li><a href="#jbn"><code>JBN</code></a></li>
            <li><a href="#jbc"><code>JBC</code></a></li>
            <li><a href="#jc"><code>JC</code></a></li>
            <li><a href="#jnc"><code>JNC</code></a></li>
          </ul>
        </li>
        <li><a href="#子程序指令">子程序指令</a>
          <ul>
            <li><a href="#lcall"><code>LCALL</code></a></li>
            <li><a href="#acall"><code>ACALL</code></a></li>
            <li><a href="#ret"><code>RET</code></a></li>
            <li><a href="#reti"><code>RETI</code></a></li>
          </ul>
        </li>
        <li><a href="#空指令">空指令</a>
          <ul>
            <li><a href="#nop"><code>NOP</code></a></li>
          </ul>
        </li>
        <li><a href="#伪指令">伪指令</a>
          <ul>
            <li><a href="#org"><code>ORG</code></a></li>
            <li><a href="#equ"><code>EQU</code></a></li>
            <li><a href="#db"><code>DB</code></a></li>
            <li><a href="#dw"><code>DW</code></a></li>
            <li><a href="#bit"><code>BIT</code></a></li>
            <li><a href="#end"><code>END</code></a></li>
            <li><a href="#ds"><code>DS</code></a></li>
            <li><a href="#data"><code>DATA</code></a></li>
            <li><a href="#xdata"><code>XDATA</code></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#c51">C51</a>
      <ul>
        <li><a href="#变量">变量</a>
          <ul>
            <li><a href="#变量类型">变量类型</a></li>
            <li><a href="#变量位置">变量位置</a></li>
          </ul>
        </li>
        <li><a href="#指针">指针</a>
          <ul>
            <li><a href="#通用指针">通用指针</a></li>
            <li><a href="#特殊指针">特殊指针</a></li>
          </ul>
        </li>
        <li><a href="#函数">函数</a></li>
        <li><a href="#标准库">标准库</a>
          <ul>
            <li><a href="#本征函数">本征函数</a></li>
            <li><a href="#非本征函数">非本征函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="cpu--微机原理与接口技术-dot-md"><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a></h2>
<p>微控制器的核心，包括运算器和控制器两大部分：</p>
<ul>
<li>运算器 <br />
运算器的任务是数据的处理和加工。由以下几个部分通过内部总线连接而成：
<ul>
<li>算术逻辑单元 ALU (Arithmetic Logic Unit) <br />
完成算术运算及与、或 、非、异或等逻辑操作，并通过对运算结果的判断，影响程序状态寄存器 <code>PSW</code> 相关位的内容。</li>
<li>累加器 <code>ACC</code></li>
<li>暂存寄存器</li>
<li>程序状态寄存器 <code>PSW</code></li>
<li>位处理器（布尔处理器） <br />
能直接处理位，在位逻辑和位功能上有独到优势。位处理器中功能最强、使用最频繁的位是 <code>C</code> ，也称其为位累加器。</li>
<li><a href="https://bohonghuang.github.io/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#bcd-码" rel="">BCD 码</a>运算调整电路</li>
</ul>
</li>
<li>控制器 <br />
控制器是 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 的大脑中枢，处理指令的读出、译码和执行，对指令的执行过程进行定时控制，并根据指令含义，完成指令规定的操作。
<ul>
<li>指令部件
<ul>
<li><a href="#org-target------" rel="">程序计数器</a> <code>PC</code></li>
<li>指令寄存器 <code>IR</code> <br />
存放当前正在执行的指令代码，等待译码。</li>
<li>指令译码器 <code>ID</code> <br />
对当前指令操作码进行解析，并通过控制电路产生执行该指令需要的控制信号，完成指令规定的操作。</li>
</ul>
</li>
<li>时序部件 <br />
时序部件由时钟电路和脉冲分频器组成，用于产生操作控制部件所需的时序信号，包括：
<ul>
<li><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 工作的时钟基准（称为振荡周期或时钟周期）</li>
<li>状态周期</li>
<li>机器周期</li>
</ul>
</li>
<li>操作控制部件 <br />
操作控制部件为指令译码器的输出信号配上节拍电位和节拍脉冲，形成执行指令需要的操作控制序列信号，以完成规定的操作。</li>
</ul>
</li>
</ul>
<p>其他部分：</p>
<ul>
<li>布尔处理器 <br />
具有较强的位寻址、位处理能力。</li>
<li>时钟电路 <br />
产生微控制器工作所需要的时钟脉冲（需要外接晶体振荡器和微调电容）。</li>
<li>中断系统 <br />
5 个中断源 、2 个中断优先权。</li>
</ul>
<h2 id="时钟">时钟</h2>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-03-29_07-20-50_70.png"/>
</figure>

<h3 id="时钟周期">时钟周期</h3>
<p>也称为振荡周期，是晶振频率的倒数，是 MCU 中最基本、最小的时间单位。</p>
<h3 id="状态周期">状态周期</h3>
<p>是<a href="#%e6%97%b6%e9%92%9f%e5%91%a8%e6%9c%9f" rel="">时钟周期</a>的两倍，即由连续的 2 个节拍 <code>P1</code> 和 <code>P2</code> 组成。</p>
<h3 id="机器周期">机器周期</h3>
<p><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 执行一个基本操作所需要的时间，1 个机器周期由 6 个<a href="#%e7%8a%b6%e6%80%81%e5%91%a8%e6%9c%9f" rel="">状态周期</a>（即 12个时钟周期）组成。</p>
<h3 id="指令周期">指令周期</h3>
<p>执行一条指令所需要的时间。通常每条指令的执行可划分为 1-4 个基本操作，因此指令周期由 1-4 个<a href="#%e6%9c%ba%e5%99%a8%e5%91%a8%e6%9c%9f" rel="">机器周期</a>组成。</p>
<h2 id="存储器--微机原理与接口技术-dot-md"><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#memory" rel="">存储器</a></h2>
<p><a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 微控制器的存储器采用哈佛结构，<a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 和 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 是分开寻址的：</p>
<table>
<thead>
<tr>
<th><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#memory" rel="">存储器</a></th>
<th>大小</th>
<th>地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>256B</td>
<td><code>00H</code> 至 <code>FFH</code></td>
</tr>
<tr>
<td>特殊寄存器 SFR</td>
<td>21 个</td>
<td><code>80H</code> 至 <code>FFH</code> （专用内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区）</td>
</tr>
<tr>
<td>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>64KB</td>
<td><code>0000H</code> 至 <code>FFFFH</code></td>
</tr>
<tr>
<td>内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a></td>
<td>8KB （增强型 8051 为 64KB）</td>
<td><code>0000H</code> 至 <code>1FFFH</code></td>
</tr>
<tr>
<td>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a></td>
<td>64KB</td>
<td><code>0000H</code> 至 <code>FFFFH</code></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>程序存储器 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> <br /></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>入口地址</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>复位</td>
<td><code>0000H</code></td>
<td>系统复位后 <code>PC</code> 所在位置</td>
</tr>
<tr>
<td>外部中断0</td>
<td><code>0003H</code></td>
<td>外部中断0 响应时程序跳转位置</td>
</tr>
<tr>
<td>定时器0 溢出</td>
<td><code>000BH</code></td>
<td>定时器0 中断响应时程序跳转位置</td>
</tr>
<tr>
<td>外部中断1</td>
<td><code>0013H</code></td>
<td>外部中断1 响应时程序跳转位置</td>
</tr>
<tr>
<td>定时器1 溢出</td>
<td><code>001BH</code></td>
<td>定时器1 中断响应时程序跳转位置</td>
</tr>
<tr>
<td>串行口中断</td>
<td><code>0023H</code></td>
<td>串行口中断响应时程序跳转位置</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>数据存储器 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></p>
<ul>
<li>内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a>
<ul>
<li>
<p>寻址方式</p>
<ul>
<li><code>00H</code>-<code>7FH</code> 的内存区域
<ul>
<li>直接寻址</li>
<li>间接寻址</li>
</ul>
</li>
<li><code>80H</code>-<code>FFH</code> 的特殊功能寄存器
<ul>
<li>直接寻址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>区域 <br /></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>入口地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>工作寄存器区</td>
<td><code>00H</code></td>
</tr>
<tr>
<td>位寻址区</td>
<td><code>20F</code></td>
</tr>
<tr>
<td>用户 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区</td>
<td><code>30H</code></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>工作寄存器区 <span class="org-target" id="org-target-------"></span> <br />
工作寄存器区位于内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的 <code>00H</code>-<code>1FH</code> 单元，分成 4 组，每组 8 个字节（共 32 字节），均记作 <code>R0</code>-<code>R7</code> 。工作寄存器区是寄存器寻址区域，对该区域操作的指令数量最多，均为单周期指令，执行的速度最快。 <span class="org-target" id="org-target-------"></span></p>
<table>
<thead>
<tr>
<th>工作寄存器组</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>工作寄存器 0 组</td>
<td><code>00H</code>-<code>07H</code></td>
</tr>
<tr>
<td>工作寄存器 1 组</td>
<td><code>08H</code>-<code>0FH</code></td>
</tr>
<tr>
<td>工作寄存器 2 组</td>
<td><code>10H</code>-<code>17H</code></td>
</tr>
<tr>
<td>工作寄存器 3 组</td>
<td><code>18H</code>-<code>1FH</code></td>
</tr>
</tbody>
</table>
<ul>
<li>选择 <br />
任一时刻，只能使用一个寄存器组，<a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 复位后，默认选择第 0 组。之后由 <code>PSW</code> 寄存器中的 <code>RS1</code> 、 <code>RS0</code> 来选择四组工作寄存器区的哪一组作为 <code>R0</code>-<code>R7</code> 。</li>
</ul>
</li>
<li>
<p>位寻址区 <span class="org-target" id="org-target-----"></span> <br />
位寻址区中的寄存器可 <strong>按位</strong> 进行寻址。由于在汇编中，操作数是 16 进制的，因此无法直接对某个数进行按位运算（无法一个寄存器的某一个位进行寻址）。而位寻址区中的寄存器具有位地址，1 个寄存器地址对应 8 个位地址，寄存器地址 <code>20H</code>-<code>2FH</code> 对应位地址 <code>00H</code>-<code>7FH</code> 。当操作码是位指令时，会使用的是位地址（而不是寄存器地址），操作位地址对应寄存器中某一位的值。要对其他内存区域中储存的数进行位运算时，应先将这个数移动至位寻址区，进行位运算后再移动回来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">BIT</span><span class="p">,</span> <span class="no">C</span>
</span></span><span class="line"><span class="cl"><span class="nf">SETB</span> <span class="no">BIT</span>
</span></span><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">C</span><span class="p">,</span> <span class="no">BIT</span>
</span></span><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">BIT</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <code>BIT</code> 是位地址， <code>C</code> 是位累加器。</p>
<ul>
<li>位指令
<ul>
<li>置位</li>
<li>复位</li>
<li>位逻辑操作</li>
<li>位条件转移</li>
</ul>
</li>
<li>位累加器 <code>C</code> <br />
<code>PSW</code> 寄存器的最高位。</li>
<li>位寻址空间
<ul>
<li>通用内部 RAM 中的 128 bit</li>
<li>特殊功能寄存器中的 83 bit</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用户 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区 <br />
处于内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的 <code>30H</code>-<code>7FH</code> ，以及没有使用的<a href="#org-target-------" rel="">工作寄存器区</a>和<a href="#org-target-----" rel="">位寻址区</a>，通常作为：</p>
<ul>
<li>数据缓冲区 <br />
存放各种变量。</li>
<li>堆栈区 <br />
暂存数据和地址，通常在子程序和中断服务程序中，用于保护断点、现场。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> <br />
外部数据存储器的寻址空间为 <code>0000H</code>-<code>FFFFH</code> (64K)，只能使用 <code>MOVX</code> 等指令，通过累加器 <code>ACC</code> 与片外 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 进行数据传输。</li>
</ul>
</li>
<li>
<p>特殊功能寄存器 <code>SFR</code> <span class="org-target" id="org-target--------"></span> <br />
也称专用寄存器， <code>SFR</code> 主要用于内部硬件功能模块（定时器/计数器、串行口、中断系统等）的管理和控制，用来存放功能模块的控制命令、状态或数据。离散分布于 <code>80H</code>-<code>FFH</code> 的专用寄存器区，未定义的访问无效，部分可以位寻址。除程序计数器 <code>PC</code> 指针和 <code>R0</code>-<code>R7</code> 工作寄存器外，其余所有定义的寄存器均属于特殊功能寄存器。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>符号</th>
<th>名称</th>
<th>作用</th>
<th>地址</th>
<th>位地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>P0</code></td>
<td>Port 0</td>
<td>并行口 <code>P0</code></td>
<td><code>80H</code></td>
<td><code>80H</code>-<code>87H</code></td>
</tr>
<tr>
<td>2</td>
<td><code>SP</code></td>
<td>Stack Pointer</td>
<td>堆栈指针</td>
<td><code>81H</code></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td><code>DPL</code></td>
<td>Data Pointer Low</td>
<td>数据指针 <code>DPTR</code> 低8位</td>
<td><code>82H</code></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td><code>DPH</code></td>
<td>Data Pointer High</td>
<td>数据指针 <code>DPTR</code> 高8位</td>
<td><code>83H</code></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td><code>PCON</code></td>
<td>Power Control</td>
<td>电源控制寄存器</td>
<td><code>87H</code></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td><code>TCON</code></td>
<td>Timer Control</td>
<td>定时器控制寄存器</td>
<td><code>88H</code></td>
<td><code>88H</code>-<code>8FH</code></td>
</tr>
<tr>
<td>7</td>
<td><code>TMOD</code></td>
<td>Timer Mode</td>
<td>定时方式选择寄存器</td>
<td><code>89H</code></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td><code>TL0</code></td>
<td>Timer Low 0</td>
<td>定时器0 低8位</td>
<td><code>8AH</code></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td><code>TL1</code></td>
<td>Timer Low 1</td>
<td>定时器1 低8位</td>
<td><code>8BH</code></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td><code>TH0</code></td>
<td>Timer High 0</td>
<td>定时器0 高8位</td>
<td><code>8CH</code></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td><code>TH1</code></td>
<td>Timer High 1</td>
<td>定时器1 高8位</td>
<td><code>8DH</code></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td><code>P1</code></td>
<td>Port 1</td>
<td>并行口 <code>P1</code></td>
<td><code>90H</code></td>
<td><code>90H</code>-<code>97H</code></td>
</tr>
<tr>
<td>13</td>
<td><code>SCON</code></td>
<td>Serial Control</td>
<td>串行口控制寄存器</td>
<td><code>98H</code></td>
<td><code>98H</code>-<code>9FH</code></td>
</tr>
<tr>
<td>14</td>
<td><code>SBUF</code></td>
<td>Serial Data Buffer</td>
<td>串行口数据寄存器</td>
<td><code>99H</code></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><code>P2</code></td>
<td>Port 2</td>
<td>并行口 <code>P2</code></td>
<td><code>A0H</code></td>
<td><code>A0H</code>-<code>A7H</code></td>
</tr>
<tr>
<td>16</td>
<td><code>IE</code></td>
<td>Interrupt Enable</td>
<td>中断使能寄存器</td>
<td><code>A8H</code></td>
<td><code>A8H</code>-<code>AFH</code></td>
</tr>
<tr>
<td>17</td>
<td><code>P3</code></td>
<td>Port 3</td>
<td>并行口 <code>P3</code></td>
<td><code>B0H</code></td>
<td><code>B0H</code>-<code>B7H</code></td>
</tr>
<tr>
<td>18</td>
<td><code>IP</code></td>
<td>Interrupt Priority</td>
<td>中断优先级寄存器</td>
<td><code>B8H</code></td>
<td><code>B8H</code>-<code>BFH</code></td>
</tr>
<tr>
<td>19</td>
<td><code>PSW</code></td>
<td>Program Status Workd</td>
<td>程序状态字</td>
<td><code>D0H</code></td>
<td><code>D0H</code>-<code>D7H</code></td>
</tr>
<tr>
<td>20</td>
<td><code>A</code></td>
<td>Accumulator</td>
<td>累加器</td>
<td><code>E0H</code></td>
<td><code>E0H</code>-<code>E7H</code></td>
</tr>
<tr>
<td>21</td>
<td><code>B</code></td>
<td></td>
<td>乘除指令中使用</td>
<td><code>F0H</code></td>
<td><code>F0H</code>-<code>F7H</code></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>位寻址 <br />
字节地址的低位为 <code>0H</code> 或 <code>8H</code> 的特殊功能寄存器，是可以进行位寻址的。与通用 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 中的<a href="#org-target-----" rel="">位寻址区</a>构成<a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a>的位寻址空间。</p>
</li>
<li>
<p>程序计数器 <code>PC</code> <span class="org-target" id="org-target------"></span> <br />
<code>PC</code> 是一个 16 位的专用寄存器，作为程序指针则其寻址范围为 0-65535 字节，用于存放下一条要执行的指令地址，复位后为 <code>0000H</code> 。由于其不属于<a href="#org-target--------" rel="">特殊功能寄存器</a>，因此不占用 <code>SFR</code> 地址空间，是不可寻址的，在程序中不能直接访问，但可以通过 <code>LJMP</code> 、 <code>SJMP</code> 等转移指令来间接修改 <code>PC</code> 的值。</p>
</li>
<li>
<p>累加器 <code>A</code> 和 <code>ACC</code> <span class="org-target" id="org-target----"></span> <br />
可作一般 8 位寄存器，也可作外部和内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 数据交换的中转站。</p>
</li>
<li>
<p>寄存器 <code>B</code> <br /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MUL</span> <span class="no">AB</span>                          <span class="c">; A*B=BA
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">DIV</span> <span class="no">AB</span>                          <span class="c">; A/B=A...B
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>电源控制寄存器 <span class="org-target" id="org-target--------"></span> <br /></p>
<table>
<thead>
<tr>
<th>位</th>
<th>7</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>SMOD</code></td>
<td><code>GF1</code></td>
<td><code>GF0</code></td>
<td><code>PD</code></td>
<td><code>IDL</code></td>
</tr>
<tr>
<td>英文注释</td>
<td>Serial Mode</td>
<td>General Flag 1</td>
<td>General Flag 0</td>
<td>Power down bit</td>
<td>Idle mode bit</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>程序状态字 <span class="org-target" id="org-target------"></span> <br /></p>
<table>
<thead>
<tr>
<th>位地址</th>
<th><code>D7H</code></th>
<th><code>D6H</code></th>
<th><code>D5H</code></th>
<th><code>D4H</code></th>
<th><code>D3H</code></th>
<th><code>D2H</code></th>
<th><code>D1H</code></th>
<th><code>D0H</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>CY</code></td>
<td><code>AC</code></td>
<td><code>F0</code></td>
<td><code>RS1</code></td>
<td><code>RS0</code></td>
<td><code>OV</code></td>
<td><code>F1</code></td>
<td><code>P</code></td>
</tr>
<tr>
<td>注释</td>
<td>Carry</td>
<td>Assistant</td>
<td>Flag 0</td>
<td>Register Bank Selector Bit 1</td>
<td>Register Bank Selector Bit 0</td>
<td>Overflow</td>
<td>Flag 1</td>
<td>Parity Flag</td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li>状态位：由指令执行结果由硬件进行置位或清除
<ul>
<li><code>C</code> (<code>CY</code>)：进位标志 <span class="org-target" id="org-target------"></span> <br />
在加减法运算时，最高位发生进位或借位会被置位，否则被复位。</li>
<li><code>AC</code> ：辅助进位标志 <span class="org-target" id="org-target--------"></span> <br />
在加减法运算时，低 4 位向高 4 位发生进位或借位会被置位，否则被复位。</li>
<li><code>OV</code> ：溢出标志 <span class="org-target" id="org-target------"></span>
<ul>
<li>加减运算 <br />
运算结果超出 8 位有符号整数范围时置位。</li>
<li>乘法 <br />
运算结果超出 255 时置位。</li>
<li>除法 <br />
除数为 0 时置位。</li>
</ul>
</li>
<li><code>P</code> ：奇偶标志 <span class="org-target" id="org-target------"></span> <br />
<a href="#org-target----" rel="">累加器</a>中 1 的个数的奇偶性（奇数为 1 ，偶数为 0），会随着 <code>ACC</code> 的变化而变化。</li>
</ul>
</li>
<li>控制位：根据使用需要，用指令设定
<ul>
<li><code>RS0</code>, <code>RS1</code> ：<a href="#org-target-------" rel="">工作寄存器组</a>选择。</li>
<li><code>F0</code>, <code>F1</code> ：用户自定义。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>堆栈指针 <code>SP</code> <br />
存放当前堆栈栈顶地址的 8 位寄存器。8051 的堆栈是向上生成的，即进栈时 <code>SP</code> 增加，出栈时 <code>SP</code> 减小。复位后， <code>SP</code> 为 <code>07H</code> ，即默认堆栈区为 <code>08H</code> 以上的内存区域。</p>
<ul>
<li>操作
<ul>
<li>直接赋值 <br />
因为 <code>08H</code>-<code>1FH</code> 单元为<a href="#org-target-------" rel="">工作寄存器区</a>， <code>20H</code>-<code>2FH</code> 为<a href="#org-target-----" rel="">位寻址区</a>，通常直接对 <code>SP</code> 赋值，将堆栈区设置到用户 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区。</li>
<li>指令操作 <br />
使用堆栈操作指令进行数据的“进栈”和“出栈”，实现一些数据的暂存，以及对现场的保护和恢复。</li>
<li>自动操作
<ul>
<li>调用子程序或响应中断时， <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 会自动将返回地址或断点地址，压入堆栈保护</li>
<li>程序返回时，自动将断点地址弹回<a href="#org-target------" rel="">程序计数器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据指针 <code>DPTR</code> <br />
作为外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 地址的 16 位指针。</p>
</li>
<li>
<p>端口寄存器 <br />
对于端口即引脚的操作实际上是对这些寄存器的操作，其端口引脚与端口寄存器的位具有映射关系，复位后为 <code>FFH</code> 。</p>
<ul>
<li>
<p>结构 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-03-29_06-30-47_7.svg"/>
</figure>

<ul>
<li>位输出 <a href="https://bohonghuang.github.io/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#d-触发器" rel="">D 触发器</a></li>
<li>输出场效应管</li>
<li>读锁存器数据缓冲器</li>
<li>读引脚三态输入缓冲器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="引脚">引脚</h2>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-03-28_08-18-32_Microcontroller%208051%20Pinout%20Diagram.png"/>
</figure>

<ul>
<li>
<p>外部晶振接口 <br />
外接晶体振荡器、电容，为时钟电路提供振荡源，产生时钟信号：</p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-03-29_07-21-25_67.png"/>
</figure>

<ul>
<li><code>XTAL1</code> <br />
接外部晶振一端。是片内振荡电路反相放大器的输入端。</li>
<li><code>XTAL2</code> <br />
接外部晶振另一端。是片内振荡电路反相放大器的输出端，振荡电路的振荡频率为晶振频率。</li>
</ul>
</li>
<li>
<p><code>ALE</code> (Address Latch Enable) <br />
地址锁存允许信号输出端。在访问片外<a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#memory" rel="">存储器</a>或 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 接口</a>时，用于锁存低 8 位地址，以实现低 8 位地址与数据的隔离。</p>
</li>
<li>
<p><code>PSEN</code> (Program Store Enable) <br />
外部<a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">程序存储器</a>选通信号输出端，低电平有效。从外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 取指令时有效，连接到外扩 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 芯片的输出使能端。</p>
</li>
<li>
<p><code>EA</code> (External Access Enable) <br />
片内外程序存储器 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 选择信号输入端。为 <code>1</code> 时从内部开始执行程序，为 <code>0</code> 时只访问外程序存储器。</p>
</li>
<li>
<p><code>RST</code> (Reset) <br />
复位信号输入端，高电平有效。传统的 <a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 微控制器没有内置复位电路，因此需引入外部复位电路：</p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-03-29_07-21-55_72.png"/>
</figure>

<p>该电路有两种复位方式：</p>
<ul>
<li>上电复位（冷启动） <br />
上电时，电容的充电过程产生复位信号，高脉冲需要维持 10ms 以上。上电复位后 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的内容随机。</li>
<li>按键复位（热启动） <br />
高脉冲需要维持 2 个机器周期以上。按键复位后 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的内容保持不变。</li>
</ul>
</li>
<li>
<p><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 接口</a> <br />
4 个 8 位 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 接口</a>：</p>
<ul>
<li><code>P0</code> <br />
双功能的 8 位并行端口：
<ul>
<li>功能 1 <br />
准双向 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 端口</a>，无内部上拉电阻，因此做输出口使用时，需要外接上拉电阻。</li>
<li>功能 2 <br />
分时复用的 8 位数据线 <code>D7H</code>-<code>D0H</code> 和低 8 位地址线 <code>A7H</code>-<code>A0H</code> ，在扩展外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#memory" rel="">存储器</a> 或 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 端口</a> 时使用。</li>
</ul>
</li>
<li><code>P1</code> <br />
带有内部上拉电阻的 8 位准双向 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 端口</a> 。</li>
<li><code>P2</code> <br />
双功能的 8 位并行端口：
<ul>
<li>功能 1 <br />
准双向 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 端口</a>，带有内部上拉电阻。</li>
<li>功能 2 <br />
在扩展外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a>/<a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 时，用作高 8 位地址线 <code>A15H</code>-<code>A8H</code> 。</li>
</ul>
</li>
<li><code>P3</code> <br />
多功能端口：
<ul>
<li>功能 1 <br />
准双向 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface" rel="">I/O 端口</a>，带有内部上拉电阻。</li>
<li>功能 2  <br />
<table>
<thead>
<tr>
<th>引脚</th>
<th>引脚名</th>
<th>英文名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>P3.0</code></td>
<td><code>RXD</code></td>
<td>Receive eXternal Data</td>
<td>串行口输入</td>
</tr>
<tr>
<td><code>P3.1</code></td>
<td><code>TXD</code></td>
<td>Transmitted eXternal Data</td>
<td>串行口输出</td>
</tr>
<tr>
<td><code>P3.2</code></td>
<td><code>INT0</code></td>
<td>Interrupt 0</td>
<td>外部中断0 输入</td>
</tr>
<tr>
<td><code>P3.3</code></td>
<td><code>INT1</code></td>
<td>Interrupt 1</td>
<td>外部中断1 输入</td>
</tr>
<tr>
<td><code>P3.4</code></td>
<td><code>T0</code></td>
<td>Timer 0</td>
<td>定时器0 计数输入</td>
</tr>
<tr>
<td><code>P3.5</code></td>
<td><code>T1</code></td>
<td>Timer 1</td>
<td>定时器1 计数输入</td>
</tr>
<tr>
<td><code>P3.6</code></td>
<td><code>WR</code></td>
<td>Write</td>
<td>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 写选通</td>
</tr>
<tr>
<td><code>P3.7</code></td>
<td><code>RD</code></td>
<td>Read</td>
<td>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 读选通</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中断">中断</h2>
<ul>
<li>
<p>处理</p>
<ul>
<li>保护断点 <br />
硬件自动将 <code>PC</code> 指针压栈。</li>
<li>保护现场 <br />
编写中断服务程序时，须对中断程序中用到的工作寄存器和特殊功能寄存器等内容进行保护。</li>
<li>恢复现场 <br />
编写中断服务程序时，从中断服务程序返回前需要恢复保护的内容。</li>
<li>恢复断点 <br />
中断服务程序最后一条指令必须为 <code>RETI</code> ，用于恢复断点至 <code>PC</code> 指针，继续执行主程序。</li>
</ul>
</li>
<li>
<p>查询 <br />
CPU 在每个机器周期的 <code>S6</code> 状态查询各中断源，并按优先级管理规则处理同时请求的中断源，且在下一个机器周期的 <code>S1</code> 状态响应最高级中断请求，除非：</p>
<ul>
<li>CPU 正在处理相同或更高优先级中断</li>
<li>多机器周期指令中，还未执行到最后一个机器周期</li>
<li>正在执行中断系统的特殊功能寄存器操作 <br />
如 <code>RETI</code> 指令及访问 <code>IE</code>, <code>IP</code> 等操作时要延后一条指令。</li>
</ul>
</li>
<li>
<p>响应 <br />
中断的响应时间：</p>
<ul>
<li>最短为 3 个机器周期
<ul>
<li>查询中断标志位占 1 个机器周期</li>
<li>产生硬件长调用 <code>LCALL</code> 指令需要 2 个机器周期</li>
</ul>
</li>
<li>最长为 8 个机器周期 <br />
如果检测到中断请求时，而 CPU 正在执行 RETI 指令或访问：
<ul>
<li><code>IE</code>, <code>IP</code> 的指令（2 个机器周期），则执行该指令后，还必须再执行 1 条指令才能响应中断。若再执行的一条指令恰好为乘法或除法指令（4 个机器周期），再加上自动保护断点地址的 2 个机器周期，总共需要 8 个机器周期。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使能 <br />
中断使能寄存器 <code>IE</code> ：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>7</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>EA</code></td>
<td><code>ES</code></td>
<td><code>ET1</code></td>
<td><code>EX1</code></td>
<td><code>ET0</code></td>
<td><code>EX0</code></td>
</tr>
<tr>
<td>注释</td>
<td>Enable All Interrupts</td>
<td>Enable Serial Interrupts</td>
<td>Enable Timer 1 Interrupt</td>
<td>Enable External 1 Interrupt</td>
<td>Enable Timer 0 Interrupt</td>
<td>Enable External 0 Interrupt</td>
</tr>
</tbody>
</table>
<ul>
<li><code>EA</code> <br />
只有被置位时，CPU 才会响应中断请求。复位时，CPU 不响应任何中断请求，相当于总开关。</li>
</ul>
</li>
<li>
<p>程序设计 <br />
设计程序时，应使得中断服务程序的执行时间尽可能短。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">        <span class="nf">ORG</span> <span class="mi">0000</span><span class="no">H</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LJMP</span> <span class="no">MAIN</span>    <span class="c">; 跳转到主程序
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">ORG</span> <span class="mi">0003</span><span class="no">H</span>    <span class="c">; INT0 中断入口地址
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">LJMP</span> <span class="no">INT0SUB</span> <span class="c">; 跳转到实际 INT0 中断服务程序存放空间
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="c">;; ...
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">ORG</span> <span class="mi">001</span><span class="no">BH</span>    <span class="c">; T1 中断入口地址
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">LJMP</span> <span class="no">T1SUB</span>   <span class="c">; 跳转到实际 T1 中断服务程序存放空间
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="c">;; ...
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">ORG</span> <span class="mi">0030</span><span class="no">H</span>    <span class="c">; 实际主程序存放区
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MAIN</span><span class="p">:</span>   <span class="no">MOV</span> <span class="no">SP</span><span class="p">,</span><span class="c">#5FH  ; 设置堆栈区
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">SETB</span> <span class="no">IT0</span>     <span class="c">; 选择 INT0 为下降沿触发方式
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">SETB</span> <span class="no">EA</span>      <span class="c">; CPU 开中断
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">SETB</span> <span class="no">EX0</span>     <span class="c">; INT0 开中断
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">SETB</span> <span class="no">ET1</span>     <span class="c">; T1 开中断
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">SETB</span> <span class="no">PX0</span>     <span class="c">; 设置 INT0 为高优先级
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="c">;; ...
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">SJMP</span> <span class="no">$</span>       <span class="c">; 模拟主程序
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">ORG</span> <span class="mi">0800</span><span class="no">H</span>    <span class="c">; INT0 中断服务程序存放区
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">INT0SUB</span><span class="p">:</span><span class="no">PUSH</span> <span class="no">ACC</span>
</span></span><span class="line"><span class="cl">        <span class="nf">PUSH</span> <span class="no">PSW</span>
</span></span><span class="line"><span class="cl">        <span class="c">;; ...
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl">        <span class="nf">POP</span> <span class="no">PSW</span>
</span></span><span class="line"><span class="cl">        <span class="nf">POP</span> <span class="no">ACC</span>
</span></span><span class="line"><span class="cl">        <span class="nf">RETI</span> 	     <span class="c">; 中断返回
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">T1SUB</span><span class="p">:</span>  <span class="no">PUSH</span> <span class="no">ACC</span>     <span class="c">; 定时器 T1 中断服务程序
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="no">PUSH</span> <span class="no">PSW</span>
</span></span><span class="line"><span class="cl">        <span class="c">;; ...
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="nf">POP</span> <span class="no">PSW</span>
</span></span><span class="line"><span class="cl">        <span class="nf">POP</span> <span class="no">ACC</span>
</span></span><span class="line"><span class="cl">        <span class="nf">RETI</span>         <span class="c">; 中断返回
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>扩展</p>
<ul>
<li>
<p>扩展外部中断源 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_21-56-31_image.IQQ8K1.png"/>
</figure>

<p>与门（相当于负逻辑的或）的输入端，当其中一个或几个按键按下时，与门输出的下降沿触发 MCU 的 <code>INT0</code> 。在中断服务程序中，轮询四个 I/O 口的状态，确定是哪个按键被按下。</p>
</li>
<li>
<p>电平方式外部中断请求的撤销 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_21-59-37_image.UVSCL1.png"/>
</figure>

<p>电路的功能是，通过 <a href="https://bohonghuang.github.io/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#d-触发器" rel="">D 触发器</a>将外部中断请求信号的下降沿（可以是非常快速的，短于 8051 的机器周期）转换为稳定的低电平，外部中断设置为低电平触发，等到 CPU 处理中断后，在中断服务程序里给基于 <code>P1.0</code> 一个负脉冲给触发器置位，使得触发器输出高电平，使得中断不再触发，实现请求的撤销。</p>
</li>
</ul>
</li>
<li>
<p>结构 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_20-07-05_image.UAXYK1.png"/>
</figure>

<ul>
<li>
<p>中断源（5 个） <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_20-12-09_image.USI7K1.png"/>
</figure>

<p>5 个中断源的中断入口地址是固定的：</p>
<table>
<thead>
<tr>
<th>中断源</th>
<th>入口地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>INT0</code></td>
<td><code>0003H</code></td>
</tr>
<tr>
<td><code>T0</code></td>
<td><code>000BH</code></td>
</tr>
<tr>
<td><code>INT1</code></td>
<td><code>0013H</code></td>
</tr>
<tr>
<td><code>T1</code></td>
<td><code>001BH</code></td>
</tr>
<tr>
<td><code>TX</code> / <code>RX</code></td>
<td><code>0023H</code></td>
</tr>
</tbody>
</table>
<p>可见，各中断入口地址之间只间隔 8 个字节，对于一般的中断服务程序是容纳不下的。通常是在中断入口地址处安排一条无条件转移指令，使程序跳转到用户安排的中断服务程序的存放区。</p>
<p>当 CPU 响应某中断源的中断请求后，硬件自动将断点地址压入堆栈保护，并将此中断源的中断入口地址赋给 <code>PC</code> ，使 CPU 执行该中断的中断服务程序。</p>
<ul>
<li>
<p>外部中断 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_20-10-46_image.GM49K1.png"/>
</figure>

<p>外部中断请求信号分别从引脚 <code>INT0</code> (<code>P3.2</code>) 和 <code>INT1</code> (<code>P3.3</code>) 引入。</p>
<ul>
<li>触发方式
<ul>
<li>低电平触发方式 <br />
低电平至少保持一个机器周期。</li>
<li>下降沿触发方式 <br />
高低电平至少保持一个机器周期。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>定时器 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_20-11-47_image.L9ECL1.png"/>
</figure>

<p>当 <code>T0</code>, <code>T1</code> 发生溢出（定时时间到）时，向 CPU 请求中断。</p>
<ul>
<li><code>TF0</code>, <code>TF1</code> <br />
溢出标志位，溢出时有硬件置位，并请求中断， CPU 响应后硬件自动复位。</li>
<li><code>IE0</code>, <code>IE1</code> <br />
<code>INT0</code>, <code>INT1</code> 中断标志位，发生中断时由硬件置位，向 CPU 请求中断。如果采用低电平触发方式，只有当中断引脚变为高电平时，才会被复位。</li>
<li><code>IT0</code>, <code>IT1</code> <br />
<code>INT0</code>, <code>INT1</code> 触发方式选择位：
<table>
<thead>
<tr>
<th><code>IT0</code>, <code>IT1</code></th>
<th>触发方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>低电平触发</td>
</tr>
<tr>
<td><code>1</code></td>
<td>下降沿触发</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>串行中断 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-23_20-12-00_image.SNBGL1.png"/>
</figure>

<p>当串行口发送完一个字节数据或接收到一个字节数据时，产生中断请求。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>SM0</code></td>
<td><code>SM1</code></td>
<td><code>SM2</code></td>
<td><code>REN</code></td>
<td><code>TB8</code></td>
<td><code>RB8</code></td>
<td><code>TI</code></td>
<td><code>RI</code></td>
</tr>
<tr>
<td>注释</td>
<td>Serial Mode Bit 0</td>
<td>Serial Mode Bit 1</td>
<td>Serial Mode Bit 2</td>
<td>Receive Enable</td>
<td>Transmit Bit 8</td>
<td>Receive Bit 8</td>
<td>Transmit Interrupt Flag</td>
<td>Receive Interrupt Flag</td>
</tr>
</tbody>
</table>
<ul>
<li><code>TI</code> / <code>RI</code> <br />
发送/接收中断标志。当串行口发送/接收完一帧数据时，由硬件自动置位，必须通过软件复位。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中断相关的特殊功能寄存器（4 个）</p>
</li>
<li>
<p>中断入口</p>
</li>
<li>
<p>顺序查询逻辑电路</p>
</li>
</ul>
</li>
</ul>
<h3 id="中断优先级">中断优先级</h3>
<p>当有多个中断源同时请求中断时，CPU 根据各中断源的优先级别，首先响应优先级高的中断请求，当该中断程序执行完毕返回主程序后并且再执行一条指令后，再响应优先权较低的中断源。这个过程由 MCU 的中断系统自动完成。每个中断源的优先级可通过中断优先级寄存器配置：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>PS</code></td>
<td><code>PT1</code></td>
<td><code>PX1</code></td>
<td><code>PT0</code></td>
<td><code>PX0</code></td>
</tr>
<tr>
<td>注释</td>
<td>Serial Interrupt Priority</td>
<td>Timer 1 Interrupt Priority</td>
<td>External 1 Interrupt Priority</td>
<td>Timer 0 Interrupt Priority</td>
<td>External 0 Interrupt Priority</td>
</tr>
</tbody>
</table>
<p>当中断优先级控制位被置位时，中断源的单刀双掷开关被拨向上方，处于高中断优先级状态。MCU 复位后，中断优先级控制位均被复位，所有中断源处于低中断优先级。</p>
<p>每个优先级内还存在第二个优先级（CPU 轮询顺序）：</p>
<ol>
<li>外部中断 0</li>
<li>定时器 <code>T0</code> 中断</li>
<li>外部中断 1</li>
<li>定时器 <code>T1</code> 中断</li>
<li>串行口中断</li>
</ol>
<h3 id="中断嵌套">中断嵌套</h3>
<p>当 CPU 正在执行低级的中断服务程序时，若有高级中断源请求中断，则从低级中断服务程序中断，去执行高级中断源的服务程序，产生中断嵌套，并能逐级正确返回。如果新的中断请求的优先级小于或等于当前正在处理的中断，则 CPU 暂时不处理这个中断，直到正在处理的中断服务程序执行完毕后，再进行处理。若要在执行当前中断程序时禁止高优先级的中断（即不允许中断嵌套），则在进入中断程序后先关闭 CPU 中断（复位 <code>EA</code> ），或将高级中断源的中断允许位复位，在中断返回前再进行置位。</p>
<h3 id="中断向量表">中断向量表</h3>
<p>存放中断服务程序的入口地址，“向量”可以看作就是函数。</p>
<h2 id="定时器">定时器</h2>
<ul>
<li>
<p>作用 <br />
可以在脉冲的上升沿或下降沿使得计数器的值发生变化：</p>
<ul>
<li>加法计数 <br />
当计数器达到最大值时，再进行加法计数器会溢出。微控制器的片内定时器大多采用加法计数。</li>
<li>减法计数 <br />
独立定时器芯片通常采用减法计数的方式。</li>
</ul>
</li>
<li>
<p>结构 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-25_20-50-25_image4_5_rId2_10248.png"/>
</figure>

<ul>
<li>加法计数器
<ul>
<li><code>T0</code> <br />
2 个级联的 8 位加法计数器 (<code>TH0</code>, <code>TL0</code>)</li>
<li><code>T1</code> <br />
2 个级联的 8 位加法计数器 (<code>TH1</code>, <code>TL1</code>)</li>
</ul>
</li>
<li>输入引脚
<ul>
<li><code>T0</code></li>
<li><code>T1</code></li>
</ul>
</li>
<li>寄存器
<ul>
<li>
<p>模式寄存器 <code>TMOD</code> <br />
其中高 4 位设置 <code>T1</code> ，低 4 位设置 <code>T0</code> 。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>GATE</code></td>
<td><code>C/T</code></td>
<td><code>M1</code></td>
<td><code>M0</code></td>
<td><code>GATE</code></td>
<td><code>C/T</code></td>
<td><code>M1</code></td>
<td><code>M0</code></td>
</tr>
<tr>
<td>注释</td>
<td>Gate</td>
<td>Counter/Timer</td>
<td>Mode Bit 1</td>
<td>Mode Bit 0</td>
<td>Gate</td>
<td>Counter/Timer</td>
<td>Mode Bit 1</td>
<td>Mode Bit 0</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>C/T</code> ：功能选择位</p>
</li>
<li>
<p><code>GATE</code> ：门控位 <br />
用于释放或封锁 <code>INT0</code> 或 <code>INT1</code> 的信号。当且仅当 <code>GATE</code> 被置位时， <code>INT0</code> 或 <code>INT1</code> 才能够控制定时器的启动与停止。
<code>INT0</code> 或 <code>INT1</code> 可以用于测量外部脉冲信号的高电平周期。</p>
</li>
<li>
<p><code>M0</code>, <code>M1</code> <br /></p>
<table>
<thead>
<tr>
<th><code>M1</code></th>
<th><code>M0</code></th>
<th>工作方式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>0</code></td>
<td>方式 0</td>
<td>13 位计数器</td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td>方式 1</td>
<td>16 位计数器</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>0</code></td>
<td>方式 2</td>
<td>初值自动装载的 8 位计数器</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>1</code></td>
<td>方式 3</td>
<td><code>T0</code> 分成 2 个 8 位计数器， <code>T1</code> 停止计数</td>
</tr>
</tbody>
</table>
<ul>
<li>方式 1 <br />
2 个 8 位计数器将组成一个 16 位计数器。若要设置计数器每次计数的初值，需要在中断服务程序中，给 <code>TH0</code> / <code>TH1</code> 与 <code>TL0</code> / <code>TL1</code> 装载初值。这时由于中断响应时间的随机性，定时时间将有一定误差。</li>
<li>方式 2 <br />
这时 <code>TL0</code> / <code>TL1</code> 将成为独立的 8 位加法计数器， <code>TH0</code> / <code>TH1</code> 将变成重载初值寄存器。即 <code>TL0</code> / <code>TL1</code> 溢出时，会自动从 <code>TH0</code> / <code>TH1</code> 预置初值，因此没有定时时间的误差。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制寄存器 <code>TCON</code> <br />
<code>TCON</code> 地址为 <code>88H</code> ，是可进行位寻址的特殊功能寄存器。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>TF1</code></td>
<td><code>TR1</code></td>
<td><code>TF0</code></td>
<td><code>TR0</code></td>
<td><code>IE1</code></td>
<td><code>IT1</code></td>
<td><code>IE0</code></td>
<td><code>IT0</code></td>
</tr>
<tr>
<td>注释</td>
<td>Timer 1 Overflow</td>
<td>Timer 1 Run</td>
<td>Timer 0 Overflow</td>
<td>Timer 0 Run</td>
<td>Interrupt External 1 Edge Flag</td>
<td>Interrupt 1 Type Control Bit</td>
<td>Interrupt External 0 Edge Flag</td>
<td>Interrupt 0 Type Control Bit</td>
</tr>
</tbody>
</table>
<ul>
<li><code>TF0</code> / <code>TF1</code> <br />
溢出标志位，即中断标志位。 <code>T0</code> / <code>T1</code> 溢出时被置位，在 CPU 响应中断后自动复位。</li>
<li><code>TR0</code> / <code>TR1</code> <br />
定时器启动控制位。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>工作模式 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-04-25_20-50-59_image5.png"/>
</figure>

<ul>
<li>定时模式 <br />
当 <code>C/T</code> 为 <code>0</code> 时，定时器处于定时模式。输入脉冲由内部振荡频率的 12 分频脉冲信号（即机器周期）提供。</li>
<li>计数模式 <br />
当 <code>C/T</code> 为 <code>1</code> 时，定时器处于计数模式。输入脉冲由引脚 <code>T0</code> (<code>P3.4</code>) 或 <code>T1</code> (<code>P3.5</code>) 的输入信号提供。每输入 1 个脉冲（的下降沿），计数器的值加 1 ，高电平和低电平的宽度应大于 1 个机器周期。因此外部脉冲的最大频率为系统晶振频率的\(\frac{1}{24}\)。</li>
</ul>
</li>
<li>
<p>周期 <br />
对于 12MHz 的外部晶振，定时器滴答的周期为 \(1\mu\text{s}\)。</p>
</li>
<li>
<p>读取 <br />
CPU 读取计数器值的期间，若计数器是 16 位的，则需要花费多个机器周期，若在读取一个字节的时候，定时器刚好发生溢出，并且使得刚刚读取的字节发生变化，就产生相位误差。</p>
</li>
</ul>
<h2 id="串口">串口</h2>
<ul>
<li>寄存器
<ul>
<li>
<p>串行口控制寄存器 <code>SCON</code> <br /></p>
<table>
<thead>
<tr>
<th>位</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td><code>SM0</code></td>
<td><code>SM1</code></td>
<td><code>SM2</code></td>
<td><code>REN</code></td>
<td><code>TB8</code></td>
<td><code>RB8</code></td>
<td><code>TI</code></td>
<td><code>RI</code></td>
</tr>
<tr>
<td>注释</td>
<td>Serial Mode Bit 0</td>
<td>Serial Mode Bit 1</td>
<td>Serial Mode Bit 2</td>
<td>Receive Enable</td>
<td>Transmit Bit 8</td>
<td>Receive Bit 8</td>
<td>Transmit Interrupt Flag</td>
<td>Receive Interrupt Flag</td>
</tr>
</tbody>
</table>
<ul>
<li><code>SM0</code> / <code>SM1</code> <br />
<table>
<thead>
<tr>
<th><code>SM0</code></th>
<th><code>SM1</code></th>
<th>工作方式</th>
<th>特点</th>
<th>波特率</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td>方式 0</td>
<td>8 位移位寄存器</td>
<td>\(\frac{f_\mathrm{osc}}{12}\)</td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>1</code></td>
<td>方式 1</td>
<td>10 位 UART</td>
<td>可变</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>0</code></td>
<td>方式 2</td>
<td>11 位 UART</td>
<td>\(\frac{f_\mathrm{osc}}{64}\) 或 \(\frac{f_\mathrm{osc}}{32}\)</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>1</code></td>
<td>方式 3</td>
<td>11 位 UART</td>
<td>可变</td>
</tr>
</tbody>
</table>
</li>
<li><code>REN</code> ：接收使能控制位</li>
<li><code>TB8</code> <br />
使用方式 0 或方式 1 时不使用，使用方式 2 或方式 3 时需要事先用软件写入发送的第 8 位。</li>
<li><code>RB8</code> <br />
使用方式 0 时不使用，使用方式 2 或方式 3 时接收到的第 8 位数据自动送入该位，使用方式 1 时停止被送入该位。</li>
<li><code>SM2</code> ：多机通信控制位 <br />
使用方式 2 或方式 3 时，若 <code>SM2</code> 被置位，接收中断标志位将与接收到的第 8 位数据同时置位与复位。</li>
<li><code>TI</code> ：发送中断标志位 <br />
发送完一帧后有硬件置位，必须由软件复位。</li>
<li><code>RI</code> ：接收中断标志位</li>
</ul>
</li>
<li>
<p><a href="#org-target--------" rel="">电源控制寄存器</a> <br /></p>
<ul>
<li><code>SMOD</code> ：波特率选择位 <br />
置位时对波特率进行加倍。</li>
</ul>
</li>
<li>
<p>数据缓冲器 <code>SBUF</code> <br />
串行口上有 2 个独立的数据缓冲器，均表示为 <code>SBUF</code> ：</p>
<ul>
<li>发送缓冲器 <br />
只写不读，当 <code>SBUF</code> 作为源操作数时，对接收缓冲器进行读操作。</li>
<li>接收缓冲器 <br />
只读不写，当 <code>SBUF</code> 作为目的操作数时，对发送缓冲器进行写操作。</li>
</ul>
</li>
</ul>
</li>
<li>工作方式
<ul>
<li>
<p>方式 0 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-05-04_image12.png"/>
</figure>

<p>8 位同步通信方式，通常用于 I/O 端口扩展。</p>
<ul>
<li>引脚 <code>P3.0</code> (<code>TXD</code>) 同时作为数据输入/输出端，发送或接收的是 8 位二进制数（LSB 优先）。
<ul>
<li>
<p>发送 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-01-21_image13_23_rId2_28677.png"/>
</figure>

</li>
<li>
<p>接收 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-03-26_image14.png"/>
</figure>

</li>
</ul>
</li>
<li>引脚 <code>P3.1</code> (<code>RXD</code>) 作为移位同步脉冲输出端，波特率固定为\(\frac{f_\mathrm{osc}}{12}\)。</li>
</ul>
</li>
<li>
<p>方式 1 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-05-25_image17_26_rId2_31749.png"/>
</figure>

<p>10 位（包含 1 位起始位与 1 位停止位）异步通信方式，发送与接收的是 8 位二进制数（LSB 优先）。波特率可编程为\(\frac{2^\texttt{SMOD}}{32}\times \text{T1 溢出速率}\)。对于常用波特率：</p>
<table>
<thead>
<tr>
<th>波特率</th>
<th>晶振频率 (MHz)</th>
<th><code>SMOD</code></th>
<th><code>TH1</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>115200</td>
<td>11.0592</td>
<td>1</td>
<td><code>FFH</code></td>
</tr>
<tr>
<td>38400</td>
<td>11.0592</td>
<td>1</td>
<td><code>FEH</code></td>
</tr>
<tr>
<td>19200</td>
<td>11.0592</td>
<td>1</td>
<td><code>FDH</code></td>
</tr>
<tr>
<td>9600</td>
<td>11.0592</td>
<td>0</td>
<td><code>FDH</code></td>
</tr>
<tr>
<td>4800</td>
<td>11.0592</td>
<td>0</td>
<td><code>FAH</code></td>
</tr>
<tr>
<td>2400</td>
<td>11.0592</td>
<td>0</td>
<td><code>F4H</code></td>
</tr>
<tr>
<td>1200</td>
<td>11.0592</td>
<td>0</td>
<td><code>E8H</code></td>
</tr>
</tbody>
</table>
<p>若使用 12MHz 的晶振，则会引起误差（在波特率 2400 下为\(0.11\%\)），当两个设备的波特率的误差超过\(2.5\%\)时则可能引起通信错误。</p>
<ul>
<li>
<p>引脚 <code>P3.0</code> (<code>TXD</code>) 同时作为数据输出端 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-10-17_image18.png"/>
</figure>

</li>
<li>
<p>引脚 <code>P3.1</code> (<code>RXD</code>) 同时作为数据输入端 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-11-36_image19_28_rId2_33796.png"/>
</figure>

<p>位检测采样以波特率的 16 倍速率对每个位进行检测，把半数以上的结果作为最终的采样结果。第 8 位（停止位）被自动送入 <code>RB8</code> 中。</p>
</li>
</ul>
</li>
<li>
<p>方式 2 / 方式 3 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-15-22_image20.png"/>
</figure>

<p>11 位（包含 1 位起始位、 1 位停止位与 1 位奇偶校验位）异步通信方式，发送与接收的是 8 位二进制数（LSB 优先）。方式 2 与方式 3 仅在波特率的设置上有区别：</p>
<ul>
<li>方式 2 ：波特率固定为\(\frac{2^\texttt{SMOD}}{64}\times f_\mathrm{osc}\)</li>
<li>方式 3 ：波特率可编程为\(\frac{2^\texttt{SMOD}}{32}\times \text{T1 溢出速率}\)（与方式 1 相同）</li>
</ul>
<p>引脚设置与方式 1 相同：</p>
<ul>
<li>
<p>引脚 <code>P3.0</code> (<code>TXD</code>) 同时作为数据输出端 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-21-30_image21.png"/>
</figure>

</li>
<li>
<p>引脚 <code>P3.1</code> (<code>RXD</code>) 同时作为数据输入端 <br /></p>
<figure><img src="https://bohonghuang.github.io/ox-hugo/2022-05-04_11-21-48_image22.png"/>
</figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="低功耗">低功耗</h2>
<p><a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 具有两种低功耗方式，通过<a href="#org-target--------" rel="">电源控制寄存器</a> 中的 <code>IDL</code> 位和 <code>PD</code> 位进行选择。</p>
<table>
<thead>
<tr>
<th>运行方式</th>
<th>电源电压 (V)</th>
<th>时钟频率 (Mhz)</th>
<th>电源电流 (mA)</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常运行</td>
<td>5</td>
<td>12</td>
<td>20</td>
</tr>
<tr>
<td><a href="#%e7%a9%ba%e9%97%b2%e6%a8%a1%e5%bc%8f" rel="">空闲模式</a></td>
<td>5</td>
<td>12</td>
<td>5</td>
</tr>
<tr>
<td><a href="#%e6%8e%89%e7%94%b5%e6%a8%a1%e5%bc%8f" rel="">掉电模式</a></td>
<td>5</td>
<td>12</td>
<td>0.075</td>
</tr>
</tbody>
</table>
<h3 id="空闲模式">空闲模式</h3>
<p>当 <code>IDL</code> 为 1 且 <code>PD</code> 为 0 时，进入空闲模式。</p>
<ul>
<li>特点 <br />
内部时钟电路正常工作，但关闭了 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 的时钟，<a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 停止工作，中断系统、串行口与定时器/计数器继续工作。</li>
<li>唤醒方式
<ul>
<li>复位</li>
<li>触发中断</li>
</ul>
</li>
</ul>
<h3 id="掉电模式">掉电模式</h3>
<p>只要 <code>PD</code> 为 1 ，即进入掉电模式。</p>
<ul>
<li>特点 <br />
内部时钟电路不工作，内部所有功能单元停止工作。</li>
<li>唤醒方式
<ul>
<li>复位</li>
</ul>
</li>
</ul>
<h2 id="指令">指令</h2>
<p>属于 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#complex-instruction-set-computer" rel="">CISC</a> ，有 5 大功能，111 条指令，参考 <a href="https://www.keil.com/support/man/docs/is51/" target="_blank" rel="noopener noreffer">https://www.keil.com/support/man/docs/is51/</a> 。</p>
<ul>
<li>
<p>执行过程</p>
<ul>
<li>
<p>程序 <br />
完成一个特定功能的一系列指令集。</p>
</li>
<li>
<p>指令 <br />
是微控制器指挥各功能部件工作的指示和命令。指令是一组二进制数，其编码格式及功能、类别和数量因 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit" rel="">CPU</a> 的不同而不同，是芯片设计者设定的。 一条指令包括两部分内容：</p>
<ul>
<li>操作码 <br />
指令的功能。</li>
<li>操作数 <br />
指令执行的数据或数据存放的地址。</li>
</ul>
<p>计算机每执行一条指令，都可以分为三个阶段：</p>
<ol>
<li>取指令 <br />
根据程序计数器（程序指针） <code>PC</code> 中的值，从 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 读出现行指令，送到指令寄存器 <code>IR</code> 。</li>
<li>分析指令 <br />
由指令译码器对现行指令进行译码，分析该指令要求实现什么操作，如执行数据传送，还是加、减等运算等。</li>
<li>执行指令 <br />
取出操作数，由控制逻辑电路发出相应的控制信号，完成操作码规定的操作。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>分类</p>
<ul>
<li>长度分类
<ul>
<li>单字节 <br />
指令的操作数隐含在操作码中。</li>
<li>双字节</li>
<li>三字节</li>
</ul>
</li>
<li>耗时分类
<ul>
<li>单机器周期</li>
<li>双机器周期</li>
<li>四机器周期</li>
</ul>
</li>
<li>功能分类
<ul>
<li>数据传送</li>
<li>算术运算</li>
<li>逻辑运算</li>
<li>控制转移</li>
<li>位操作</li>
</ul>
</li>
</ul>
</li>
<li>
<p>格式 <br /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">LOOP:</span>   <span class="nf">OPER</span> <span class="no">DIST</span><span class="p">,</span><span class="no">SRC</span>                <span class="c">; COMMENT
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>LOOP</code> ：标号 <br />
首字母必须为字母。</p>
</li>
<li>
<p><code>OPER</code> ：助记符 <br />
指令的功能。</p>
</li>
<li>
<p><code>DIST,SRC</code> ：操作数 <br /></p>
<ul>
<li>对象
<ul>
<li>立即数</li>
<li>地址</li>
<li>寄存器</li>
<li>标号</li>
</ul>
</li>
<li>符号
<ul>
<li><code>#</code> ：立即数</li>
<li><code>@</code> ：间接寻址</li>
<li><code>+</code> ：变址寻址</li>
</ul>
</li>
</ul>
<p>如果有两个操作数：</p>
<ul>
<li><code>DIST</code> ：目的操作数</li>
<li><code>SRC</code> ：源操作数</li>
</ul>
</li>
<li>
<p><code>COMMENT</code> ：注释</p>
<ul>
<li><code>Rn</code> (<code>R0</code>-<code>R7</code>) <br />
当前选中的<a href="#org-target-------" rel="">工作寄存器组</a>，其地址<a href="#org-target------" rel="">程序状态字</a>中的 <code>RS1</code>, <code>RS0</code> 确定。
<ul>
<li><code>Ri</code> (<code>R0</code>-<code>R1</code>) <br />
当前选中的<a href="#org-target-------" rel="">工作寄存器组</a>中可作为地址指针的两个工作寄存器 <code>R0</code>, <code>R1</code> 。</li>
</ul>
</li>
<li><code>#data</code> <br />
8 位立即数，即指令中给出的 8 位常数。</li>
<li><code>#data16</code> <br />
16 位立即数，即指令中给出的 16 位常数。</li>
<li><code>direct</code> <br />
8 位片内 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 单元（包括<a href="#org-target--------" rel="">特殊功能寄存器</a>）的直接地址。</li>
<li><code>addr16</code> <br />
16 位目的地址，用于 <code>LCALL</code> 和 <code>LJMP</code> 指令中，目的地址在 64KB 的 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 空间中。</li>
<li><code>addr11</code> <br />
11 位目的地址，用于 <code>ACALL</code> 和 <code>AJMP</code> 指令中，目的地址必须与下一条指令的第一字节在同一个 2KB 的 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 空间之内（很少使用）。</li>
<li><code>rel</code> <br />
8 位带符号的偏移字节，用于 <code>SJMP</code> 和所有的条件转移指令中。偏移量以下一条指令第一字节地址为基址，范围为 <code>-128</code>-<code>127</code> 。</li>
<li><code>bit</code> <br />
片内 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 或<a href="#org-target--------" rel="">特殊功能寄存器</a>的直接寻址的位地址。</li>
<li><code>@</code> <br />
间接寻址方式，表示间址寄存器的符号。</li>
<li><code>/</code> <br />
在位操作指令中，表示对该位先求反再参与操作，不影响原始值。</li>
<li><code>(x)</code> <br />
表示 <code>x</code> 中内容。</li>
<li><code>((x))</code> <br />
表示以 <code>x</code> 中的内容为地址寻址。</li>
<li><code>&lt;-</code> <br />
指令操作流程，将箭头右边的内容送到箭头左边的单元中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="寻址方式">寻址方式</h3>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>使用的变量</th>
<th>寻址空间</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#%e7%9b%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">直接寻址</a></td>
<td><code>direct</code></td>
<td>内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的 <code>00H</code>-<code>7FH</code>, <code>SFR</code></td>
</tr>
<tr>
<td><a href="#%e5%af%84%e5%ad%98%e5%99%a8%e5%af%bb%e5%9d%80" rel="">寄存器寻址</a></td>
<td><code>R0</code>-<code>R7</code>, <code>A</code></td>
<td><code>R0</code>-<code>R7</code>, <code>A</code></td>
</tr>
<tr>
<td><a href="#%e5%af%84%e5%ad%98%e5%99%a8%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">寄存器间接寻址</a></td>
<td><code>@R0</code>-<code>R1</code>, <code>SP</code></td>
<td>内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的 <code>00H</code>-<code>FFH</code></td>
</tr>
<tr>
<td></td>
<td><code>@R0</code>-<code>R1</code>, <code>@DPTR</code></td>
<td>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
</tr>
<tr>
<td><a href="#%e7%ab%8b%e5%8d%b3%e5%af%bb%e5%9d%80" rel="">立即寻址</a></td>
<td><code>#data</code>, <code>#data16</code></td>
<td><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a></td>
</tr>
<tr>
<td><a href="#%e5%8f%98%e5%9d%80%e5%af%bb%e5%9d%80" rel="">变址寻址</a></td>
<td>基址寄存器 <code>DPTR</code>, <code>PC</code> 、变址寄存器 <code>A</code></td>
<td><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a></td>
</tr>
<tr>
<td><a href="#%e7%9b%b8%e5%af%b9%e5%af%bb%e5%9d%80" rel="">相对寻址</a></td>
<td>偏移量</td>
<td><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a></td>
</tr>
<tr>
<td><a href="#%e4%bd%8d%e5%af%bb%e5%9d%80" rel="">位寻址</a></td>
<td><code>C</code></td>
<td>位寻址空间</td>
</tr>
</tbody>
</table>
<h4 id="立即寻址">立即寻址</h4>
<p>直接给出操作数作为 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c">#50H            ; (Rn) &lt;- data
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="直接寻址">直接寻址</h4>
<p>给出操作数的内存地址，其中的内容作为操作数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="mi">30</span><span class="no">H</span><span class="p">,</span> <span class="mi">50</span><span class="no">H</span>            <span class="c">; (direct) &lt;- (direct)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="寄存器寻址">寄存器寻址</h4>
<p>给出操作数的寄存器名称，其中的内容作为操作数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="no">R1</span>               <span class="c">; (A) &lt;- (Rn)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="寄存器间接寻址">寄存器间接寻址</h4>
<p>给出操作数地址所在的寄存器，其中的地址的内容作为操作数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R1</span>              <span class="c">; (A) &lt;- ((Ri))
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 <code>80H</code>-<code>FFH</code> 的内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">R0</span><span class="p">,</span> <span class="c">#80H            ; (Ri) &lt;- data
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">R0</span>              <span class="c">; (A) &lt;- ((Ri))
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="变址寻址">变址寻址</h4>
<p>以 <code>DPTR</code> 或 <code>PC</code> （均为 16 位寄存器）作基址寄存器， <code>A</code> 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 地址（寻址空间为 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a>），其中的内容作为操作数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>         <span class="c">; (A) &lt;- ((A)+(DPTR))
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="相对寻址">相对寻址</h4>
<p>用于程序控制，利用指令修改 <code>PC</code> 指针内容实现跳转，操作数为执行完这条指令后的 <code>PC</code> 偏移量。
\[\text{目的地址} = \text{转移指令所在地址} + \text{转移指令字节数} + \text{偏移量}\]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">SJMP</span> <span class="c">#01H
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="位寻址">位寻址</h4>
<p>位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。</p>
<h3 id="数据写入指令">数据写入指令</h3>
<h4 id="mov"><code>MOV</code></h4>
<p>MOVe</p>
<ul>
<li>写入<a href="#org-target----" rel="">累加器</a> <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>               <span class="c">; (A) &lt;- (Rn)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>           <span class="c">; (A) &lt;- (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>              <span class="c">; (A) &lt;- ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data            ; (A) &lt;- data
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>写入<a href="#%e7%9b%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">直接地址</a> <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">direct</span><span class="p">,</span> <span class="no">A</span>           <span class="c">; (direct) &lt;- (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">direct</span><span class="p">,</span> <span class="no">Rn</span>          <span class="c">; (direct) &lt;- (Rn)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">direct1</span><span class="p">,</span> <span class="no">direct2</span>    <span class="c">; (direct1) &lt;- (direct2)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">direct</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>         <span class="c">; (direct) &lt;- ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">direct</span><span class="p">,</span> <span class="c">#data       ; (direct) &lt;- data
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>写入当前的<a href="#org-target-------" rel="">工作寄存器组</a> <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">Rn</span><span class="p">,</span> <span class="no">A</span>               <span class="c">; (Rn) &lt;- (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">Rn</span><span class="p">,</span> <span class="no">direct</span>          <span class="c">; (Rn) &lt;- (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="no">Rn</span><span class="p">,</span> <span class="c">#data           ; (Rn) &lt;- data
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>写入<a href="#%e5%af%84%e5%ad%98%e5%99%a8%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">间接地址</a> <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="err">@</span><span class="no">Ri</span><span class="p">,</span> <span class="no">A</span>              <span class="c">; ((Ri)) &lt;- (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="err">@</span><span class="no">Ri</span><span class="p">,</span> <span class="no">direct</span>         <span class="c">; ((Ri)) &lt;- (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOV</span> <span class="err">@</span><span class="no">Ri</span><span class="p">,</span> <span class="c">#data          ; ((Ri)) &lt;- data
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>写入 16 位寄存器 <br />
只能将立即数传送给 16 位寄存器。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">DPTR</span><span class="p">,</span> <span class="c">#data16       ; (DPTR) &lt;- data16
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>注意，<a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 的指令系统没有 <code>MOV @R0, R1</code> 这类指令，可以看作 <a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 无法同时进行两次除了<a href="#org-target----" rel="">累加器</a>之外<a href="#%e5%af%84%e5%ad%98%e5%99%a8%e5%af%bb%e5%9d%80" rel="">寄存器寻址</a>（包括<a href="#%e5%af%84%e5%ad%98%e5%99%a8%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">寄存器间接寻址</a>这种相当于连续做了两次<a href="#%e5%af%84%e5%ad%98%e5%99%a8%e5%af%bb%e5%9d%80" rel="">寄存器寻址</a>的寻址方式）。</p>
<h4 id="movx"><code>MOVX</code></h4>
<p>MOVe eXternal RAM</p>
<p>对外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 读写必须通过<a href="#org-target----" rel="">累加器</a>并且使用<a href="#%e5%af%84%e5%ad%98%e5%99%a8%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">寄存器间接寻址</a>（16 位）来完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOVX</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">DPTR</span>           <span class="c">; (A) &lt;- ((DPTR))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOVX</span> <span class="err">@</span><span class="no">DPTR</span><span class="p">,</span> <span class="no">A</span>           <span class="c">; ((DPTR)) &lt;- (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOVX</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>             <span class="c">; (A) &lt;- ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">MOVX</span> <span class="err">@</span><span class="no">Ri</span><span class="p">,</span> <span class="no">A</span>             <span class="c">; ((Ri)) &lt;- (A)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="movc"><code>MOVC</code></h4>
<p>MOVe Code</p>
<p>使用<a href="#%e5%8f%98%e5%9d%80%e5%af%bb%e5%9d%80" rel="">变址寻址</a>，将 <code>DPTR</code> 或 <code>PC</code> 的内容与<a href="#org-target----" rel="">累加器</a> <code>A</code> 的内容相加后形成一个 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 单元地址，将其中的内容赋值给累加器 <code>A</code> ，根据使用 <code>DPTR</code> 或 <code>PC</code> 分为：</p>
<ul>
<li>远程查表指令 <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>         <span class="c">; (A) &lt;- ((A) + (DPTR))
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>近程查表指令 <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOVC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">PC</span>           <span class="c">; (PC) &lt;- (PC) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (A) &lt;- ((A) + (PC))
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="栈操作指令">栈操作指令</h3>
<h4 id="push"><code>PUSH</code></h4>
<p>PUSH onto stack</p>
<p>先修改 <code>SP</code> 指针，再使用<a href="#%e7%9b%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">直接寻址</a>将内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的指定单元的内容压入堆栈。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">PUSH</span> <span class="no">direct</span>             <span class="c">; (SP) &lt;- (SP) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; ((SP)) &lt;- (direct)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="pop"><code>POP</code></h4>
<p>POP from stack</p>
<p>先将堆栈栈顶的内容弹出，在使用<a href="#%e7%9b%b4%e6%8e%a5%e5%af%bb%e5%9d%80" rel="">直接寻址</a>送到内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 的指定单元，再修改 <code>SP</code> 指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">POP</span> <span class="no">direct</span>              <span class="c">; (direct) &lt;- ((SP))
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) - 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="数据交换指令">数据交换指令</h3>
<h4 id="xch"><code>XCH</code></h4>
<p>eXCHange</p>
<p>将<a href="#org-target----" rel="">累加器</a> <code>A</code> 与其他单元进行字节交换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">XCH</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>               <span class="c">; (A) &lt;-&gt; (Rn)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XCH</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>           <span class="c">; (A) &lt;-&gt; (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XCH</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>              <span class="c">; (A) &lt;-&gt; ((Ri))
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="xchd"><code>XCHD</code></h4>
<p>eXCHange low-order Digit</p>
<p>将<a href="#org-target----" rel="">累加器</a> <code>A</code> 与 <code>R0</code>-<code>R1</code> 进行半字节交换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">XCHD</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>             <span class="c">; (A)3~0 &lt;-&gt; ((Ri))3~0
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="swap"><code>SWAP</code></h4>
<p>SWAP</p>
<p>将<a href="#org-target----" rel="">累加器</a>的低四位与高四位进行交换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">SWAP</span> <span class="no">A</span>                  <span class="c">; (A)3~0 &lt;-&gt; (A)7~4
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="算术运算指令">算术运算指令</h3>
<h4 id="add"><code>ADD</code></h4>
<p>将源操作数与目的操作数（<a href="#org-target----" rel="">累加器</a> <code>A</code> ）不带进位地相加后（但会改变 <code>C</code> 的值），存放至<a href="#org-target----" rel="">累加器</a> <code>A</code> 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data            ; (A) &lt;- (A) + #data
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>           <span class="c">; (A) &lt;- (A) + (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>              <span class="c">; (A) &lt;- (A) + ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ADD</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>               <span class="c">; (A) &lt;- (A) + (Rn)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="addc"><code>ADDC</code></h4>
<p>将源操作数与目的操作数（<a href="#org-target----" rel="">累加器</a> <code>A</code> ）带进位地相加后，存放至<a href="#org-target----" rel="">累加器</a> <code>A</code> 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ADDC</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data           ; (A) &lt;- (A) + #data + (C)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ADDC</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>          <span class="c">; (A) &lt;- (A) + (direct) + (C)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ADDC</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>             <span class="c">; (A) &lt;- (A) + ((Ri)) + (C)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ADDC</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>              <span class="c">; (A) &lt;- (A) + (Rn) + (C)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="subb"><code>SUBB</code></h4>
<p>将源操作数与目的操作数（<a href="#org-target----" rel="">累加器</a> <code>A</code> ）带借位地相减后，存放至<a href="#org-target----" rel="">累加器</a> <code>A</code> 中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">SUBB</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data           ; (A) &lt;- (A) - #data - (C)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">SUBB</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>          <span class="c">; (A) &lt;- (A) - (direct) - (C)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">SUBB</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>             <span class="c">; (A) &lt;- (A) - ((Ri)) - (C)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">SUBB</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>              <span class="c">; (A) &lt;- (A) - (Rn) - (C)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="inc"><code>INC</code></h4>
<p>将指令中的操作数加 1 ，不影响标志位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">INC</span>  <span class="no">Rn</span>                 <span class="c">; (Rn) &lt;- (Rn) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">INC</span>  <span class="no">direct</span>             <span class="c">; (direct) &lt;- (direct) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">INC</span>  <span class="err">@</span><span class="no">Ri</span>                <span class="c">; ((Ri)) &lt;- ((Ri)) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">INC</span>  <span class="no">A</span>                  <span class="c">; (A) &lt;- (A) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">INC</span>  <span class="no">DPTR</span>               <span class="c">; (DPTR) &lt;-(DPTR) + 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="dec"><code>DEC</code></h4>
<p>将指令中的操作数减 1 ，不影响标志位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">DEC</span>  <span class="no">Rn</span>                 <span class="c">; (Rn) &lt;- (Rn) - 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">DEC</span>  <span class="no">direct</span>             <span class="c">; (direct) &lt;- (direct) - 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">DEC</span>  <span class="err">@</span><span class="no">Ri</span>                <span class="c">; ((Ri)) &lt;- ((Ri)) - 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">DEC</span>  <span class="no">A</span>                  <span class="c">; (A) &lt;- (A) - 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>注意，该指令不能对 <code>DPTR</code> 实现减 1 。</p>
<h4 id="mul"><code>MUL</code></h4>
<p>将 <code>A</code> 和 <code>B</code> 中两个 <strong>无符号</strong> 8 位二进制数相乘，所得的 16 位积：</p>
<ul>
<li>低 8 位存至 <code>A</code> 中</li>
<li>高 8 位存至 <code>B</code> 中</li>
</ul>
<p>如果乘积大于 255 时（高位 <code>B</code> 不为 0 时）， <code>OV</code> 置位，否则 <code>OV</code> 复位，而 <code>C</code> 总是为 0 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MUL</span> <span class="no">AB</span>                  <span class="c">; (B)(A) &lt;- (A) * (B)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="div"><code>DIV</code></h4>
<p>将 <code>A</code> 整除 <code>B</code> ，结果存入 <code>A</code> ，余数存入 <code>B</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">DIV</span> <span class="no">A</span><span class="p">,</span> <span class="no">B</span>                <span class="c">; (A) &lt;- (A) / (B)
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (B) &lt;- (A) % (B)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="da"><code>DA</code></h4>
<p>对两个压缩 <a href="https://bohonghuang.github.io/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#bcd-码" rel="">BCD 码</a>（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 <a href="#add" rel=""><code>ADD</code></a> 和 <a href="#addc" rel=""><code>ADDC</code></a> 指令之后，对 <code>A</code> 中的结果进行修正。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">DA</span> <span class="no">A</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="逻辑运算指令">逻辑运算指令</h3>
<p>不影响标志位，仅当其目的操作数为<a href="#org-target----" rel="">累加器</a> <code>A</code> 时，对<a href="#org-target------" rel="">奇偶标志位</a> <code>P</code> 有影响。</p>
<h4 id="anl"><code>ANL</code></h4>
<p>将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>               <span class="c">; (A) &lt;- (A) and (Rn)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>           <span class="c">; (A) &lt;- (A) and (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>              <span class="c">; (A) &lt;- (A) and ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ANL</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data            ; (A) &lt;- (A) and #data
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ANL</span> <span class="no">direct</span><span class="p">,</span> <span class="no">A</span>           <span class="c">; (direct) &lt;- (direct) and (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ANL</span> <span class="no">direct</span><span class="p">,</span> <span class="c">#data       ; (direct) &lt;- (direct) and #data
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="orl"><code>ORL</code></h4>
<p>将目的操作数和源操作数按位相或，结果存放到目的操作数单元中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ORL</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>               <span class="c">; (A) &lt;- (A) or (Rn)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ORL</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>           <span class="c">; (A) &lt;- (A) or (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ORL</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>              <span class="c">; (A) &lt;- (A) or ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ORL</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data            ; (A) &lt;- (A) or #data
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ORL</span> <span class="no">direct</span><span class="p">,</span> <span class="no">A</span>           <span class="c">; (direct) &lt;- (direct) or (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">ORL</span> <span class="no">direct</span><span class="p">,</span> <span class="c">#data       ; (direct) &lt;- (direct) or #data
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="xrl"><code>XRL</code></h4>
<p>将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">XRL</span> <span class="no">A</span><span class="p">,</span> <span class="no">Rn</span>               <span class="c">; (A) &lt;- (A) xor (Rn)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XRL</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span>           <span class="c">; (A) &lt;- (A) xor (direct)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XRL</span> <span class="no">A</span><span class="p">,</span> <span class="err">@</span><span class="no">Ri</span>              <span class="c">; (A) &lt;- (A) xor ((Ri))
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XRL</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data            ; (A) &lt;- (A) xor #data
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XRL</span> <span class="no">direct</span><span class="p">,</span> <span class="no">A</span>           <span class="c">; (direct) &lt;- (direct) xor (A)
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">XRL</span> <span class="no">direct</span><span class="p">,</span> <span class="c">#data       ; (direct) &lt;- (direct) xor #data
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="clr"><code>CLR</code></h4>
<ul>
<li>当操作数是<a href="#org-target----" rel="">累加器</a> <code>A</code> 时，对字节清零 <br />
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">CLR</span> <span class="no">A</span>                   <span class="c">; (A) &lt;- 0
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="cpl"><code>CPL</code></h4>
<p>对<a href="#org-target----" rel="">累加器</a> <code>A</code> 的内容逐位取反。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">CPL</span> <span class="no">A</span>                   <span class="c">; (A) &lt;- /(A)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="移位运算指令">移位运算指令</h3>
<h4 id="rl"><code>RL</code></h4>
<p>循环左移指令，将 <code>A</code> 的内容循环左移一位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">RL</span> <span class="no">A</span>                    <span class="c">; (A) &lt;- (A) &lt;&lt; 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="rr"><code>RR</code></h4>
<p>循环右移指令，将 <code>A</code> 的内容循环右移一位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">RR</span> <span class="no">A</span>                    <span class="c">; (A) &lt;- (A) &gt;&gt; 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="rlc"><code>RLC</code></h4>
<p>带<a href="#org-target------" rel="">进位标志位</a> <code>C</code> 的循环左移，将 <code>A</code> 的内容和 <code>C</code> 的内容整个左移一位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">RLC</span> <span class="no">A</span>                   <span class="c">; (C)(A) &lt;- (C)(A) &lt;&lt; 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="rrc"><code>RRC</code></h4>
<p>带<a href="#org-target------" rel="">进位标志位</a> <code>C</code> 的循环右移，将 <code>A</code> 的内容和 <code>C</code> 的内容整个右移一位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">RRC</span> <span class="no">A</span>                   <span class="c">; (C)(A) &lt;- (C)(A) &gt;&gt; 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="无条件跳转指令">无条件跳转指令</h3>
<h4 id="ljmp"><code>LJMP</code></h4>
<p>长跳转指令，跳转范围为 <code>0000H</code>-<code>FFFFH</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">LJMP</span> <span class="no">addr16</span>             <span class="c">; (PC) &lt;- addr16
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="ajmp"><code>AJMP</code></h4>
<p>绝对跳转指令，跳转范围为相同 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 的 2KB 区域 (<code>000H</code>-<code>7FFH</code>) 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">AJMP</span> <span class="no">addr11</span>             <span class="c">; (PC) &lt;- (PC) + 2
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (PC)[0..11] &lt;- addr11
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于地址是 11 位的，作为无符号整型时最大可表示 2047 ，对 <code>PC</code> 赋值时高 5 位不变，仅对低 11 位进行赋值，如果不在同一个 2KB 区域中，就会跳转至错误的位置。</p>
<h4 id="sjmp"><code>SJMP</code></h4>
<p>短跳转指令，跳转范围为 <code>80H</code>-<code>7FH</code> （有符号）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">SJMP</span> <span class="no">rel</span>                <span class="c">; (PC) &lt;- (PC) + 2 + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jmp"><code>JMP</code></h4>
<p>散转指令或间接跳转指令。跳转位置取决于 <code>DPTR</code> 与<a href="#org-target----" rel="">累加器</a> <code>A</code> 的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JMP</span> <span class="err">@</span><span class="no">A</span><span class="err">+</span><span class="no">DPTR</span>             <span class="c">; (PC) &lt;- (A) + (DPTR)
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="条件跳转指令">条件跳转指令</h3>
<h4 id="jz"><code>JZ</code></h4>
<p>Jump if <code>ACC</code> equal Zero</p>
<p>当累加器 <code>A</code> 为 0 时跳转，否则继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JZ</span> <span class="no">rel</span>                  <span class="c">; (A) == 0 =&gt; (PC) &lt;- (PC) + 2 + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jnz"><code>JNZ</code></h4>
<p>Jump if <code>ACC</code> Not equal Zero</p>
<p>当累加器 <code>A</code> 不为 0 时跳转，否则继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JNZ</span> <span class="no">rel</span>                 <span class="c">; (A) != 0 =&gt; (PC) &lt;- (PC) + 2 + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="cjne"><code>CJNE</code></h4>
<p>Compare and Jump if Not Equal</p>
<p>对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 <code>C</code> ：</p>
<ul>
<li>操作数1 &gt; 操作数2： <code>C</code> 为 0</li>
<li>操作数1 &lt; 操作数2： <code>C</code> 为 1</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">CJNE</span> <span class="no">A</span><span class="p">,</span> <span class="no">direct</span><span class="p">,</span> <span class="no">rel</span>     <span class="c">; (A) != (direct) =&gt; (PC) &lt;- (PC) + 3 + rel
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">CJNE</span> <span class="no">A</span><span class="p">,</span> <span class="c">#data, rel      ; (A) != data =&gt; (PC) &lt;- (PC) + 3 + rel
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">CJNE</span> <span class="no">Rn</span><span class="p">,</span> <span class="c">#data, rel     ; (Rn) != data =&gt; (PC) &lt;- (PC) + 3 + rel
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="no">CJNE</span> <span class="err">@</span><span class="no">Ri</span><span class="p">,</span> <span class="c">#data, rel    ; ((Ri)) != data =&gt; (PC) &lt;- (PC) + 3 + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="djnz"><code>DJNZ</code></h4>
<p>Decrement and Jump if Not equal Zero</p>
<p>将工作寄存器 <code>Rn</code> 的值减去 1 ，若相减后 <code>Rn</code> 不为 0 则进行跳转 ，否则继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">DJNZ</span> <span class="no">Rn</span><span class="p">,</span> <span class="no">rel</span>            <span class="c">; (Rn) &lt;- (Rn) - 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (Rn) != 0 =&gt; (PC) &lt;- (PC) + 2 + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jbn"><code>JBN</code></h4>
<p>Jump if the Bit is Not set</p>
<p>如果位未置位，则进行跳转。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JNB</span> <span class="no">bit</span><span class="p">,</span> <span class="no">rel</span>            <span class="c">; (bit) == 0 =&gt; (PC) &lt;- (PC) + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jbc"><code>JBC</code></h4>
<p>Jump if the Bit is set and Clear the bit</p>
<p>如果位已置位，则进行跳转，并复位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JBC</span> <span class="no">bit</span><span class="p">,</span> <span class="no">rel</span>            <span class="c">; (bit) == 1 =&gt; (PC) &lt;- (PC) + rel
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">;               (bit) &lt;- 0
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jc"><code>JC</code></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JC</span> <span class="no">rel</span>                  <span class="c">; (C) == 1 =&gt; (PC) &lt;- (PC) + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jnc"><code>JNC</code></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">JNC</span> <span class="no">rel</span>                 <span class="c">; (C) == 0 =&gt; (PC) &lt;- (PC) + rel
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="子程序指令">子程序指令</h3>
<h4 id="lcall"><code>LCALL</code></h4>
<p>该指令可调用存放在 64KB <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 空间任何位置的子程序，跳转前会分别将 <code>PCL</code> （ <code>PC</code> 的低 8 位）与 <code>PCH</code> （ <code>PC</code> 的高 8 位）入栈，便于退出子程序后进行恢复。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">LCALL</span> <span class="no">addr16</span>            <span class="c">; (PC) &lt;- (PC) + 3
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; ((SP)) &lt;- PCL
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; ((SP)) &lt;- PCH
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (PC) &lt;- addr16
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="acall"><code>ACALL</code></h4>
<p>与 <a href="#ajmp" rel=""><code>AJMP</code></a> 一样，跳转的子程序必须位于相同 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 的 2KB 区域 (<code>000H</code>-<code>7FFH</code>) 内。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ACALL</span> <span class="no">addr11</span>            <span class="c">; (PC) &lt;- (PC) + 2
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; ((SP)) &lt;- PCL
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) + 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; ((SP)) &lt;- PCH
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (PC)[0..10] &lt;- addr11
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于 MCU 的 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 容量不再是问题，所以这条指令很少使用。</p>
<h4 id="ret"><code>RET</code></h4>
<p>从堆栈顶部的弹出子程序调用时，压入保护的断点地址到 <code>PC</code> 。子程序的最后一条指令必须是 <code>RET</code> 指令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">RET</span>                     <span class="c">; (PCH) &lt;- ((SP))
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) - 1
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (PCL) &lt;- ((SP))
</span></span></span><span class="line"><span class="cl"><span class="c"></span>                        <span class="c">; (SP) &lt;- (SP) - 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="reti"><code>RETI</code></h4>
<p>除具有 <a href="#ret" rel=""><code>RET</code></a> 的功能外,还可以恢复中断逻辑（不能互换使用），中断子程序的最后一条指令，必须是 <code>RETI</code> 指令。</p>
<h3 id="空指令">空指令</h3>
<h4 id="nop"><code>NOP</code></h4>
<p>无实际作用，占用一个<a href="#%e6%9c%ba%e5%99%a8%e5%91%a8%e6%9c%9f" rel="">机器周期</a>时间。常用于软件延时。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">NOP</span>                     <span class="c">; (PC) &lt;- (PC) + 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="伪指令">伪指令</h3>
<p>伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。</p>
<h4 id="org"><code>ORG</code></h4>
<p>给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">ORG</span> <span class="no">addr16</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <code>addr16</code> 是直接给出的 16 位二进制数。</p>
<h4 id="equ"><code>EQU</code></h4>
<p>给数据或表达式赋予字符名称，以便在 <strong>之后的</strong> 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">NAME</span> <span class="no">EQU</span> <span class="no">expr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">DATA1</span> <span class="no">EQU</span> <span class="mi">22</span><span class="no">H</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="db"><code>DB</code></h4>
<p>将常数或字符 <code>data</code> 串存入标号开始的连续存储单元中，通常用于定义数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">TABLE:</span>  <span class="nf">DB</span> <span class="no">data</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">TABLE:</span>  <span class="nf">DB</span> <span class="err">&#34;</span><span class="no">ABC</span><span class="err">&#34;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="no">FFH</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">51 单片机</a> 中只能用于 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 中。</p>
<h4 id="dw"><code>DW</code></h4>
<p>将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">LBAEL:</span>  <span class="nf">DW</span> <span class="no">data</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">LBAEL:</span>  <span class="nf">DW</span> <span class="mi">1234</span><span class="no">H</span><span class="p">,</span> <span class="no">FFFFH</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时 <code>LABEL</code> 对应的存储单元里有 <code>12H</code>, <code>34H</code>, <code>FFH</code>, <code>FFH</code> 。
<code>DW</code> 与 <code>DB</code> 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 <a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">51 单片机</a> 中只能用于 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 中。</p>
<h4 id="bit"><code>BIT</code></h4>
<p>给位地址 <code>addr</code> 赋予字符名称 <code>NAME</code> ，以便在程序中直接用这个名称代替这个位地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">NAME</span> <span class="no">BIT</span> <span class="no">addr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="end"><code>END</code></h4>
<p>表示汇编程序的结束，一个程序中有且仅有一条。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">END</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="ds"><code>DS</code></h4>
<p>使得汇编程序从标号开始保留若干个存储单元。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">NAME:</span>   <span class="nf">DS</span> <span class="no">N</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">51 单片机</a> 中只能用于 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a> 中。</p>
<h4 id="data"><code>DATA</code></h4>
<p>给数据或表达式赋予字符名称，以便在 <strong>整个</strong> 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">NAME</span> <span class="no">DATA</span> <span class="no">data</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="xdata"><code>XDATA</code></h4>
<h2 id="c51">C51</h2>
<h3 id="变量">变量</h3>
<h4 id="变量类型">变量类型</h4>
<table>
<thead>
<tr>
<th>标准</th>
<th>数据类型</th>
<th>位数</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准 C 语言</td>
<td><code>signed char</code></td>
<td>8</td>
<td><code>-128</code>-<code>127</code></td>
</tr>
<tr>
<td></td>
<td><code>unsigned char</code></td>
<td>8</td>
<td><code>0</code>-<code>255</code></td>
</tr>
<tr>
<td></td>
<td><code>signed int</code></td>
<td>16</td>
<td><code>-32768</code>-<code>32767</code></td>
</tr>
<tr>
<td></td>
<td><code>unsigned int</code></td>
<td>16</td>
<td><code>0</code>-<code>-65535</code></td>
</tr>
<tr>
<td></td>
<td><code>signed long</code></td>
<td>32</td>
<td><code>-2147483648</code>-<code>2147483647</code></td>
</tr>
<tr>
<td></td>
<td><code>unsigned long</code></td>
<td>32</td>
<td><code>0</code>-<code>4294967295</code></td>
</tr>
<tr>
<td></td>
<td><code>float</code></td>
<td>32</td>
<td></td>
</tr>
<tr>
<td><a href="#c51" rel="">C51</a></td>
<td><code>bit</code></td>
<td>1</td>
<td><code>0</code>-<code>1</code></td>
</tr>
<tr>
<td></td>
<td><code>sbit</code></td>
<td>1</td>
<td><code>0</code>-<code>1</code></td>
</tr>
<tr>
<td></td>
<td><code>sfr</code></td>
<td>8</td>
<td><code>0</code>-<code>255</code></td>
</tr>
<tr>
<td></td>
<td><code>sfr16</code></td>
<td>16</td>
<td><code>0</code>-<code>65535</code></td>
</tr>
</tbody>
</table>
<!--list-separator-->
<ul>
<li>
<p><code>bit</code></p>
<p>用于声明一个位变量，其寻址空间在通用 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 中，位地址为 <code>00H</code>-<code>7FH</code> 的位空间。不能声明一个位变量的指针或数组。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p><code>sbit</code></p>
<p>用于声明一个<a href="#org-target--------" rel="">特殊功能寄存器</a>中的位变量，其寻址空间在<a href="#org-target--------" rel="">特殊功能寄存器</a>的可位寻址空间中。声明时指定的不是初始值，而是变量的地址，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">sbit</span> <span class="n">P</span> <span class="o">=</span> <span class="mh">0xD0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>很像是 <a href="https://bohonghuang.github.io/posts/notes/c++/#c-plus-plus" rel="">C++</a> 中的引用类型，本质上是一个地址，但进行赋值、运算等操作时会自动解引用。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p><code>sfr</code></p>
<p>定义<a href="#org-target--------" rel="">特殊功能寄存器</a>中的字节变量，与 <a href="#sbit" rel=""><code>sbit</code></a> 一样，本质上是一个地址，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">sfr</span> <span class="n">P0</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>=</code> 后必须是 <code>80H</code>-<code>FFH</code> 之间的常数。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p><code>sfr16</code></p>
<p>定义<a href="#org-target--------" rel="">特殊功能寄存器</a>中的双字节变量，与 <a href="#sfr" rel=""><code>sfr</code></a> 一样，本质上是一个地址，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">sfr16</span> <span class="n">DPTR</span> <span class="o">=</span> <span class="mh">0x82</span><span class="p">;</span>              <span class="c1">// DPL = 0x82, DPH = 0x83
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在变量定义中出现的是低字节地址。</p>
</li>
</ul>
<h4 id="变量位置">变量位置</h4>
<table>
<thead>
<tr>
<th>存储器类型</th>
<th>存储空间描述</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>code</code></td>
<td>内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory" rel="">ROM</a></td>
<td>64KB</td>
</tr>
<tr>
<td><code>data</code></td>
<td>可直接访问的内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>低 128B</td>
</tr>
<tr>
<td><code>idata</code></td>
<td>可间接访问的内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>256B</td>
</tr>
<tr>
<td><code>bdata</code></td>
<td>可位寻址的内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>16B (<code>20H</code>-<code>2FH</code>)</td>
</tr>
<tr>
<td><code>xdata</code></td>
<td>外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>最大 64KB</td>
</tr>
<tr>
<td><code>pdata</code></td>
<td>分页的 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a></td>
<td>256B/页</td>
</tr>
</tbody>
</table>
<p>访问内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 比较快，应该把频繁使用的变量放置在内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 中。在变量类型和变量之间可以插入变量位置修饰符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">code</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                 <span class="c1">// 内部 ROM
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果未指定存储器类型（即变量的位置），编译器根据编译器参数（ <code>SMALL</code>, <code>COMPACT</code>, <code>LARGE</code> ）自动选择默认存储器类型：</p>
<table>
<thead>
<tr>
<th>存储模式</th>
<th>存储器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SMALL</code></td>
<td><code>data</code></td>
</tr>
<tr>
<td><code>COMPACT</code></td>
<td><code>pdata</code></td>
</tr>
<tr>
<td><code>LARGE</code></td>
<td><code>xdata</code></td>
</tr>
</tbody>
</table>
<ul>
<li><code>SMALL</code> <br />
缺省变量参数均装入内部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a>，优点是访问速度快，缺点是空间有限，适用于小程序。</li>
<li><code>LARGE</code> <br />
缺省变量可放在 64KB 的外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区，优点是空间大，可存变量多，缺点是速度较慢。</li>
<li><code>COMPACT</code> <br />
缺省变量均位于外部 <a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory" rel="">RAM</a> 区的一页 (256B)，速度和空间适中。</li>
</ul>
<h3 id="指针">指针</h3>
<h4 id="通用指针">通用指针</h4>
<p>通用指针可以指向任意位置的变量，指针变量本身占用 3 字节的空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="n">data</span> <span class="n">ptr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="特殊指针">特殊指针</h4>
<p>指针变量本身可以指定变量位置，由于普通变量可以指定位置，指针大小会根据变量不同的位置改变。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">code</span> <span class="o">*</span><span class="p">(</span><span class="n">data</span> <span class="n">ptr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据 C 语言的变量定义等式，意思是位于 <code>data</code> 中的指针 <code>ptr</code> 经过解引用后得到位于 <code>code</code> 中的 <code>int</code> 变量。</p>
<h3 id="函数">函数</h3>
<p>在标准 C 语言函数定义的基础上，在函数原型定义和函数体之间可以加入修饰符：</p>
<ul>
<li><code>small</code>, <code>compact</code>, <code>large</code> <br />
函数里的变量存放位置。</li>
<li><code>reentrant</code> <br />
说明该函数可递归或重入的。</li>
<li><code>interrupt n</code> <br />
说明该函数是个中断处理子程序， <code>n</code> 的取值为 <code>0</code>-<code>31</code> 。</li>
<li><code>using n</code> <br />
指定函数使用的<a href="#org-target-------" rel="">工作寄存器组</a>。若不指定，则选用第 0 个<a href="#org-target-------" rel="">工作寄存器组</a>。</li>
</ul>
<p>如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">function</span><span class="p">()</span> <span class="n">compact</span> <span class="n">reentrant</span> <span class="n">interrupt</span> <span class="mi">0</span> <span class="n">using</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="标准库">标准库</h3>
<h4 id="本征函数">本征函数</h4>
<p><a href="#c51" rel="">C51</a> 的本征库函数定义在 <code>intrins.h</code> 头文件中。</p>
<ul>
<li><code>_crol_</code> <br />
返回将 8 位整型 (<code>char</code>) 变量左移指定位数的结果。</li>
<li><code>_cror_</code> <br />
返回将 8 位整型 (<code>char</code>) 变量右移指定位数的结果。</li>
<li><code>_irol_</code> <br />
返回将 16 位整型 (<code>int</code>) 变量左移指定位数的结果。</li>
<li><code>_iror_</code> <br />
返回将 16 位整型 (<code>int</code>) 变量右移指定位数的结果。</li>
<li><code>_lrol_</code> <br />
返回将 32 位整型 (<code>long</code>) 变量左移指定位数的结果。</li>
<li><code>_lror_</code> <br />
返回将 32 位整型 (<code>long</code>) 变量右移指定位数的结果。</li>
<li><code>_nop_</code> <br />
相当于插入空指令 <a href="#nop" rel=""><code>NOP</code></a> 。</li>
<li><code>_testbit_</code> <br />
相当于对位变量使用 <a href="#jbc" rel=""><code>JBC</code></a> 。</li>
<li><code>_chkfloat_</code> <br />
测试并返回浮点数状态。</li>
</ul>
<h4 id="非本征函数">非本征函数</h4>
<p>效率与<a href="#%e6%9c%ac%e5%be%81%e5%87%bd%e6%95%b0" rel="">本征函数</a>相比较低。</p>
<ul>
<li><a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 库函数
<ul>
<li><code>reg51.h</code> <br />
包括了所有 <a href="https://bohonghuang.github.io/posts/notes/8051/" rel="">8051</a> 的<a href="#org-target--------" rel="">特殊功能寄存器</a>及其位定义，一般系统都必须包括本文件。</li>
<li><code>absacc.h</code> <br />
定义绝对存储器访问的宏，以确定各存储空间的绝对地址。</li>
</ul>
</li>
<li>C 语言标准库
<ul>
<li><code>stdlib.h</code> <br />
包括数据类型转换和存储器分配函数。</li>
<li><code>string.h</code> <br />
包含字符串和缓存操作函数。</li>
<li><code>stdio.h</code> <br />
包含流输入输出的原型函数。</li>
<li><code>math.h</code> <br />
包含数学计算库函数。</li>
</ul>
</li>
</ul>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-06-18</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="#" onclick="return false;" title="分享到 Twitter" data-sharer="twitter" data-url="https://bohonghuang.github.io/posts/notes/8051/" data-title="8051" data-hashtags="单片机,汇编语言"><i class="fab fa-twitter fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Facebook" data-sharer="facebook" data-url="https://bohonghuang.github.io/posts/notes/8051/" data-hashtag="单片机"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://bohonghuang.github.io/posts/notes/8051/" data-title="8051"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Line" data-sharer="line" data-url="https://bohonghuang.github.io/posts/notes/8051/" data-title="8051"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@v5.21.1/icons/line.svg"></i></a><a href="#" onclick="return false;" title="分享到 微博" data-sharer="weibo" data-url="https://bohonghuang.github.io/posts/notes/8051/" data-title="8051"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="https://bohonghuang.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a>,&nbsp;<a href="https://bohonghuang.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="https://bohonghuang.github.io/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="https://bohonghuang.github.io/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/" class="prev" rel="prev" title="微机原理"><i class="fas fa-angle-left fa-fw"></i>微机原理</a>
            <a href="https://bohonghuang.github.io/posts/notes/c&#43;&#43;/" class="next" rel="next" title="C&#43;&#43;">C&#43;&#43;<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/BohongHuang" target="_blank" rel="noopener noreferrer">黄博宏</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.0/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script type="text/javascript" src="https://bohonghuang.github.io/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="https://bohonghuang.github.io/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/topbar@1.0.1/topbar.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@sliphua/pjax@2.4.0/dist/pjax.min.js"></script><script type="text/javascript" src="https://bohonghuang.github.io/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'UA-221867158-1');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-221867158-1" async></script></div>

<div class="pjax-assets"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.2/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"VNmzG0eMncQlMctEkgmdt3Bm-gzGzoHsz","appKey":"g02JnVghlriklkak3Tum8f2q","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"visitor":true}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"},"sharerjs":true};</script><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://bohonghuang.github.io/lib/valine/valine.min.css">
    <noscript><link rel="stylesheet" href="https://bohonghuang.github.io/lib/valine/valine.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"></noscript></div>
</body>

</html>