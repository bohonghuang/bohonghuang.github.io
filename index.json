[{"categories":null,"content":"前言 Common Lisp 虽然是动态语言，但分发可执行的应用程序是比较方便的，因为大多数 Lisp 实现支持将运行环境 Dump 出镜像，可以实现几乎无外部依赖（如 SBCL 生成的镜像只依赖于 libm 、 libc 与 libzstd 等具有很强向后兼容性的库）的可执行文件分发，也就是在一台系统足够旧的计算机上生成的可执行文件直接扔到大多数同平台、同架构的计算机上往往可以直接运行，无需进行编译、安装或解压，这一点是大部分动态语言无法做到的。 但如果需要使用 C 来编写一些性能敏感的代码或通过 FFI 使用基于 C ABI 的外部库，发布应用程序时一般就需要带上不少动态库，一定程度上破坏了这种 Image-based 分发方式的便携性。虽然 Lisp 镜像实际上可以存放各种数据，包括图片、音乐等，理论上只要能加载进内存的内容，就可以将他们存入 Lisp 镜像，理论上是可以将这些动态链接库“打包”在 Lisp 镜像里，然后程序运行时将他们“解包”到磁盘上再进行加载的，但对于一些从设计上就用于静态链接的库（如 stb 、 raylib ），这些库一般只包括一个存有声明与实现的头文件，在 C 里直接 #include 即可使用，而在 Lisp 这边，则需要先手动编写一个 C 的源文件 #include 想要使用的静态库，然后调用编译器将其编译为动态连接库，然后才可以在 Lisp 程序里加载这些库然后运行，显然整个应用程序的构建过程是相对比较繁琐的。 好在 CFFI 提供了对于静态链接的支持，在 ASDF 的系统定义文件里声明好需要使用或手动编写的 C 文件， 那么在构建时， ASDF 就可以自动调用 C 编译器输出对应的目标文件，然后将它们静态链接到 Lisp 的运行环境里。值得一提的是目前只有 SBCL 、 ECL 、 Clisp 支持这种静态链接的构建方式，并且相关的文档资料十分不完善。本人折腾了很久，实测只有带 --with-sb-linkable-runtime 编译的 SBCL 才可以正常地进行静态链接与加载，这里以一个示例应用程序记录一下整个过程。 ","date":"2022-12-24","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-sbcl-%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84-lisp-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/:1:0","series":null,"tags":["Lisp","SBCL"],"title":"使用 SBCL 构建静态链接的 Lisp 可执行文件","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-sbcl-%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84-lisp-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/#前言"},{"categories":null,"content":"步骤 下载 SBCL 的源代码并进行编译安装 SBCL_VERSION=\"2.2.11\" curl -L \"http://downloads.sourceforge.net/project/sbcl/sbcl/$SBCL_VERSION/sbcl-$SBCL_VERSION-source.tar.bz2\" -o \"sbcl-$SBCL_VERSION-source.tar.bz2\" tar -xvjf \"sbcl-$SBCL_VERSION-source.tar.bz2\" cd \"sbcl-$SBCL_VERSION\" sh ./make.sh --fancy --with-sb-linkable-runtime --prefix=~/.local/ sh ./install.sh 示例 ASDF 项目 在 Quicklisp 的 local-projects 目录下创建示例项目： . ├── my-lib.c ├── package.lisp └── test-static.asd 其中： my-lib.c 简单起见，这里只定义了一个用于测试的函数： int plus_one(int i) { return i + 1; } package.lisp (defpackage test-static (:use #:cl #:alexandria #:cffi) (:nicknames #:test) (:export #:main)) (in-package #:test-static) (cffi:defcfun \"plus_one\" :int (i :int)) (defun main () (format t \"~d\" (plus-one 3))) Lisp 程序也很简单，就是调用刚刚定义的 plus_one 函数，看一下能不能输出正确的结果 4 。 test-static.asd #+sb-core-compression (defmethod asdf:perform ((o asdf:image-op) (c asdf:system)) (uiop:dump-image (asdf:output-file o c) :executable t :compression t)) (defsystem test-static :version \"1.0.0\" :defsystem-depends-on (:cffi-grovel) :build-operation \"static-program-op\" :build-pathname \"test-static\" :entry-point \"test-static:main\" :components ((:c-file \"my-lib\") (:file \"package\")) :depends-on (#:asdf #:cffi)) 其中： build-operation 指定了调用 asdf:make 是默认进行的构建操作，根据 CFFI 的手册，这里使用 static-program-op 。 build-pathname 是构建的可执行文件的相对路径。 entry-point 指定应用程序的入口函数。 c-file 需要编译并静态链接的 C 源文件名。如果只是想静态链接已有的 C 库，也可以使用 CFFI-Grovel 语法包含现有 C 文件。 值得一提的是 SBCL 的核心压缩似乎会将静态链接的库也一起进行压缩，这意味着当静态链接的库比较多的时候， SBCL 输出的可执行文件与 C/C++ 相比可能还具有体积的优势。 构建可执行文件 进入到刚刚构建完成 SBCL 的库目录（即带有 sbcl.core 与 contrib 的目录，上面的构建命令对应的目录是 ~/.local/lib/sbcl ，如果不是在这个目录下进行构建，那么可能在构建时会出现 (require \"asdf\") 失败的情况），运行 SBCL ，在 REPL 里输入： (asdf:load-system :cffi-grovel) (asdf:operate :static-program-op :test-static) This is SBCL 2.2.11, an implementation of ANSI Common Lisp. More information about SBCL is available at \u003chttp://www.sbcl.org/\u003e. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. ​* (asdf:make :test-static) WARNING: redefining PERFORM (#\u003cSTANDARD-CLASS ASDF/BUNDLE:IMAGE-OP\u003e #\u003cSTANDARD-CLASS ASDF/SYSTEM:SYSTEM\u003e) in DEFMETHOD ; compiling file \"/home/coco24/.quicklisp/local-projects/test-static/package.lisp\" (written 24 DEC 2022 12:38:04 PM): ; wrote /home/coco24/.cache/common-lisp/sbcl-2.2.11-linux-x64/home/coco24/.quicklisp/local-projects/test-static/package-tmpGHU3ALSV.fasl ; compilation finished in 0:00:00.010 ; ar rcsDT /home/coco24/.cache/common-lisp/sbcl-2.2.11-linux-x64/home/coco24/.quicklisp/local-projects/test-static/test-static-tmpAAURSO1.a /home/coco24/.cache/common-lisp/sbcl-2.2.11-linux-x64/home/coco24/.quicklisp/local-projects/test-static/test_static__my_lib.o ; cc -o /home/coco24/.cache/common-lisp/sbcl-2.2.11-linux-x64/home/coco24/.quicklisp/local-projects/test-static/test-static-runtime-tmp5GEXGEG5 -g -Wl,--export-dynamic /home/coco24/.local/bin/../lib/sbcl/sbcl.o -Wl,--whole-archive /home/coco24/.cache/common-lisp/sbcl-2.2.11-linux-x64/home/coco24/.quicklisp/local-projects/test-static/test-static.a -Wl,--no-whole-archive -ldl -lpthread -lzstd -lm -lm ; /home/coco24/.cache/common-lisp/sbcl-2.2.11-linux-x64/home/coco24/.quicklisp/local-projects/test-static/test-static-runtime --core /home/coco24/.local/bin/../lib/sbcl/sbcl.core --noinform --non-interactive --no-sysinit --no-userinit --eval \"'(#.(require \\\"asdf\\\") #.(in-package :asdf) #.(progn (setf *central-registry* (quote (#P\\\"/home/coco24/.quicklisp/quicklisp/\\\"))) (initialize-source-registry (quote nil)) (initialize-output-translations (quote nil)) (upgrade-asdf) (load #P\\\"/home/coco24/.quicklisp/setup.lisp\\\") (load-system \\\"cffi-grovel\\\") (defmethod operation-done-p ((operation program-op) (system (eql (find-system \\\"test-static\\\")))) nil) (defmethod output-files ((operation program-op) (system (eql (find-system \\\"test-static\\\")))) (values (list #P\\\"/home","date":"2022-12-24","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-sbcl-%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84-lisp-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/:2:0","series":null,"tags":["Lisp","SBCL"],"title":"使用 SBCL 构建静态链接的 Lisp 可执行文件","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-sbcl-%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84-lisp-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/#步骤"},{"categories":null,"content":"后记 前面也提到了， SBCL 运行时本身就依赖了一些兼容性较好的动态链接库，而如果要将运行时也完全地进行静态链接，可以参考这篇文章。一般对于开发而言，还是推荐使用动态链接的方式通过 CFFI 调用外部库，这样可以动态地加载与更新这些库，而不需要像静态链接那样反复 Dump 镜像然后重启会话，破坏 Lisp 交互式开发的体验。而 CFFI 显然也是考虑了这一点，在加载 ASDF 系统时会将依赖的 C 源文件编译两次，一次编译为动态链接库文件，一次编译为目标文件，并在 当前会话 里自动加载这个动态链接库，可以使用 (cffi:list-foreign-libraries) 进行查看已经加载的动态链接库。在应用程序发布时，在开源协议允许的情况下，使用静态链接可能是个不错的选择，不过需要记得将这些静态链接库对应的 cffi:use-foreign-library 语句删掉，否则发布的应用程序在运行时还是会尝试去加载这些动态链接库。 ","date":"2022-12-24","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-sbcl-%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84-lisp-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/:3:0","series":null,"tags":["Lisp","SBCL"],"title":"使用 SBCL 构建静态链接的 Lisp 可执行文件","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-sbcl-%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84-lisp-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/#后记"},{"categories":null,"content":"在 Emacs 里一边用 EWW （Emacs 内置的浏览器）阅读博客文章或技术文档，一边用 Org-mode 记笔记和运行代码十分方便，不过个人认为使用 EWW 在文章里阅读代码时，比较头疼的地方有： 很多博客文章的代码高亮是使用 Javascript 插件做的，EWW 不支持 Javascript 就只能干瞪眼了。 有的文章的代码高亮是嵌入在 HTML 里的，但是风格往往与 Emacs 的主题格格不入，看着不舒服。 很多关于 Lisp 的文章，原文章的代码高亮就比较废，大部分宏与函数一样，不提供高亮（其实是 Javascript 高亮插件的问题），有时候括号还会看得眼花缭乱，更不用说在 EWW 里了。 因此本人经常将文章里的代码块复制出来，然后粘贴到一个开启了这个语言 Mode 的 Buffer 里阅读代码。为了同时能看文章的上下文内容，我还经常再将这些代码复制回 EWW 的 Buffer 中，替换掉原来的代码块（先禁用 read-only-mode ，粘贴，再启用 read-only-mode ）。这个过程会经常打断阅读与思路，降低阅读体验，尤其是文章中代码块比较多的时候。 于是自己写了一个简单的包，理论上可以适用于任意 Buffer （包括用于阅读 EPUB 的 nov.el 或 Markdown Buffer）： 可以在 EWW 等 Buffer 中一键高亮大部分文章的所有代码块（需要指定文章使用的编程语言，也就是 Emacs 里的 Mode），也可以单独对一个选区进行代码高亮（理论上适用于任何 Buffer）。 可以借助 tree-sitter 、 sly 、 emacs-lisp-mode 获得比所有 Javascript 高亮插件更精确、更美观的代码高亮。 可以借助类似于 rainbow-delimiters （彩虹括号）之类的包来辅助阅读关于 Lisp 的或代码结构比较复杂的文章。 阅读关于 Lisp 的文章与 Rust 库的文档效果如下： 原理其实很简单，就是将具有相同 Face 的文本（EWW 通常使用 default 与 shr-code 渲染网页中使用等宽字符的地方）打包放到一个启用了指定 Mode 的 Buffer 里进行语法高亮，再替换掉原来的文本。 代码放在 Github 上给大家参考： https://github.com/bohonghuang/mode-fontify ","date":"2022-10-12","objectID":"/posts/blog/%E5%9C%A8-emacs-%E7%9A%84%E4%BB%BB%E6%84%8F-buffer-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%9F%9F%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/:0:0","series":null,"tags":["org-mode","Emacs"],"title":"在 Emacs 的任意 Buffer 中进行区域代码高亮","uri":"/posts/blog/%E5%9C%A8-emacs-%E7%9A%84%E4%BB%BB%E6%84%8F-buffer-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%9F%9F%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/#"},{"categories":null,"content":"最近将一个 C++ 的音频处理库（大概 3600 行的代码）花了 5 天的时间成功移植到了 Common Lisp 上。 ","date":"2022-09-01","objectID":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/:0:0","series":null,"tags":["Lisp"],"title":"记录一次将 C++ 程序移植到 Common Lisp 上的经历","uri":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/#"},{"categories":null,"content":"背景 事情的起因是这样的，最近在做一个项目，主要使用 Common Lisp 进行开发，但发现需要使用到一个 C++ 实时音频处理库提供的功能，这种情况一般是使用 CFFI 通过 C ABI 与 C++ 进行互操作，但该方案麻烦的地方在于： 与 C++ 进行 FFI 通过 C 的 ABI 交互，需要手写不少接口函数，并且做好内存管理。 每换一个平台都需要先安装对应的 C/C++ 环境进行编译动态链接库，然后才能编译 Lisp 程序，不然 CFFI 会报错。 每进行一次修改都需要编译然后重启程序才能看到更改的内容，而在 Lisp 中，程序运行时在 Emacs 下通过一次 C-c C-c 当场就可以看到修改的结果。 因此索性将这个 C++ 项目直接移植到 CL 上，顺便比较一下在算法与程序结构相同的前提下，CL 与 C++ 的性能差距以及 CL 在计算密集应用场景的实用性。 ","date":"2022-09-01","objectID":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/:1:0","series":null,"tags":["Lisp"],"title":"记录一次将 C++ 程序移植到 Common Lisp 上的经历","uri":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/#背景"},{"categories":null,"content":"代码翻译 C++ 的很多代码可以很方便地移植到 CL 上，大部分的特性都可以在 CL 找到对应的实现方式，如指针可以表示为 Displaced Array ，模板这些也有专门的库来实现， CLOS 灵活性又比 C++ 的对象系统高得多，所以将 C++ 翻译成 CLOS 没啥障碍。由于不用手动管理内存，少了不少语法噪音，但 CL 访问类/结构体成员时与有 . 运算符的 C++ 的相比，代码没那么简洁。 CL 在 Lisp 方言中已经算比较接近底层的了，但肯定还是比不上 C/C++ ，比如没办法进行直接内存转译（通过 union 或指针强转），没法直接将 IEEE 浮点类型转换为对应的二进制表示。由于 CL 对结构体/列表/哈希表默认传引用， cl:fill 函数不对拷贝的元素进行复制，会出现改一个元素的属性导致整个数组的元素发生变化的情况，C/C++ 默认传值则没有这个问题，不过解决方法很简单，自己写一个 fill 函数/宏即可，但在 CL 中修改数组元素时确实需要格外谨慎。总之这些都是小问题，不过多少会引入一些性能开销。 ","date":"2022-09-01","objectID":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/:2:0","series":null,"tags":["Lisp"],"title":"记录一次将 C++ 程序移植到 Common Lisp 上的经历","uri":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/#代码翻译"},{"categories":null,"content":"性能 只能说 SBCL 不论是成熟度还是性能确实都是 CL 的实现里（甚至是所有 Lisp 方言里）首屈一指的。 对于实时音频处理这种计算密集的应用场景，SBCL 开 (speed 3) 加上 (safety 0) ，根据编译器的提示一步步加类型声明，并且根据 sb-sprof 采样的函数开销进行内联声明，某些模块的性能可以直接追平开 -O3 的 C++。而程序整体的性能 SBCL 与不开优化的 C++差不多， C++ 如果开了 -O3 优化，SBCL 的整体性能大概只有 C++ 的四分之一左右，当然 CL 上我也只优化了调用比较频繁的代码，但是已经可以达到实时处理的效果。 其他的实现就没有这么乐观了，主要还是由于音频和其他媒体不一样，如果说视频与游戏帧率减半勉强能看能玩，音频速率减半的效果基本可以说是惨不忍睹。我这里测了 ECL、CCL、CLASP、ABCL ，其中 ABCL 和 ECL 的结果没问题，但性能连 SBCL 的十分之一都到不了，尤其是 ABCL 在 Java 18 下的性能比 ECL 还差； CCL 总体有 SBCL 三分之一左右的性能，不过 CCL 加类型声明且开启安全检查时居然可能导致简单数值计算得到错误的结果；CLASP 通过 CFFI 调用 API 播放音频采样时报 Memory Fault，不过它的性能基本与 ECL 一个水平；其他专有的实现像 ACL 和 LispWorks 这样的买不起，也不考虑用于项目上了。 ","date":"2022-09-01","objectID":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/:3:0","series":null,"tags":["Lisp"],"title":"记录一次将 C++ 程序移植到 Common Lisp 上的经历","uri":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/#性能"},{"categories":null,"content":"总结 个人觉得这次的移植还是比较成功的，毕竟在我的应用场景里，修改、调试与维护 CL 代码要比 C++ 方便得多，性能也还过得去，确实验证了 CL 可以在一些性能敏感的场景取代 C/C++ 的使用，不过还是改变不了 Lisp 没什么人用的事实，哈哈。 ","date":"2022-09-01","objectID":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/:4:0","series":null,"tags":["Lisp"],"title":"记录一次将 C++ 程序移植到 Common Lisp 上的经历","uri":"/posts/blog/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%B0%86-c++-%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D%E5%88%B0-common-lisp-%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/#总结"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-06-18","objectID":"/posts/notes/c++/:0:0","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#"},{"categories":null,"content":"delete ","date":"2022-06-18","objectID":"/posts/notes/c++/:1:0","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#delete"},{"categories":null,"content":"函数后的 = delete 作用是让编译器通过函数参数的找到该函数后，禁止调用该函数（函数多态优先于隐式转换）。也可用于删除默认实现的函数。 ","date":"2022-06-18","objectID":"/posts/notes/c++/:1:1","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#函数后的-delete"},{"categories":null,"content":"const 修饰变量：编译期可确定的常量 修饰方法：可以被通过不可变引用来调用。 修饰函数引用参数：不可变引用，只能通过它调用以 const 修饰的方法。 ","date":"2022-06-18","objectID":"/posts/notes/c++/:2:0","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#const"},{"categories":null,"content":"构造函数 如果不想使用默认实现的函数，可以将其定义为 private 或者使用 = delete 来禁止编译器使用该函数。 class DataOnly { public: DataOnly(); // 默认构造函数 ~DataOnly(); // 默认析构函数 DataOnly (const DataOnly \u0026 rhs); // 默认拷贝构造函数 DataOnly \u0026 operator=(const DataOnly \u0026 rhs); // 默认赋值函数 DataOnly (const DataOnly \u0026\u0026 rhs); // 移动构造函数（C++11） DataOnly \u0026 operator=(DataOnly \u0026\u0026 rhs); // 移动拷贝函数（C++11） }; ","date":"2022-06-18","objectID":"/posts/notes/c++/:3:0","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#构造函数"},{"categories":null,"content":"默认构造函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:3:1","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#默认构造函数"},{"categories":null,"content":"默认拷贝构造函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:3:2","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#默认拷贝构造函数"},{"categories":null,"content":"默认赋值函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:3:3","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#默认赋值函数"},{"categories":null,"content":"移动构造函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:3:4","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#移动构造函数"},{"categories":null,"content":"移动拷贝函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:3:5","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#移动拷贝函数"},{"categories":null,"content":"析构函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:4:0","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#析构函数"},{"categories":null,"content":"默认析构函数 ","date":"2022-06-18","objectID":"/posts/notes/c++/:4:1","series":null,"tags":["编程语言","嵌入式"],"title":"C++","uri":"/posts/notes/c++/#默认析构函数"},{"categories":null,"content":"前言 不知道有多少人的童年是在游戏机的陪伴下度过的，对于我个人而言，以前玩过 GBA、NDS、PSP、3DS ，游戏机无疑是童年的一大快乐源泉。虽然我本人现在已经没时间玩了，但是偶尔能听一听之前玩过游戏中的音乐怀旧一下，还是能回忆起小时候玩游戏的时光。本文就给大家简单地介绍一下游戏音乐的背景以及分享一下我个人播放游戏音乐的方式，希望对于有相关需求的朋友能够有所帮助。 ","date":"2022-05-19","objectID":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/:1:0","series":null,"tags":["音乐"],"title":"播放游戏音乐的正确姿势","uri":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/#前言"},{"categories":null,"content":"背景 需要说明的是，游戏音乐 (Video Game Music) 算是一种专有名词，不同的游戏机平台，具有不同的音频系统，对应游戏的音乐也具有多种格式。游戏音乐的发展基本可以代表计算机音乐技术的发展，在维基百科上有详细的介绍，不过大致可以分为以下两大类型： 音序型 相当于录制或定义好每个乐器的采样，播放音乐就相当于让计算机现场根据乐谱演奏乐器并合成发出声音。这种方式的优点是占用的空间小，缺点是一般合成出来的音色单薄、听感较差，同时发声数量和乐器数目也有限制。早期由于性能与存储介质的成本问题，很多游戏都采用这种方案。 录制型 直接录制并保存演奏或合成的音乐。优点是在录制阶段可以随意地使用各种乐器和效果器，听者的得到的效果基本就是音乐在制作时的效果，缺点是占用的体积较大。随着计算机性能的提升以及存储介质成本的降低，现在大部分游戏机和电脑上的游戏基本都使用这种方案以提升玩家的游戏体验。 ","date":"2022-05-19","objectID":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/:2:0","series":null,"tags":["音乐"],"title":"播放游戏音乐的正确姿势","uri":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/#背景"},{"categories":null,"content":"播放方式 相信大部分人听游戏音乐，都会去寻找游戏原声带下载下来用本地播放器播放或者通过网易云音乐、QQ 音乐等在线音乐平台在线播放，但我个人认为这些方式并不是最优的收听方式，原因如下： 原声带里的音乐一般是已经经过录制、采样率转换、压缩，音质一般会有损失（基本就是有损压缩音乐和无损压缩音乐的区别）。 游戏机专用的音频一般都支持无缝循环（游戏音乐在制作过程中会特地留有循环点，游戏机只要在循环点间循环播放，音乐一直持续播放，玩家感觉不到音乐的间断），常用的播放器不支持这种功能。 对于早期音序型的游戏音乐，如果将其录制成文件进行存储是比较低效的（如对 8-bit 音乐进行录制需要占用几 M 的空间，而使用音序进行存储就只需要几 K 的空间）。 所以推荐使用专用播放器播放游戏音乐，通过模拟游戏机音频系统的方式实时演奏这些游戏音乐。 ","date":"2022-05-19","objectID":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/:3:0","series":null,"tags":["音乐"],"title":"播放游戏音乐的正确姿势","uri":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/#播放方式"},{"categories":null,"content":"音乐资源 目前，有大量不同的开源软件提供了对不同格式游戏机音乐播放，也有播放器对这些开源的软件进行了整合，使得只需要安装一个软件即可播放多种格式的游戏音乐，这里推荐： Droidsound-E (Android) ZXTune (Windows/MacOS/Linux/Android) 此外，大家可以在这个网站上找到大量游戏音乐，通过上面推荐的软件直接打开即可播放。这里以 ZXTune 为例，除了可以使用图形化界面进行播放以外，还可以通过命令行播放： zxtune123 \"./01 Title Screen.mini2sf\" 此外，可以添加选项 --loop 进行无缝循环播放： zxtune123 --loop \"./01 Title Screen.mini2sf\" 这样除非我们手动终止程序，播放器就会持续无缝地循环播放这个当前文件，这就与打开游戏听背景音乐的效果一样了。 ","date":"2022-05-19","objectID":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/:4:0","series":null,"tags":["音乐"],"title":"播放游戏音乐的正确姿势","uri":"/posts/blog/%E6%92%AD%E6%94%BE%E6%B8%B8%E6%88%8F%E9%9F%B3%E4%B9%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/#音乐资源"},{"categories":null,"content":"简介 本人最近需要在 GNU/Linux 下实现类似加密文件夹的功能（透明加密），而 LUKS 是 GNU/Linux 下的磁盘加密标准，可以用于磁盘分区的加密。要想不创建分区就使用 LUKS 进行加密，可以创建并挂载一个磁盘镜像文件，在里面进行 LUKS 加密并创建分区。 ","date":"2022-03-30","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-luks-%E5%9C%A8-linux-%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%8A%A0%E5%AF%86%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/:1:0","series":null,"tags":["GNU/Linux"],"title":"使用 LUKS 在 Linux 下创建加密磁盘镜像文件","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-luks-%E5%9C%A8-linux-%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%8A%A0%E5%AF%86%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/#简介"},{"categories":null,"content":"步骤 先使用 fallocate 或 truncate 创建一个固定大小的文件： truncate -s 4G image.iso 确保 cryptsetup 已经安装（大部分发行版自带），并执行： cryptsetup -y luksFormat image.iso 此时会要求输入加密口令： WARNING! ======== 这将覆盖 image.iso 上的数据，该动作不可取消。 Are you sure? (Type 'yes' in capital letters): YES 输入 image.iso 的口令：***** 加密磁盘创建完成，然后使用 cryptsetup 挂载磁盘镜像： sudo cryptsetup luksOpen image.iso loop0 这时会出现两个设备： /dev/loop0 加密后的磁盘镜像分区。 /dev/mapper/loop0 经过 LUKS 解密映射出的磁盘镜像分区，若要使用透明加密功能，应保证始终对该设备挂载、写入等操作。 接着对分区进行建立文件系统： sudo mkfs.ext4 /dev/mapper/loop0 然后就可以挂载这个加密的磁盘镜像文件了： sudo mount /dev/mapper/loop0 /mnt/ 最后进入挂载点更改权限，并删除 lost+found 文件夹： cd /mnt/ sudo rm -r ./lost+found sudo chmod 777 ./ 这时就可以将我们需要加密的文件拷贝进去即可，对应的加密磁盘镜像文件也会随之更新。 ","date":"2022-03-30","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-luks-%E5%9C%A8-linux-%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%8A%A0%E5%AF%86%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/:2:0","series":null,"tags":["GNU/Linux"],"title":"使用 LUKS 在 Linux 下创建加密磁盘镜像文件","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-luks-%E5%9C%A8-linux-%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%8A%A0%E5%AF%86%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/#步骤"},{"categories":null,"content":"CPU 微控制器的核心，包括运算器和控制器两大部分： 运算器 运算器的任务是数据的处理和加工。由以下几个部分通过内部总线连接而成： 算术逻辑单元 ALU (Arithmetic Logic Unit) 完成算术运算及与、或 、非、异或等逻辑操作，并通过对运算结果的判断，影响程序状态寄存器 PSW 相关位的内容。 累加器 ACC 暂存寄存器 程序状态寄存器 PSW 位处理器（布尔处理器） 能直接处理位，在位逻辑和位功能上有独到优势。位处理器中功能最强、使用最频繁的位是 C ，也称其为位累加器。 BCD 码运算调整电路 控制器 控制器是 CPU 的大脑中枢，处理指令的读出、译码和执行，对指令的执行过程进行定时控制，并根据指令含义，完成指令规定的操作。 指令部件 程序计数器 PC 指令寄存器 IR 存放当前正在执行的指令代码，等待译码。 指令译码器 ID 对当前指令操作码进行解析，并通过控制电路产生执行该指令需要的控制信号，完成指令规定的操作。 时序部件 时序部件由时钟电路和脉冲分频器组成，用于产生操作控制部件所需的时序信号，包括： CPU 工作的时钟基准（称为振荡周期或时钟周期） 状态周期 机器周期 操作控制部件 操作控制部件为指令译码器的输出信号配上节拍电位和节拍脉冲，形成执行指令需要的操作控制序列信号，以完成规定的操作。 其他部分： 布尔处理器 具有较强的位寻址、位处理能力。 时钟电路 产生微控制器工作所需要的时钟脉冲（需要外接晶体振荡器和微调电容）。 中断系统 5 个中断源 、2 个中断优先权。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:1:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#cpu--微机原理与接口技术-dot-md"},{"categories":null,"content":"时钟 ","date":"2022-03-29","objectID":"/posts/notes/8051/:2:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#时钟"},{"categories":null,"content":"时钟周期 也称为振荡周期，是晶振频率的倒数，是 MCU 中最基本、最小的时间单位。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:2:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#时钟周期"},{"categories":null,"content":"状态周期 是时钟周期的两倍，即由连续的 2 个节拍 P1 和 P2 组成。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:2:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#状态周期"},{"categories":null,"content":"机器周期 CPU 执行一个基本操作所需要的时间，1 个机器周期由 6 个状态周期（即 12个时钟周期）组成。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:2:3","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#机器周期"},{"categories":null,"content":"指令周期 执行一条指令所需要的时间。通常每条指令的执行可划分为 1-4 个基本操作，因此指令周期由 1-4 个机器周期组成。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:2:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#指令周期"},{"categories":null,"content":"存储器 8051 微控制器的存储器采用哈佛结构，ROM 和 RAM 是分开寻址的： 存储器 大小 地址范围 内部 RAM 256B 00H 至 FFH 特殊寄存器 SFR 21 个 80H 至 FFH （专用内部 RAM 区） 外部 RAM 64KB 0000H 至 FFFFH 内部 ROM 8KB （增强型 8051 为 64KB） 0000H 至 1FFFH 外部 ROM 64KB 0000H 至 FFFFH 程序存储器 ROM 名称 入口地址 意义 复位 0000H 系统复位后 PC 所在位置 外部中断0 0003H 外部中断0 响应时程序跳转位置 定时器0 溢出 000BH 定时器0 中断响应时程序跳转位置 外部中断1 0013H 外部中断1 响应时程序跳转位置 定时器1 溢出 001BH 定时器1 中断响应时程序跳转位置 串行口中断 0023H 串行口中断响应时程序跳转位置 数据存储器 RAM 内部 RAM 寻址方式 00H-7FH 的内存区域 直接寻址 间接寻址 80H-FFH 的特殊功能寄存器 直接寻址 区域 名称 入口地址 工作寄存器区 00H 位寻址区 20F 用户 RAM 区 30H 工作寄存器区 工作寄存器区位于内部 RAM 的 00H-1FH 单元，分成 4 组，每组 8 个字节（共 32 字节），均记作 R0-R7 。工作寄存器区是寄存器寻址区域，对该区域操作的指令数量最多，均为单周期指令，执行的速度最快。 工作寄存器组 地址 工作寄存器 0 组 00H-07H 工作寄存器 1 组 08H-0FH 工作寄存器 2 组 10H-17H 工作寄存器 3 组 18H-1FH 选择 任一时刻，只能使用一个寄存器组，CPU 复位后，默认选择第 0 组。之后由 PSW 寄存器中的 RS1 、 RS0 来选择四组工作寄存器区的哪一组作为 R0-R7 。 位寻址区 位寻址区中的寄存器可 按位 进行寻址。由于在汇编中，操作数是 16 进制的，因此无法直接对某个数进行按位运算（无法一个寄存器的某一个位进行寻址）。而位寻址区中的寄存器具有位地址，1 个寄存器地址对应 8 个位地址，寄存器地址 20H-2FH 对应位地址 00H-7FH 。当操作码是位指令时，会使用的是位地址（而不是寄存器地址），操作位地址对应寄存器中某一位的值。要对其他内存区域中储存的数进行位运算时，应先将这个数移动至位寻址区，进行位运算后再移动回来： MOV BIT, C SETB BIT MOV C, BIT CLR BIT 其中 BIT 是位地址， C 是位累加器。 位指令 置位 复位 位逻辑操作 位条件转移 位累加器 C PSW 寄存器的最高位。 位寻址空间 通用内部 RAM 中的 128 bit 特殊功能寄存器中的 83 bit 用户 RAM 区 处于内部 RAM 的 30H-7FH ，以及没有使用的工作寄存器区和位寻址区，通常作为： 数据缓冲区 存放各种变量。 堆栈区 暂存数据和地址，通常在子程序和中断服务程序中，用于保护断点、现场。 外部 RAM 外部数据存储器的寻址空间为 0000H-FFFFH (64K)，只能使用 MOVX 等指令，通过累加器 ACC 与片外 RAM 进行数据传输。 特殊功能寄存器 SFR 也称专用寄存器， SFR 主要用于内部硬件功能模块（定时器/计数器、串行口、中断系统等）的管理和控制，用来存放功能模块的控制命令、状态或数据。离散分布于 80H-FFH 的专用寄存器区，未定义的访问无效，部分可以位寻址。除程序计数器 PC 指针和 R0-R7 工作寄存器外，其余所有定义的寄存器均属于特殊功能寄存器。 序号 符号 名称 作用 地址 位地址 1 P0 Port 0 并行口 P0 80H 80H-87H 2 SP Stack Pointer 堆栈指针 81H 3 DPL Data Pointer Low 数据指针 DPTR 低8位 82H 4 DPH Data Pointer High 数据指针 DPTR 高8位 83H 5 PCON Power Control 电源控制寄存器 87H 6 TCON Timer Control 定时器控制寄存器 88H 88H-8FH 7 TMOD Timer Mode 定时方式选择寄存器 89H 8 TL0 Timer Low 0 定时器0 低8位 8AH 9 TL1 Timer Low 1 定时器1 低8位 8BH 10 TH0 Timer High 0 定时器0 高8位 8CH 11 TH1 Timer High 1 定时器1 高8位 8DH 12 P1 Port 1 并行口 P1 90H 90H-97H 13 SCON Serial Control 串行口控制寄存器 98H 98H-9FH 14 SBUF Serial Data Buffer 串行口数据寄存器 99H 15 P2 Port 2 并行口 P2 A0H A0H-A7H 16 IE Interrupt Enable 中断使能寄存器 A8H A8H-AFH 17 P3 Port 3 并行口 P3 B0H B0H-B7H 18 IP Interrupt Priority 中断优先级寄存器 B8H B8H-BFH 19 PSW Program Status Workd 程序状态字 D0H D0H-D7H 20 A Accumulator 累加器 E0H E0H-E7H 21 B 乘除指令中使用 F0H F0H-F7H 位寻址 字节地址的低位为 0H 或 8H 的特殊功能寄存器，是可以进行位寻址的。与通用 RAM 中的位寻址区构成8051的位寻址空间。 程序计数器 PC PC 是一个 16 位的专用寄存器，作为程序指针则其寻址范围为 0-65535 字节，用于存放下一条要执行的指令地址，复位后为 0000H 。由于其不属于特殊功能寄存器，因此不占用 SFR 地址空间，是不可寻址的，在程序中不能直接访问，但可以通过 LJMP 、 SJMP 等转移指令来间接修改 PC 的值。 累加器 A 和 ACC 可作一般 8 位寄存器，也可作外部和内部 RAM 数据交换的中转站。 寄存器 B MUL AB ; A*B=BA DIV AB ; A/B=A...B 电源控制寄存器 位 7 3 2 1 0 位符号 SMOD GF1 GF0 PD IDL 英文注释 Serial Mode General Flag 1 General Flag 0 Power down bit Idle mode bit 程序状态字 位地址 D7H D6H D5H D4H D3H D2H D1H D0H 位符号 CY AC F0 RS1 RS0 OV F1 P 注释 Carry Assistant Flag 0 Register Bank Selector Bit 1 Register Bank Selector Bit 0 Overflow Flag 1 Parity Flag 其中： 状态位：由指令执行结果由硬件进行置位或清除 C (CY)：进位标志 在加减法运算时，最高位发生进位或借位会被置位，否则被复位。 AC ：辅助进位标志 在加减法运算时，低 4 位向高 4 位发生进位或借位会被置位，否则被复位。 OV ：溢出标志 加减运算 运算结果超出 8 位有符号整数范围时置位。 乘法 运算结果超出 255 时置位。 除法 除数为 0 时置位。 P ：奇偶标志 累加器中 1 的个数的奇偶性（奇数为 1 ，偶数为 0），会随着 ACC 的变化而变化。 控制位：根据使用需要，用指令设定 RS0, RS1 ：工作寄存器组选择。 F0, F1 ：用户自定义。 堆栈指针 SP 存放当前堆栈栈顶地址的 8 位寄存器。8051 的堆栈是向上生成的，即进栈时 SP 增加，出栈时 SP 减小。复位后， SP 为 07H ，即默认堆栈区为 08H 以上的内存区域。 操作 直接赋值 因为 08H-1FH 单元为工作寄存器区， 20H-2FH 为位寻址区，通常直接对 SP 赋值，将堆栈区设置到用户 RAM 区。 指令操作 使用堆栈操作指令进行数据的“进栈”和“出栈”，实现一些数据的暂存，以及对现场的保护和恢复。 自动操作 调用子程序或响应中断时， CPU 会自动将返回地址或断点地址，压入堆栈保护 程序返回时，自动将断点地址弹回程序计数器 数据指针 DPTR 作为外部 RAM 地址的 16 位指针。 端口寄存器 对于端口即引脚的操作实际上是对这些寄存器的操作，其端口引脚与端口寄存器的位具有映射关系，复位后为 FFH 。 结构 位输出 D 触发器 输出场效应管 读锁存器数据缓冲器 读引脚三态输入缓冲器 ","date":"2022-03-29","objectID":"/posts/notes/8051/:3:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#存储器--微机原理与接口技术-dot-md"},{"categories":null,"content":"引脚 外部晶振接口 外接晶体振荡器、电容，为时钟电路提供振荡源，产生时钟信号： XTAL1 接外部晶振一端。是片内振荡电路反相放大器的输入端。 XTAL2 接外部晶振另一端。是片内振荡电路反相放大器的输出端，振荡电路的振荡频率为晶振频率。 ALE (Address Latch Enable) 地址锁存允许信号输出端。在访问片外存储器或 I/O 接口时，用于锁存低 8 位地址，以实现低 8 位地址与数据的隔离。 PSEN (Program Store Enable) 外部程序存储器选通信号输出端，低电平有效。从外部 ROM 取指令时有效，连接到外扩 ROM 芯片的输出使能端。 EA (External Access Enable) 片内外程序存储器 ROM 选择信号输入端。为 1 时从内部开始执行程序，为 0 时只访问外程序存储器。 RST (Reset) 复位信号输入端，高电平有效。传统的 8051 微控制器没有内置复位电路，因此需引入外部复位电路： 该电路有两种复位方式： 上电复位（冷启动） 上电时，电容的充电过程产生复位信号，高脉冲需要维持 10ms 以上。上电复位后 RAM 的内容随机。 按键复位（热启动） 高脉冲需要维持 2 个机器周期以上。按键复位后 RAM 的内容保持不变。 I/O 接口 4 个 8 位 I/O 接口： P0 双功能的 8 位并行端口： 功能 1 准双向 I/O 端口，无内部上拉电阻，因此做输出口使用时，需要外接上拉电阻。 功能 2 分时复用的 8 位数据线 D7H-D0H 和低 8 位地址线 A7H-A0H ，在扩展外部 存储器 或 I/O 端口 时使用。 P1 带有内部上拉电阻的 8 位准双向 I/O 端口 。 P2 双功能的 8 位并行端口： 功能 1 准双向 I/O 端口，带有内部上拉电阻。 功能 2 在扩展外部 RAM/ROM 时，用作高 8 位地址线 A15H-A8H 。 P3 多功能端口： 功能 1 准双向 I/O 端口，带有内部上拉电阻。 功能 2 引脚 引脚名 英文名称 功能描述 P3.0 RXD Receive eXternal Data 串行口输入 P3.1 TXD Transmitted eXternal Data 串行口输出 P3.2 INT0 Interrupt 0 外部中断0 输入 P3.3 INT1 Interrupt 1 外部中断1 输入 P3.4 T0 Timer 0 定时器0 计数输入 P3.5 T1 Timer 1 定时器1 计数输入 P3.6 WR Write 外部 RAM 写选通 P3.7 RD Read 外部 RAM 读选通 ","date":"2022-03-29","objectID":"/posts/notes/8051/:4:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#引脚"},{"categories":null,"content":"中断 处理 保护断点 硬件自动将 PC 指针压栈。 保护现场 编写中断服务程序时，须对中断程序中用到的工作寄存器和特殊功能寄存器等内容进行保护。 恢复现场 编写中断服务程序时，从中断服务程序返回前需要恢复保护的内容。 恢复断点 中断服务程序最后一条指令必须为 RETI ，用于恢复断点至 PC 指针，继续执行主程序。 查询 CPU 在每个机器周期的 S6 状态查询各中断源，并按优先级管理规则处理同时请求的中断源，且在下一个机器周期的 S1 状态响应最高级中断请求，除非： CPU 正在处理相同或更高优先级中断 多机器周期指令中，还未执行到最后一个机器周期 正在执行中断系统的特殊功能寄存器操作 如 RETI 指令及访问 IE, IP 等操作时要延后一条指令。 响应 中断的响应时间： 最短为 3 个机器周期 查询中断标志位占 1 个机器周期 产生硬件长调用 LCALL 指令需要 2 个机器周期 最长为 8 个机器周期 如果检测到中断请求时，而 CPU 正在执行 RETI 指令或访问： IE, IP 的指令（2 个机器周期），则执行该指令后，还必须再执行 1 条指令才能响应中断。若再执行的一条指令恰好为乘法或除法指令（4 个机器周期），再加上自动保护断点地址的 2 个机器周期，总共需要 8 个机器周期。 使能 中断使能寄存器 IE ： 位 7 4 3 2 1 0 位符号 EA ES ET1 EX1 ET0 EX0 注释 Enable All Interrupts Enable Serial Interrupts Enable Timer 1 Interrupt Enable External 1 Interrupt Enable Timer 0 Interrupt Enable External 0 Interrupt EA 只有被置位时，CPU 才会响应中断请求。复位时，CPU 不响应任何中断请求，相当于总开关。 程序设计 设计程序时，应使得中断服务程序的执行时间尽可能短。 ORG 0000H LJMP MAIN ; 跳转到主程序 ORG 0003H ; INT0 中断入口地址 LJMP INT0SUB ; 跳转到实际 INT0 中断服务程序存放空间 ;; ... ORG 001BH ; T1 中断入口地址 LJMP T1SUB ; 跳转到实际 T1 中断服务程序存放空间 ;; ... ORG 0030H ; 实际主程序存放区 MAIN: MOV SP,#5FH ; 设置堆栈区 SETB IT0 ; 选择 INT0 为下降沿触发方式 SETB EA ; CPU 开中断 SETB EX0 ; INT0 开中断 SETB ET1 ; T1 开中断 SETB PX0 ; 设置 INT0 为高优先级 ;; ... SJMP $ ; 模拟主程序 ORG 0800H ; INT0 中断服务程序存放区 INT0SUB:PUSH ACC PUSH PSW ;; ... POP PSW POP ACC RETI ; 中断返回 T1SUB: PUSH ACC ; 定时器 T1 中断服务程序 PUSH PSW ;; ... POP PSW POP ACC RETI ; 中断返回 扩展 扩展外部中断源 与门（相当于负逻辑的或）的输入端，当其中一个或几个按键按下时，与门输出的下降沿触发 MCU 的 INT0 。在中断服务程序中，轮询四个 I/O 口的状态，确定是哪个按键被按下。 电平方式外部中断请求的撤销 电路的功能是，通过 D 触发器将外部中断请求信号的下降沿（可以是非常快速的，短于 8051 的机器周期）转换为稳定的低电平，外部中断设置为低电平触发，等到 CPU 处理中断后，在中断服务程序里给基于 P1.0 一个负脉冲给触发器置位，使得触发器输出高电平，使得中断不再触发，实现请求的撤销。 结构 中断源（5 个） 5 个中断源的中断入口地址是固定的： 中断源 入口地址 INT0 0003H T0 000BH INT1 0013H T1 001BH TX / RX 0023H 可见，各中断入口地址之间只间隔 8 个字节，对于一般的中断服务程序是容纳不下的。通常是在中断入口地址处安排一条无条件转移指令，使程序跳转到用户安排的中断服务程序的存放区。 当 CPU 响应某中断源的中断请求后，硬件自动将断点地址压入堆栈保护，并将此中断源的中断入口地址赋给 PC ，使 CPU 执行该中断的中断服务程序。 外部中断 外部中断请求信号分别从引脚 INT0 (P3.2) 和 INT1 (P3.3) 引入。 触发方式 低电平触发方式 低电平至少保持一个机器周期。 下降沿触发方式 高低电平至少保持一个机器周期。 定时器 当 T0, T1 发生溢出（定时时间到）时，向 CPU 请求中断。 TF0, TF1 溢出标志位，溢出时有硬件置位，并请求中断， CPU 响应后硬件自动复位。 IE0, IE1 INT0, INT1 中断标志位，发生中断时由硬件置位，向 CPU 请求中断。如果采用低电平触发方式，只有当中断引脚变为高电平时，才会被复位。 IT0, IT1 INT0, INT1 触发方式选择位： IT0, IT1 触发方式 0 低电平触发 1 下降沿触发 串行中断 当串行口发送完一个字节数据或接收到一个字节数据时，产生中断请求。 位 7 6 5 4 3 2 1 0 位符号 SM0 SM1 SM2 REN TB8 RB8 TI RI 注释 Serial Mode Bit 0 Serial Mode Bit 1 Serial Mode Bit 2 Receive Enable Transmit Bit 8 Receive Bit 8 Transmit Interrupt Flag Receive Interrupt Flag TI / RI 发送/接收中断标志。当串行口发送/接收完一帧数据时，由硬件自动置位，必须通过软件复位。 中断相关的特殊功能寄存器（4 个） 中断入口 顺序查询逻辑电路 ","date":"2022-03-29","objectID":"/posts/notes/8051/:5:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#中断"},{"categories":null,"content":"中断优先级 当有多个中断源同时请求中断时，CPU 根据各中断源的优先级别，首先响应优先级高的中断请求，当该中断程序执行完毕返回主程序后并且再执行一条指令后，再响应优先权较低的中断源。这个过程由 MCU 的中断系统自动完成。每个中断源的优先级可通过中断优先级寄存器配置： 位 4 3 2 1 0 位符号 PS PT1 PX1 PT0 PX0 注释 Serial Interrupt Priority Timer 1 Interrupt Priority External 1 Interrupt Priority Timer 0 Interrupt Priority External 0 Interrupt Priority 当中断优先级控制位被置位时，中断源的单刀双掷开关被拨向上方，处于高中断优先级状态。MCU 复位后，中断优先级控制位均被复位，所有中断源处于低中断优先级。 每个优先级内还存在第二个优先级（CPU 轮询顺序）： 外部中断 0 定时器 T0 中断 外部中断 1 定时器 T1 中断 串行口中断 ","date":"2022-03-29","objectID":"/posts/notes/8051/:5:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#中断优先级"},{"categories":null,"content":"中断嵌套 当 CPU 正在执行低级的中断服务程序时，若有高级中断源请求中断，则从低级中断服务程序中断，去执行高级中断源的服务程序，产生中断嵌套，并能逐级正确返回。如果新的中断请求的优先级小于或等于当前正在处理的中断，则 CPU 暂时不处理这个中断，直到正在处理的中断服务程序执行完毕后，再进行处理。若要在执行当前中断程序时禁止高优先级的中断（即不允许中断嵌套），则在进入中断程序后先关闭 CPU 中断（复位 EA ），或将高级中断源的中断允许位复位，在中断返回前再进行置位。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:5:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#中断嵌套"},{"categories":null,"content":"中断向量表 存放中断服务程序的入口地址，“向量”可以看作就是函数。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:5:3","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#中断向量表"},{"categories":null,"content":"定时器 作用 可以在脉冲的上升沿或下降沿使得计数器的值发生变化： 加法计数 当计数器达到最大值时，再进行加法计数器会溢出。微控制器的片内定时器大多采用加法计数。 减法计数 独立定时器芯片通常采用减法计数的方式。 结构 加法计数器 T0 2 个级联的 8 位加法计数器 (TH0, TL0) T1 2 个级联的 8 位加法计数器 (TH1, TL1) 输入引脚 T0 T1 寄存器 模式寄存器 TMOD 其中高 4 位设置 T1 ，低 4 位设置 T0 。 位 7 6 5 4 3 2 1 0 位符号 GATE C/T M1 M0 GATE C/T M1 M0 注释 Gate Counter/Timer Mode Bit 1 Mode Bit 0 Gate Counter/Timer Mode Bit 1 Mode Bit 0 C/T ：功能选择位 GATE ：门控位 用于释放或封锁 INT0 或 INT1 的信号。当且仅当 GATE 被置位时， INT0 或 INT1 才能够控制定时器的启动与停止。 INT0 或 INT1 可以用于测量外部脉冲信号的高电平周期。 M0, M1 M1 M0 工作方式 功能 0 0 方式 0 13 位计数器 0 1 方式 1 16 位计数器 1 0 方式 2 初值自动装载的 8 位计数器 1 1 方式 3 T0 分成 2 个 8 位计数器， T1 停止计数 方式 1 2 个 8 位计数器将组成一个 16 位计数器。若要设置计数器每次计数的初值，需要在中断服务程序中，给 TH0 / TH1 与 TL0 / TL1 装载初值。这时由于中断响应时间的随机性，定时时间将有一定误差。 方式 2 这时 TL0 / TL1 将成为独立的 8 位加法计数器， TH0 / TH1 将变成重载初值寄存器。即 TL0 / TL1 溢出时，会自动从 TH0 / TH1 预置初值，因此没有定时时间的误差。 控制寄存器 TCON TCON 地址为 88H ，是可进行位寻址的特殊功能寄存器。 位 7 6 5 4 3 2 1 0 位符号 TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 注释 Timer 1 Overflow Timer 1 Run Timer 0 Overflow Timer 0 Run Interrupt External 1 Edge Flag Interrupt 1 Type Control Bit Interrupt External 0 Edge Flag Interrupt 0 Type Control Bit TF0 / TF1 溢出标志位，即中断标志位。 T0 / T1 溢出时被置位，在 CPU 响应中断后自动复位。 TR0 / TR1 定时器启动控制位。 工作模式 定时模式 当 C/T 为 0 时，定时器处于定时模式。输入脉冲由内部振荡频率的 12 分频脉冲信号（即机器周期）提供。 计数模式 当 C/T 为 1 时，定时器处于计数模式。输入脉冲由引脚 T0 (P3.4) 或 T1 (P3.5) 的输入信号提供。每输入 1 个脉冲（的下降沿），计数器的值加 1 ，高电平和低电平的宽度应大于 1 个机器周期。因此外部脉冲的最大频率为系统晶振频率的\\(\\frac{1}{24}\\)。 周期 对于 12MHz 的外部晶振，定时器滴答的周期为 \\(1\\mu\\text{s}\\)。 读取 CPU 读取计数器值的期间，若计数器是 16 位的，则需要花费多个机器周期，若在读取一个字节的时候，定时器刚好发生溢出，并且使得刚刚读取的字节发生变化，就产生相位误差。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:6:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#定时器"},{"categories":null,"content":"串口 寄存器 串行口控制寄存器 SCON 位 7 6 5 4 3 2 1 0 位符号 SM0 SM1 SM2 REN TB8 RB8 TI RI 注释 Serial Mode Bit 0 Serial Mode Bit 1 Serial Mode Bit 2 Receive Enable Transmit Bit 8 Receive Bit 8 Transmit Interrupt Flag Receive Interrupt Flag SM0 / SM1 SM0 SM1 工作方式 特点 波特率 0 1 方式 0 8 位移位寄存器 \\(\\frac{f_\\mathrm{osc}}{12}\\) 0 1 方式 1 10 位 UART 可变 1 0 方式 2 11 位 UART \\(\\frac{f_\\mathrm{osc}}{64}\\) 或 \\(\\frac{f_\\mathrm{osc}}{32}\\) 1 1 方式 3 11 位 UART 可变 REN ：接收使能控制位 TB8 使用方式 0 或方式 1 时不使用，使用方式 2 或方式 3 时需要事先用软件写入发送的第 8 位。 RB8 使用方式 0 时不使用，使用方式 2 或方式 3 时接收到的第 8 位数据自动送入该位，使用方式 1 时停止被送入该位。 SM2 ：多机通信控制位 使用方式 2 或方式 3 时，若 SM2 被置位，接收中断标志位将与接收到的第 8 位数据同时置位与复位。 TI ：发送中断标志位 发送完一帧后有硬件置位，必须由软件复位。 RI ：接收中断标志位 电源控制寄存器 SMOD ：波特率选择位 置位时对波特率进行加倍。 数据缓冲器 SBUF 串行口上有 2 个独立的数据缓冲器，均表示为 SBUF ： 发送缓冲器 只写不读，当 SBUF 作为源操作数时，对接收缓冲器进行读操作。 接收缓冲器 只读不写，当 SBUF 作为目的操作数时，对发送缓冲器进行写操作。 工作方式 方式 0 8 位同步通信方式，通常用于 I/O 端口扩展。 引脚 P3.0 (TXD) 同时作为数据输入/输出端，发送或接收的是 8 位二进制数（LSB 优先）。 发送 接收 引脚 P3.1 (RXD) 作为移位同步脉冲输出端，波特率固定为\\(\\frac{f_\\mathrm{osc}}{12}\\)。 方式 1 10 位（包含 1 位起始位与 1 位停止位）异步通信方式，发送与接收的是 8 位二进制数（LSB 优先）。波特率可编程为\\(\\frac{2^\\texttt{SMOD}}{32}\\times \\text{T1 溢出速率}\\)。对于常用波特率： 波特率 晶振频率 (MHz) SMOD TH1 115200 11.0592 1 FFH 38400 11.0592 1 FEH 19200 11.0592 1 FDH 9600 11.0592 0 FDH 4800 11.0592 0 FAH 2400 11.0592 0 F4H 1200 11.0592 0 E8H 若使用 12MHz 的晶振，则会引起误差（在波特率 2400 下为\\(0.11\\%\\)），当两个设备的波特率的误差超过\\(2.5\\%\\)时则可能引起通信错误。 引脚 P3.0 (TXD) 同时作为数据输出端 引脚 P3.1 (RXD) 同时作为数据输入端 位检测采样以波特率的 16 倍速率对每个位进行检测，把半数以上的结果作为最终的采样结果。第 8 位（停止位）被自动送入 RB8 中。 方式 2 / 方式 3 11 位（包含 1 位起始位、 1 位停止位与 1 位奇偶校验位）异步通信方式，发送与接收的是 8 位二进制数（LSB 优先）。方式 2 与方式 3 仅在波特率的设置上有区别： 方式 2 ：波特率固定为\\(\\frac{2^\\texttt{SMOD}}{64}\\times f_\\mathrm{osc}\\) 方式 3 ：波特率可编程为\\(\\frac{2^\\texttt{SMOD}}{32}\\times \\text{T1 溢出速率}\\)（与方式 1 相同） 引脚设置与方式 1 相同： 引脚 P3.0 (TXD) 同时作为数据输出端 引脚 P3.1 (RXD) 同时作为数据输入端 ","date":"2022-03-29","objectID":"/posts/notes/8051/:7:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#串口"},{"categories":null,"content":"低功耗 8051 具有两种低功耗方式，通过电源控制寄存器 中的 IDL 位和 PD 位进行选择。 运行方式 电源电压 (V) 时钟频率 (Mhz) 电源电流 (mA) 正常运行 5 12 20 空闲模式 5 12 5 掉电模式 5 12 0.075 ","date":"2022-03-29","objectID":"/posts/notes/8051/:8:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#低功耗"},{"categories":null,"content":"空闲模式 当 IDL 为 1 且 PD 为 0 时，进入空闲模式。 特点 内部时钟电路正常工作，但关闭了 CPU 的时钟，CPU 停止工作，中断系统、串行口与定时器/计数器继续工作。 唤醒方式 复位 触发中断 ","date":"2022-03-29","objectID":"/posts/notes/8051/:8:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#空闲模式"},{"categories":null,"content":"掉电模式 只要 PD 为 1 ，即进入掉电模式。 特点 内部时钟电路不工作，内部所有功能单元停止工作。 唤醒方式 复位 ","date":"2022-03-29","objectID":"/posts/notes/8051/:8:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#掉电模式"},{"categories":null,"content":"指令 属于 CISC ，有 5 大功能，111 条指令，参考 https://www.keil.com/support/man/docs/is51/ 。 执行过程 程序 完成一个特定功能的一系列指令集。 指令 是微控制器指挥各功能部件工作的指示和命令。指令是一组二进制数，其编码格式及功能、类别和数量因 CPU 的不同而不同，是芯片设计者设定的。 一条指令包括两部分内容： 操作码 指令的功能。 操作数 指令执行的数据或数据存放的地址。 计算机每执行一条指令，都可以分为三个阶段： 取指令 根据程序计数器（程序指针） PC 中的值，从 ROM 读出现行指令，送到指令寄存器 IR 。 分析指令 由指令译码器对现行指令进行译码，分析该指令要求实现什么操作，如执行数据传送，还是加、减等运算等。 执行指令 取出操作数，由控制逻辑电路发出相应的控制信号，完成操作码规定的操作。 分类 长度分类 单字节 指令的操作数隐含在操作码中。 双字节 三字节 耗时分类 单机器周期 双机器周期 四机器周期 功能分类 数据传送 算术运算 逻辑运算 控制转移 位操作 格式 LOOP: OPER DIST,SRC ; COMMENT LOOP ：标号 首字母必须为字母。 OPER ：助记符 指令的功能。 DIST,SRC ：操作数 对象 立即数 地址 寄存器 标号 符号 # ：立即数 @ ：间接寻址 + ：变址寻址 如果有两个操作数： DIST ：目的操作数 SRC ：源操作数 COMMENT ：注释 Rn (R0-R7) 当前选中的工作寄存器组，其地址程序状态字中的 RS1, RS0 确定。 Ri (R0-R1) 当前选中的工作寄存器组中可作为地址指针的两个工作寄存器 R0, R1 。 #data 8 位立即数，即指令中给出的 8 位常数。 #data16 16 位立即数，即指令中给出的 16 位常数。 direct 8 位片内 RAM 单元（包括特殊功能寄存器）的直接地址。 addr16 16 位目的地址，用于 LCALL 和 LJMP 指令中，目的地址在 64KB 的 ROM 空间中。 addr11 11 位目的地址，用于 ACALL 和 AJMP 指令中，目的地址必须与下一条指令的第一字节在同一个 2KB 的 ROM 空间之内（很少使用）。 rel 8 位带符号的偏移字节，用于 SJMP 和所有的条件转移指令中。偏移量以下一条指令第一字节地址为基址，范围为 -128-127 。 bit 片内 RAM 或特殊功能寄存器的直接寻址的位地址。 @ 间接寻址方式，表示间址寄存器的符号。 / 在位操作指令中，表示对该位先求反再参与操作，不影响原始值。 (x) 表示 x 中内容。 ((x)) 表示以 x 中的内容为地址寻址。 \u003c- 指令操作流程，将箭头右边的内容送到箭头左边的单元中。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#指令"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#寻址方式"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#立即寻址"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#直接寻址"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#寄存器寻址"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#寄存器间接寻址"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#变址寻址"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#相对寻址"},{"categories":null,"content":"寻址方式 寻址方式 使用的变量 寻址空间 直接寻址 direct 内部 RAM 的 00H-7FH, SFR 寄存器寻址 R0-R7, A R0-R7, A 寄存器间接寻址 @R0-R1, SP 内部 RAM 的 00H-FFH @R0-R1, @DPTR 外部 RAM 立即寻址 #data, #data16 ROM 变址寻址 基址寄存器 DPTR, PC 、变址寄存器 A ROM 相对寻址 偏移量 ROM 位寻址 C 位寻址空间 立即寻址 直接给出操作数作为 ROM 地址。 MOV R0, #50H ; (Rn) \u003c- data 直接寻址 给出操作数的内存地址，其中的内容作为操作数。 MOV 30H, 50H ; (direct) \u003c- (direct) 寄存器寻址 给出操作数的寄存器名称，其中的内容作为操作数。 MOV A, R1 ; (A) \u003c- (Rn) 寄存器间接寻址 给出操作数地址所在的寄存器，其中的地址的内容作为操作数。 MOV A, @R1 ; (A) \u003c- ((Ri)) 对于 80H-FFH 的内部 RAM 区域，只能使用寄存器间接寻址，先将地址赋值给一个寄存器，然后使用该寄存器进行寻址。 MOV R0, #80H ; (Ri) \u003c- data MOV A, @R0 ; (A) \u003c- ((Ri)) 变址寻址 以 DPTR 或 PC （均为 16 位寄存器）作基址寄存器， A 作变址寄存器（存放 8 位无符号数），两者相加得到的 16 位 ROM 地址（寻址空间为 ROM），其中的内容作为操作数。 MOVC A, @A+DPTR ; (A) \u003c- ((A)+(DPTR)) 相对寻址 用于程序控制，利用指令修改 PC 指针内容实现跳转，操作数为执行完这条指令后的 PC 偏移量。 \\[\\text{目的地址} = \\text{转移指令所在地址} + \\text{转移指令字节数} + \\text{偏移量}\\] SJMP #01H 位寻址 位寻址与直接寻址（字节）的地址形式完全相同，通过操作码来区分，当指令为位指令或使用了位寄存器时，地址会被当作位地址。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#位寻址"},{"categories":null,"content":"数据写入指令 MOV MOVe 写入累加器 MOV A, Rn ; (A) \u003c- (Rn) MOV A, direct ; (A) \u003c- (direct) MOV A, @Ri ; (A) \u003c- ((Ri)) MOV A, #data ; (A) \u003c- data 写入直接地址 MOV direct, A ; (direct) \u003c- (A) MOV direct, Rn ; (direct) \u003c- (Rn) MOV direct1, direct2 ; (direct1) \u003c- (direct2) MOV direct, @Ri ; (direct) \u003c- ((Ri)) MOV direct, #data ; (direct) \u003c- data 写入当前的工作寄存器组 MOV Rn, A ; (Rn) \u003c- (A) MOV Rn, direct ; (Rn) \u003c- (direct) MOV Rn, #data ; (Rn) \u003c- data 写入间接地址 MOV @Ri, A ; ((Ri)) \u003c- (A) MOV @Ri, direct ; ((Ri)) \u003c- (direct) MOV @Ri, #data ; ((Ri)) \u003c- data 写入 16 位寄存器 只能将立即数传送给 16 位寄存器。 MOV DPTR, #data16 ; (DPTR) \u003c- data16 注意，8051 的指令系统没有 MOV @R0, R1 这类指令，可以看作 8051 无法同时进行两次除了累加器之外寄存器寻址（包括寄存器间接寻址这种相当于连续做了两次寄存器寻址的寻址方式）。 MOVX MOVe eXternal RAM 对外部 RAM 读写必须通过累加器并且使用寄存器间接寻址（16 位）来完成。 MOVX A, @DPTR ; (A) \u003c- ((DPTR)) MOVX @DPTR, A ; ((DPTR)) \u003c- (A) MOVX A, @Ri ; (A) \u003c- ((Ri)) MOVX @Ri, A ; ((Ri)) \u003c- (A) MOVC MOVe Code 使用变址寻址，将 DPTR 或 PC 的内容与累加器 A 的内容相加后形成一个 ROM 单元地址，将其中的内容赋值给累加器 A ，根据使用 DPTR 或 PC 分为： 远程查表指令 MOVC A, @A+DPTR ; (A) \u003c- ((A) + (DPTR)) 近程查表指令 MOVC A, @A+PC ; (PC) \u003c- (PC) + 1 ; (A) \u003c- ((A) + (PC)) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#数据写入指令"},{"categories":null,"content":"数据写入指令 MOV MOVe 写入累加器 MOV A, Rn ; (A) \u003c- (Rn) MOV A, direct ; (A) \u003c- (direct) MOV A, @Ri ; (A) \u003c- ((Ri)) MOV A, #data ; (A) \u003c- data 写入直接地址 MOV direct, A ; (direct) \u003c- (A) MOV direct, Rn ; (direct) \u003c- (Rn) MOV direct1, direct2 ; (direct1) \u003c- (direct2) MOV direct, @Ri ; (direct) \u003c- ((Ri)) MOV direct, #data ; (direct) \u003c- data 写入当前的工作寄存器组 MOV Rn, A ; (Rn) \u003c- (A) MOV Rn, direct ; (Rn) \u003c- (direct) MOV Rn, #data ; (Rn) \u003c- data 写入间接地址 MOV @Ri, A ; ((Ri)) \u003c- (A) MOV @Ri, direct ; ((Ri)) \u003c- (direct) MOV @Ri, #data ; ((Ri)) \u003c- data 写入 16 位寄存器 只能将立即数传送给 16 位寄存器。 MOV DPTR, #data16 ; (DPTR) \u003c- data16 注意，8051 的指令系统没有 MOV @R0, R1 这类指令，可以看作 8051 无法同时进行两次除了累加器之外寄存器寻址（包括寄存器间接寻址这种相当于连续做了两次寄存器寻址的寻址方式）。 MOVX MOVe eXternal RAM 对外部 RAM 读写必须通过累加器并且使用寄存器间接寻址（16 位）来完成。 MOVX A, @DPTR ; (A) \u003c- ((DPTR)) MOVX @DPTR, A ; ((DPTR)) \u003c- (A) MOVX A, @Ri ; (A) \u003c- ((Ri)) MOVX @Ri, A ; ((Ri)) \u003c- (A) MOVC MOVe Code 使用变址寻址，将 DPTR 或 PC 的内容与累加器 A 的内容相加后形成一个 ROM 单元地址，将其中的内容赋值给累加器 A ，根据使用 DPTR 或 PC 分为： 远程查表指令 MOVC A, @A+DPTR ; (A) \u003c- ((A) + (DPTR)) 近程查表指令 MOVC A, @A+PC ; (PC) \u003c- (PC) + 1 ; (A) \u003c- ((A) + (PC)) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#mov"},{"categories":null,"content":"数据写入指令 MOV MOVe 写入累加器 MOV A, Rn ; (A) \u003c- (Rn) MOV A, direct ; (A) \u003c- (direct) MOV A, @Ri ; (A) \u003c- ((Ri)) MOV A, #data ; (A) \u003c- data 写入直接地址 MOV direct, A ; (direct) \u003c- (A) MOV direct, Rn ; (direct) \u003c- (Rn) MOV direct1, direct2 ; (direct1) \u003c- (direct2) MOV direct, @Ri ; (direct) \u003c- ((Ri)) MOV direct, #data ; (direct) \u003c- data 写入当前的工作寄存器组 MOV Rn, A ; (Rn) \u003c- (A) MOV Rn, direct ; (Rn) \u003c- (direct) MOV Rn, #data ; (Rn) \u003c- data 写入间接地址 MOV @Ri, A ; ((Ri)) \u003c- (A) MOV @Ri, direct ; ((Ri)) \u003c- (direct) MOV @Ri, #data ; ((Ri)) \u003c- data 写入 16 位寄存器 只能将立即数传送给 16 位寄存器。 MOV DPTR, #data16 ; (DPTR) \u003c- data16 注意，8051 的指令系统没有 MOV @R0, R1 这类指令，可以看作 8051 无法同时进行两次除了累加器之外寄存器寻址（包括寄存器间接寻址这种相当于连续做了两次寄存器寻址的寻址方式）。 MOVX MOVe eXternal RAM 对外部 RAM 读写必须通过累加器并且使用寄存器间接寻址（16 位）来完成。 MOVX A, @DPTR ; (A) \u003c- ((DPTR)) MOVX @DPTR, A ; ((DPTR)) \u003c- (A) MOVX A, @Ri ; (A) \u003c- ((Ri)) MOVX @Ri, A ; ((Ri)) \u003c- (A) MOVC MOVe Code 使用变址寻址，将 DPTR 或 PC 的内容与累加器 A 的内容相加后形成一个 ROM 单元地址，将其中的内容赋值给累加器 A ，根据使用 DPTR 或 PC 分为： 远程查表指令 MOVC A, @A+DPTR ; (A) \u003c- ((A) + (DPTR)) 近程查表指令 MOVC A, @A+PC ; (PC) \u003c- (PC) + 1 ; (A) \u003c- ((A) + (PC)) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#movx"},{"categories":null,"content":"数据写入指令 MOV MOVe 写入累加器 MOV A, Rn ; (A) \u003c- (Rn) MOV A, direct ; (A) \u003c- (direct) MOV A, @Ri ; (A) \u003c- ((Ri)) MOV A, #data ; (A) \u003c- data 写入直接地址 MOV direct, A ; (direct) \u003c- (A) MOV direct, Rn ; (direct) \u003c- (Rn) MOV direct1, direct2 ; (direct1) \u003c- (direct2) MOV direct, @Ri ; (direct) \u003c- ((Ri)) MOV direct, #data ; (direct) \u003c- data 写入当前的工作寄存器组 MOV Rn, A ; (Rn) \u003c- (A) MOV Rn, direct ; (Rn) \u003c- (direct) MOV Rn, #data ; (Rn) \u003c- data 写入间接地址 MOV @Ri, A ; ((Ri)) \u003c- (A) MOV @Ri, direct ; ((Ri)) \u003c- (direct) MOV @Ri, #data ; ((Ri)) \u003c- data 写入 16 位寄存器 只能将立即数传送给 16 位寄存器。 MOV DPTR, #data16 ; (DPTR) \u003c- data16 注意，8051 的指令系统没有 MOV @R0, R1 这类指令，可以看作 8051 无法同时进行两次除了累加器之外寄存器寻址（包括寄存器间接寻址这种相当于连续做了两次寄存器寻址的寻址方式）。 MOVX MOVe eXternal RAM 对外部 RAM 读写必须通过累加器并且使用寄存器间接寻址（16 位）来完成。 MOVX A, @DPTR ; (A) \u003c- ((DPTR)) MOVX @DPTR, A ; ((DPTR)) \u003c- (A) MOVX A, @Ri ; (A) \u003c- ((Ri)) MOVX @Ri, A ; ((Ri)) \u003c- (A) MOVC MOVe Code 使用变址寻址，将 DPTR 或 PC 的内容与累加器 A 的内容相加后形成一个 ROM 单元地址，将其中的内容赋值给累加器 A ，根据使用 DPTR 或 PC 分为： 远程查表指令 MOVC A, @A+DPTR ; (A) \u003c- ((A) + (DPTR)) 近程查表指令 MOVC A, @A+PC ; (PC) \u003c- (PC) + 1 ; (A) \u003c- ((A) + (PC)) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#movc"},{"categories":null,"content":"栈操作指令 PUSH PUSH onto stack 先修改 SP 指针，再使用直接寻址将内部 RAM 的指定单元的内容压入堆栈。 PUSH direct ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- (direct) POP POP from stack 先将堆栈栈顶的内容弹出，在使用直接寻址送到内部 RAM 的指定单元，再修改 SP 指针。 POP direct ; (direct) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:3","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#栈操作指令"},{"categories":null,"content":"栈操作指令 PUSH PUSH onto stack 先修改 SP 指针，再使用直接寻址将内部 RAM 的指定单元的内容压入堆栈。 PUSH direct ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- (direct) POP POP from stack 先将堆栈栈顶的内容弹出，在使用直接寻址送到内部 RAM 的指定单元，再修改 SP 指针。 POP direct ; (direct) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:3","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#push"},{"categories":null,"content":"栈操作指令 PUSH PUSH onto stack 先修改 SP 指针，再使用直接寻址将内部 RAM 的指定单元的内容压入堆栈。 PUSH direct ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- (direct) POP POP from stack 先将堆栈栈顶的内容弹出，在使用直接寻址送到内部 RAM 的指定单元，再修改 SP 指针。 POP direct ; (direct) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:3","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#pop"},{"categories":null,"content":"数据交换指令 XCH eXCHange 将累加器 A 与其他单元进行字节交换。 XCH A, Rn ; (A) \u003c-\u003e (Rn) XCH A, direct ; (A) \u003c-\u003e (direct) XCH A, @Ri ; (A) \u003c-\u003e ((Ri)) XCHD eXCHange low-order Digit 将累加器 A 与 R0-R1 进行半字节交换。 XCHD A, @Ri ; (A)3~0 \u003c-\u003e ((Ri))3~0 SWAP SWAP 将累加器的低四位与高四位进行交换。 SWAP A ; (A)3~0 \u003c-\u003e (A)7~4 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#数据交换指令"},{"categories":null,"content":"数据交换指令 XCH eXCHange 将累加器 A 与其他单元进行字节交换。 XCH A, Rn ; (A) \u003c-\u003e (Rn) XCH A, direct ; (A) \u003c-\u003e (direct) XCH A, @Ri ; (A) \u003c-\u003e ((Ri)) XCHD eXCHange low-order Digit 将累加器 A 与 R0-R1 进行半字节交换。 XCHD A, @Ri ; (A)3~0 \u003c-\u003e ((Ri))3~0 SWAP SWAP 将累加器的低四位与高四位进行交换。 SWAP A ; (A)3~0 \u003c-\u003e (A)7~4 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#xch"},{"categories":null,"content":"数据交换指令 XCH eXCHange 将累加器 A 与其他单元进行字节交换。 XCH A, Rn ; (A) \u003c-\u003e (Rn) XCH A, direct ; (A) \u003c-\u003e (direct) XCH A, @Ri ; (A) \u003c-\u003e ((Ri)) XCHD eXCHange low-order Digit 将累加器 A 与 R0-R1 进行半字节交换。 XCHD A, @Ri ; (A)3~0 \u003c-\u003e ((Ri))3~0 SWAP SWAP 将累加器的低四位与高四位进行交换。 SWAP A ; (A)3~0 \u003c-\u003e (A)7~4 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#xchd"},{"categories":null,"content":"数据交换指令 XCH eXCHange 将累加器 A 与其他单元进行字节交换。 XCH A, Rn ; (A) \u003c-\u003e (Rn) XCH A, direct ; (A) \u003c-\u003e (direct) XCH A, @Ri ; (A) \u003c-\u003e ((Ri)) XCHD eXCHange low-order Digit 将累加器 A 与 R0-R1 进行半字节交换。 XCHD A, @Ri ; (A)3~0 \u003c-\u003e ((Ri))3~0 SWAP SWAP 将累加器的低四位与高四位进行交换。 SWAP A ; (A)3~0 \u003c-\u003e (A)7~4 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#swap"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#算术运算指令"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#add"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#addc"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#subb"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#inc"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#dec"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#mul"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#div"},{"categories":null,"content":"算术运算指令 ADD 将源操作数与目的操作数（累加器 A ）不带进位地相加后（但会改变 C 的值），存放至累加器 A 中。 ADD A, #data ; (A) \u003c- (A) + #data ADD A, direct ; (A) \u003c- (A) + (direct) ADD A, @Ri ; (A) \u003c- (A) + ((Ri)) ADD A, Rn ; (A) \u003c- (A) + (Rn) ADDC 将源操作数与目的操作数（累加器 A ）带进位地相加后，存放至累加器 A 中。 ADDC A, #data ; (A) \u003c- (A) + #data + (C) ADDC A, direct ; (A) \u003c- (A) + (direct) + (C) ADDC A, @Ri ; (A) \u003c- (A) + ((Ri)) + (C) ADDC A, Rn ; (A) \u003c- (A) + (Rn) + (C) SUBB 将源操作数与目的操作数（累加器 A ）带借位地相减后，存放至累加器 A 中。 SUBB A, #data ; (A) \u003c- (A) - #data - (C) SUBB A, direct ; (A) \u003c- (A) - (direct) - (C) SUBB A, @Ri ; (A) \u003c- (A) - ((Ri)) - (C) SUBB A, Rn ; (A) \u003c- (A) - (Rn) - (C) INC 将指令中的操作数加 1 ，不影响标志位。 INC Rn ; (Rn) \u003c- (Rn) + 1 INC direct ; (direct) \u003c- (direct) + 1 INC @Ri ; ((Ri)) \u003c- ((Ri)) + 1 INC A ; (A) \u003c- (A) + 1 INC DPTR ; (DPTR) \u003c-(DPTR) + 1 DEC 将指令中的操作数减 1 ，不影响标志位。 DEC Rn ; (Rn) \u003c- (Rn) - 1 DEC direct ; (direct) \u003c- (direct) - 1 DEC @Ri ; ((Ri)) \u003c- ((Ri)) - 1 DEC A ; (A) \u003c- (A) - 1 注意，该指令不能对 DPTR 实现减 1 。 MUL 将 A 和 B 中两个 无符号 8 位二进制数相乘，所得的 16 位积： 低 8 位存至 A 中 高 8 位存至 B 中 如果乘积大于 255 时（高位 B 不为 0 时）， OV 置位，否则 OV 复位，而 C 总是为 0 。 MUL AB ; (B)(A) \u003c- (A) * (B) DIV 将 A 整除 B ，结果存入 A ，余数存入 B 。 DIV A, B ; (A) \u003c- (A) / (B) ; (B) \u003c- (A) % (B) DA 对两个压缩 BCD 码（即 1 个字节存放 2 个 BCD 码）相加的结果进行十进制调整。只能用在 ADD 和 ADDC 指令之后，对 A 中的结果进行修正。 DA A ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:5","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#da"},{"categories":null,"content":"逻辑运算指令 不影响标志位，仅当其目的操作数为累加器 A 时，对奇偶标志位 P 有影响。 ANL 将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。 ANL A, Rn ; (A) \u003c- (A) and (Rn) ANL A, direct ; (A) \u003c- (A) and (direct) ANL A, @Ri ; (A) \u003c- (A) and ((Ri)) ANL A, #data ; (A) \u003c- (A) and #data ANL direct, A ; (direct) \u003c- (direct) and (A) ANL direct, #data ; (direct) \u003c- (direct) and #data ORL 将目的操作数和源操作数按位相或，结果存放到目的操作数单元中 ORL A, Rn ; (A) \u003c- (A) or (Rn) ORL A, direct ; (A) \u003c- (A) or (direct) ORL A, @Ri ; (A) \u003c- (A) or ((Ri)) ORL A, #data ; (A) \u003c- (A) or #data ORL direct, A ; (direct) \u003c- (direct) or (A) ORL direct, #data ; (direct) \u003c- (direct) or #data XRL 将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中 XRL A, Rn ; (A) \u003c- (A) xor (Rn) XRL A, direct ; (A) \u003c- (A) xor (direct) XRL A, @Ri ; (A) \u003c- (A) xor ((Ri)) XRL A, #data ; (A) \u003c- (A) xor #data XRL direct, A ; (direct) \u003c- (direct) xor (A) XRL direct, #data ; (direct) \u003c- (direct) xor #data CLR 当操作数是累加器 A 时，对字节清零 CLR A ; (A) \u003c- 0 CPL 对累加器 A 的内容逐位取反。 CPL A ; (A) \u003c- /(A) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:6","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#逻辑运算指令"},{"categories":null,"content":"逻辑运算指令 不影响标志位，仅当其目的操作数为累加器 A 时，对奇偶标志位 P 有影响。 ANL 将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。 ANL A, Rn ; (A) \u003c- (A) and (Rn) ANL A, direct ; (A) \u003c- (A) and (direct) ANL A, @Ri ; (A) \u003c- (A) and ((Ri)) ANL A, #data ; (A) \u003c- (A) and #data ANL direct, A ; (direct) \u003c- (direct) and (A) ANL direct, #data ; (direct) \u003c- (direct) and #data ORL 将目的操作数和源操作数按位相或，结果存放到目的操作数单元中 ORL A, Rn ; (A) \u003c- (A) or (Rn) ORL A, direct ; (A) \u003c- (A) or (direct) ORL A, @Ri ; (A) \u003c- (A) or ((Ri)) ORL A, #data ; (A) \u003c- (A) or #data ORL direct, A ; (direct) \u003c- (direct) or (A) ORL direct, #data ; (direct) \u003c- (direct) or #data XRL 将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中 XRL A, Rn ; (A) \u003c- (A) xor (Rn) XRL A, direct ; (A) \u003c- (A) xor (direct) XRL A, @Ri ; (A) \u003c- (A) xor ((Ri)) XRL A, #data ; (A) \u003c- (A) xor #data XRL direct, A ; (direct) \u003c- (direct) xor (A) XRL direct, #data ; (direct) \u003c- (direct) xor #data CLR 当操作数是累加器 A 时，对字节清零 CLR A ; (A) \u003c- 0 CPL 对累加器 A 的内容逐位取反。 CPL A ; (A) \u003c- /(A) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:6","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#anl"},{"categories":null,"content":"逻辑运算指令 不影响标志位，仅当其目的操作数为累加器 A 时，对奇偶标志位 P 有影响。 ANL 将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。 ANL A, Rn ; (A) \u003c- (A) and (Rn) ANL A, direct ; (A) \u003c- (A) and (direct) ANL A, @Ri ; (A) \u003c- (A) and ((Ri)) ANL A, #data ; (A) \u003c- (A) and #data ANL direct, A ; (direct) \u003c- (direct) and (A) ANL direct, #data ; (direct) \u003c- (direct) and #data ORL 将目的操作数和源操作数按位相或，结果存放到目的操作数单元中 ORL A, Rn ; (A) \u003c- (A) or (Rn) ORL A, direct ; (A) \u003c- (A) or (direct) ORL A, @Ri ; (A) \u003c- (A) or ((Ri)) ORL A, #data ; (A) \u003c- (A) or #data ORL direct, A ; (direct) \u003c- (direct) or (A) ORL direct, #data ; (direct) \u003c- (direct) or #data XRL 将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中 XRL A, Rn ; (A) \u003c- (A) xor (Rn) XRL A, direct ; (A) \u003c- (A) xor (direct) XRL A, @Ri ; (A) \u003c- (A) xor ((Ri)) XRL A, #data ; (A) \u003c- (A) xor #data XRL direct, A ; (direct) \u003c- (direct) xor (A) XRL direct, #data ; (direct) \u003c- (direct) xor #data CLR 当操作数是累加器 A 时，对字节清零 CLR A ; (A) \u003c- 0 CPL 对累加器 A 的内容逐位取反。 CPL A ; (A) \u003c- /(A) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:6","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#orl"},{"categories":null,"content":"逻辑运算指令 不影响标志位，仅当其目的操作数为累加器 A 时，对奇偶标志位 P 有影响。 ANL 将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。 ANL A, Rn ; (A) \u003c- (A) and (Rn) ANL A, direct ; (A) \u003c- (A) and (direct) ANL A, @Ri ; (A) \u003c- (A) and ((Ri)) ANL A, #data ; (A) \u003c- (A) and #data ANL direct, A ; (direct) \u003c- (direct) and (A) ANL direct, #data ; (direct) \u003c- (direct) and #data ORL 将目的操作数和源操作数按位相或，结果存放到目的操作数单元中 ORL A, Rn ; (A) \u003c- (A) or (Rn) ORL A, direct ; (A) \u003c- (A) or (direct) ORL A, @Ri ; (A) \u003c- (A) or ((Ri)) ORL A, #data ; (A) \u003c- (A) or #data ORL direct, A ; (direct) \u003c- (direct) or (A) ORL direct, #data ; (direct) \u003c- (direct) or #data XRL 将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中 XRL A, Rn ; (A) \u003c- (A) xor (Rn) XRL A, direct ; (A) \u003c- (A) xor (direct) XRL A, @Ri ; (A) \u003c- (A) xor ((Ri)) XRL A, #data ; (A) \u003c- (A) xor #data XRL direct, A ; (direct) \u003c- (direct) xor (A) XRL direct, #data ; (direct) \u003c- (direct) xor #data CLR 当操作数是累加器 A 时，对字节清零 CLR A ; (A) \u003c- 0 CPL 对累加器 A 的内容逐位取反。 CPL A ; (A) \u003c- /(A) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:6","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#xrl"},{"categories":null,"content":"逻辑运算指令 不影响标志位，仅当其目的操作数为累加器 A 时，对奇偶标志位 P 有影响。 ANL 将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。 ANL A, Rn ; (A) \u003c- (A) and (Rn) ANL A, direct ; (A) \u003c- (A) and (direct) ANL A, @Ri ; (A) \u003c- (A) and ((Ri)) ANL A, #data ; (A) \u003c- (A) and #data ANL direct, A ; (direct) \u003c- (direct) and (A) ANL direct, #data ; (direct) \u003c- (direct) and #data ORL 将目的操作数和源操作数按位相或，结果存放到目的操作数单元中 ORL A, Rn ; (A) \u003c- (A) or (Rn) ORL A, direct ; (A) \u003c- (A) or (direct) ORL A, @Ri ; (A) \u003c- (A) or ((Ri)) ORL A, #data ; (A) \u003c- (A) or #data ORL direct, A ; (direct) \u003c- (direct) or (A) ORL direct, #data ; (direct) \u003c- (direct) or #data XRL 将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中 XRL A, Rn ; (A) \u003c- (A) xor (Rn) XRL A, direct ; (A) \u003c- (A) xor (direct) XRL A, @Ri ; (A) \u003c- (A) xor ((Ri)) XRL A, #data ; (A) \u003c- (A) xor #data XRL direct, A ; (direct) \u003c- (direct) xor (A) XRL direct, #data ; (direct) \u003c- (direct) xor #data CLR 当操作数是累加器 A 时，对字节清零 CLR A ; (A) \u003c- 0 CPL 对累加器 A 的内容逐位取反。 CPL A ; (A) \u003c- /(A) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:6","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#clr"},{"categories":null,"content":"逻辑运算指令 不影响标志位，仅当其目的操作数为累加器 A 时，对奇偶标志位 P 有影响。 ANL 将目的操作数和源操作数按位相与，结果存放到目的操作数单元中。 ANL A, Rn ; (A) \u003c- (A) and (Rn) ANL A, direct ; (A) \u003c- (A) and (direct) ANL A, @Ri ; (A) \u003c- (A) and ((Ri)) ANL A, #data ; (A) \u003c- (A) and #data ANL direct, A ; (direct) \u003c- (direct) and (A) ANL direct, #data ; (direct) \u003c- (direct) and #data ORL 将目的操作数和源操作数按位相或，结果存放到目的操作数单元中 ORL A, Rn ; (A) \u003c- (A) or (Rn) ORL A, direct ; (A) \u003c- (A) or (direct) ORL A, @Ri ; (A) \u003c- (A) or ((Ri)) ORL A, #data ; (A) \u003c- (A) or #data ORL direct, A ; (direct) \u003c- (direct) or (A) ORL direct, #data ; (direct) \u003c- (direct) or #data XRL 将目的操作数和源操作数按位相异或，结果存放到目的操作数单元中 XRL A, Rn ; (A) \u003c- (A) xor (Rn) XRL A, direct ; (A) \u003c- (A) xor (direct) XRL A, @Ri ; (A) \u003c- (A) xor ((Ri)) XRL A, #data ; (A) \u003c- (A) xor #data XRL direct, A ; (direct) \u003c- (direct) xor (A) XRL direct, #data ; (direct) \u003c- (direct) xor #data CLR 当操作数是累加器 A 时，对字节清零 CLR A ; (A) \u003c- 0 CPL 对累加器 A 的内容逐位取反。 CPL A ; (A) \u003c- /(A) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:6","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#cpl"},{"categories":null,"content":"移位运算指令 RL 循环左移指令，将 A 的内容循环左移一位。 RL A ; (A) \u003c- (A) \u003c\u003c 1 RR 循环右移指令，将 A 的内容循环右移一位。 RR A ; (A) \u003c- (A) \u003e\u003e 1 RLC 带进位标志位 C 的循环左移，将 A 的内容和 C 的内容整个左移一位。 RLC A ; (C)(A) \u003c- (C)(A) \u003c\u003c 1 RRC 带进位标志位 C 的循环右移，将 A 的内容和 C 的内容整个右移一位。 RRC A ; (C)(A) \u003c- (C)(A) \u003e\u003e 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:7","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#移位运算指令"},{"categories":null,"content":"移位运算指令 RL 循环左移指令，将 A 的内容循环左移一位。 RL A ; (A) \u003c- (A) \u003c\u003c 1 RR 循环右移指令，将 A 的内容循环右移一位。 RR A ; (A) \u003c- (A) \u003e\u003e 1 RLC 带进位标志位 C 的循环左移，将 A 的内容和 C 的内容整个左移一位。 RLC A ; (C)(A) \u003c- (C)(A) \u003c\u003c 1 RRC 带进位标志位 C 的循环右移，将 A 的内容和 C 的内容整个右移一位。 RRC A ; (C)(A) \u003c- (C)(A) \u003e\u003e 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:7","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#rl"},{"categories":null,"content":"移位运算指令 RL 循环左移指令，将 A 的内容循环左移一位。 RL A ; (A) \u003c- (A) \u003c\u003c 1 RR 循环右移指令，将 A 的内容循环右移一位。 RR A ; (A) \u003c- (A) \u003e\u003e 1 RLC 带进位标志位 C 的循环左移，将 A 的内容和 C 的内容整个左移一位。 RLC A ; (C)(A) \u003c- (C)(A) \u003c\u003c 1 RRC 带进位标志位 C 的循环右移，将 A 的内容和 C 的内容整个右移一位。 RRC A ; (C)(A) \u003c- (C)(A) \u003e\u003e 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:7","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#rr"},{"categories":null,"content":"移位运算指令 RL 循环左移指令，将 A 的内容循环左移一位。 RL A ; (A) \u003c- (A) \u003c\u003c 1 RR 循环右移指令，将 A 的内容循环右移一位。 RR A ; (A) \u003c- (A) \u003e\u003e 1 RLC 带进位标志位 C 的循环左移，将 A 的内容和 C 的内容整个左移一位。 RLC A ; (C)(A) \u003c- (C)(A) \u003c\u003c 1 RRC 带进位标志位 C 的循环右移，将 A 的内容和 C 的内容整个右移一位。 RRC A ; (C)(A) \u003c- (C)(A) \u003e\u003e 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:7","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#rlc"},{"categories":null,"content":"移位运算指令 RL 循环左移指令，将 A 的内容循环左移一位。 RL A ; (A) \u003c- (A) \u003c\u003c 1 RR 循环右移指令，将 A 的内容循环右移一位。 RR A ; (A) \u003c- (A) \u003e\u003e 1 RLC 带进位标志位 C 的循环左移，将 A 的内容和 C 的内容整个左移一位。 RLC A ; (C)(A) \u003c- (C)(A) \u003c\u003c 1 RRC 带进位标志位 C 的循环右移，将 A 的内容和 C 的内容整个右移一位。 RRC A ; (C)(A) \u003c- (C)(A) \u003e\u003e 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:7","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#rrc"},{"categories":null,"content":"无条件跳转指令 LJMP 长跳转指令，跳转范围为 0000H-FFFFH 。 LJMP addr16 ; (PC) \u003c- addr16 AJMP 绝对跳转指令，跳转范围为相同 ROM 的 2KB 区域 (000H-7FFH) 。 AJMP addr11 ; (PC) \u003c- (PC) + 2 ; (PC)[0..11] \u003c- addr11 由于地址是 11 位的，作为无符号整型时最大可表示 2047 ，对 PC 赋值时高 5 位不变，仅对低 11 位进行赋值，如果不在同一个 2KB 区域中，就会跳转至错误的位置。 SJMP 短跳转指令，跳转范围为 80H-7FH （有符号）。 SJMP rel ; (PC) \u003c- (PC) + 2 + rel JMP 散转指令或间接跳转指令。跳转位置取决于 DPTR 与累加器 A 的值。 JMP @A+DPTR ; (PC) \u003c- (A) + (DPTR) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:8","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#无条件跳转指令"},{"categories":null,"content":"无条件跳转指令 LJMP 长跳转指令，跳转范围为 0000H-FFFFH 。 LJMP addr16 ; (PC) \u003c- addr16 AJMP 绝对跳转指令，跳转范围为相同 ROM 的 2KB 区域 (000H-7FFH) 。 AJMP addr11 ; (PC) \u003c- (PC) + 2 ; (PC)[0..11] \u003c- addr11 由于地址是 11 位的，作为无符号整型时最大可表示 2047 ，对 PC 赋值时高 5 位不变，仅对低 11 位进行赋值，如果不在同一个 2KB 区域中，就会跳转至错误的位置。 SJMP 短跳转指令，跳转范围为 80H-7FH （有符号）。 SJMP rel ; (PC) \u003c- (PC) + 2 + rel JMP 散转指令或间接跳转指令。跳转位置取决于 DPTR 与累加器 A 的值。 JMP @A+DPTR ; (PC) \u003c- (A) + (DPTR) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:8","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#ljmp"},{"categories":null,"content":"无条件跳转指令 LJMP 长跳转指令，跳转范围为 0000H-FFFFH 。 LJMP addr16 ; (PC) \u003c- addr16 AJMP 绝对跳转指令，跳转范围为相同 ROM 的 2KB 区域 (000H-7FFH) 。 AJMP addr11 ; (PC) \u003c- (PC) + 2 ; (PC)[0..11] \u003c- addr11 由于地址是 11 位的，作为无符号整型时最大可表示 2047 ，对 PC 赋值时高 5 位不变，仅对低 11 位进行赋值，如果不在同一个 2KB 区域中，就会跳转至错误的位置。 SJMP 短跳转指令，跳转范围为 80H-7FH （有符号）。 SJMP rel ; (PC) \u003c- (PC) + 2 + rel JMP 散转指令或间接跳转指令。跳转位置取决于 DPTR 与累加器 A 的值。 JMP @A+DPTR ; (PC) \u003c- (A) + (DPTR) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:8","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#ajmp"},{"categories":null,"content":"无条件跳转指令 LJMP 长跳转指令，跳转范围为 0000H-FFFFH 。 LJMP addr16 ; (PC) \u003c- addr16 AJMP 绝对跳转指令，跳转范围为相同 ROM 的 2KB 区域 (000H-7FFH) 。 AJMP addr11 ; (PC) \u003c- (PC) + 2 ; (PC)[0..11] \u003c- addr11 由于地址是 11 位的，作为无符号整型时最大可表示 2047 ，对 PC 赋值时高 5 位不变，仅对低 11 位进行赋值，如果不在同一个 2KB 区域中，就会跳转至错误的位置。 SJMP 短跳转指令，跳转范围为 80H-7FH （有符号）。 SJMP rel ; (PC) \u003c- (PC) + 2 + rel JMP 散转指令或间接跳转指令。跳转位置取决于 DPTR 与累加器 A 的值。 JMP @A+DPTR ; (PC) \u003c- (A) + (DPTR) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:8","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#sjmp"},{"categories":null,"content":"无条件跳转指令 LJMP 长跳转指令，跳转范围为 0000H-FFFFH 。 LJMP addr16 ; (PC) \u003c- addr16 AJMP 绝对跳转指令，跳转范围为相同 ROM 的 2KB 区域 (000H-7FFH) 。 AJMP addr11 ; (PC) \u003c- (PC) + 2 ; (PC)[0..11] \u003c- addr11 由于地址是 11 位的，作为无符号整型时最大可表示 2047 ，对 PC 赋值时高 5 位不变，仅对低 11 位进行赋值，如果不在同一个 2KB 区域中，就会跳转至错误的位置。 SJMP 短跳转指令，跳转范围为 80H-7FH （有符号）。 SJMP rel ; (PC) \u003c- (PC) + 2 + rel JMP 散转指令或间接跳转指令。跳转位置取决于 DPTR 与累加器 A 的值。 JMP @A+DPTR ; (PC) \u003c- (A) + (DPTR) ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:8","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jmp"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#条件跳转指令"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jz"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jnz"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#cjne"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#djnz"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jbn"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jbc"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jc"},{"categories":null,"content":"条件跳转指令 JZ Jump if ACC equal Zero 当累加器 A 为 0 时跳转，否则继续执行。 JZ rel ; (A) == 0 =\u003e (PC) \u003c- (PC) + 2 + rel JNZ Jump if ACC Not equal Zero 当累加器 A 不为 0 时跳转，否则继续执行。 JNZ rel ; (A) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel CJNE Compare and Jump if Not Equal 对前两个操作数进行比较，如果不相等则进行跳转。并且比较结果将影响标志位 C ： 操作数1 \u003e 操作数2： C 为 0 操作数1 \u003c 操作数2： C 为 1 CJNE A, direct, rel ; (A) != (direct) =\u003e (PC) \u003c- (PC) + 3 + rel CJNE A, #data, rel ; (A) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE Rn, #data, rel ; (Rn) != data =\u003e (PC) \u003c- (PC) + 3 + rel CJNE @Ri, #data, rel ; ((Ri)) != data =\u003e (PC) \u003c- (PC) + 3 + rel DJNZ Decrement and Jump if Not equal Zero 将工作寄存器 Rn 的值减去 1 ，若相减后 Rn 不为 0 则进行跳转 ，否则继续执行。 DJNZ Rn, rel ; (Rn) \u003c- (Rn) - 1 ; (Rn) != 0 =\u003e (PC) \u003c- (PC) + 2 + rel JBN Jump if the Bit is Not set 如果位未置位，则进行跳转。 JNB bit, rel ; (bit) == 0 =\u003e (PC) \u003c- (PC) + rel JBC Jump if the Bit is set and Clear the bit 如果位已置位，则进行跳转，并复位。 JBC bit, rel ; (bit) == 1 =\u003e (PC) \u003c- (PC) + rel ; (bit) \u003c- 0 JC JC rel ; (C) == 1 =\u003e (PC) \u003c- (PC) + rel JNC JNC rel ; (C) == 0 =\u003e (PC) \u003c- (PC) + rel ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:9","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#jnc"},{"categories":null,"content":"子程序指令 LCALL 该指令可调用存放在 64KB ROM 空间任何位置的子程序，跳转前会分别将 PCL （ PC 的低 8 位）与 PCH （ PC 的高 8 位）入栈，便于退出子程序后进行恢复。 LCALL addr16 ; (PC) \u003c- (PC) + 3 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC) \u003c- addr16 ACALL 与 AJMP 一样，跳转的子程序必须位于相同 ROM 的 2KB 区域 (000H-7FFH) 内。 ACALL addr11 ; (PC) \u003c- (PC) + 2 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC)[0..10] \u003c- addr11 由于 MCU 的 ROM 容量不再是问题，所以这条指令很少使用。 RET 从堆栈顶部的弹出子程序调用时，压入保护的断点地址到 PC 。子程序的最后一条指令必须是 RET 指令。 RET ; (PCH) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ; (PCL) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 RETI 除具有 RET 的功能外,还可以恢复中断逻辑（不能互换使用），中断子程序的最后一条指令，必须是 RETI 指令。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:10","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#子程序指令"},{"categories":null,"content":"子程序指令 LCALL 该指令可调用存放在 64KB ROM 空间任何位置的子程序，跳转前会分别将 PCL （ PC 的低 8 位）与 PCH （ PC 的高 8 位）入栈，便于退出子程序后进行恢复。 LCALL addr16 ; (PC) \u003c- (PC) + 3 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC) \u003c- addr16 ACALL 与 AJMP 一样，跳转的子程序必须位于相同 ROM 的 2KB 区域 (000H-7FFH) 内。 ACALL addr11 ; (PC) \u003c- (PC) + 2 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC)[0..10] \u003c- addr11 由于 MCU 的 ROM 容量不再是问题，所以这条指令很少使用。 RET 从堆栈顶部的弹出子程序调用时，压入保护的断点地址到 PC 。子程序的最后一条指令必须是 RET 指令。 RET ; (PCH) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ; (PCL) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 RETI 除具有 RET 的功能外,还可以恢复中断逻辑（不能互换使用），中断子程序的最后一条指令，必须是 RETI 指令。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:10","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#lcall"},{"categories":null,"content":"子程序指令 LCALL 该指令可调用存放在 64KB ROM 空间任何位置的子程序，跳转前会分别将 PCL （ PC 的低 8 位）与 PCH （ PC 的高 8 位）入栈，便于退出子程序后进行恢复。 LCALL addr16 ; (PC) \u003c- (PC) + 3 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC) \u003c- addr16 ACALL 与 AJMP 一样，跳转的子程序必须位于相同 ROM 的 2KB 区域 (000H-7FFH) 内。 ACALL addr11 ; (PC) \u003c- (PC) + 2 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC)[0..10] \u003c- addr11 由于 MCU 的 ROM 容量不再是问题，所以这条指令很少使用。 RET 从堆栈顶部的弹出子程序调用时，压入保护的断点地址到 PC 。子程序的最后一条指令必须是 RET 指令。 RET ; (PCH) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ; (PCL) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 RETI 除具有 RET 的功能外,还可以恢复中断逻辑（不能互换使用），中断子程序的最后一条指令，必须是 RETI 指令。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:10","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#acall"},{"categories":null,"content":"子程序指令 LCALL 该指令可调用存放在 64KB ROM 空间任何位置的子程序，跳转前会分别将 PCL （ PC 的低 8 位）与 PCH （ PC 的高 8 位）入栈，便于退出子程序后进行恢复。 LCALL addr16 ; (PC) \u003c- (PC) + 3 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC) \u003c- addr16 ACALL 与 AJMP 一样，跳转的子程序必须位于相同 ROM 的 2KB 区域 (000H-7FFH) 内。 ACALL addr11 ; (PC) \u003c- (PC) + 2 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC)[0..10] \u003c- addr11 由于 MCU 的 ROM 容量不再是问题，所以这条指令很少使用。 RET 从堆栈顶部的弹出子程序调用时，压入保护的断点地址到 PC 。子程序的最后一条指令必须是 RET 指令。 RET ; (PCH) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ; (PCL) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 RETI 除具有 RET 的功能外,还可以恢复中断逻辑（不能互换使用），中断子程序的最后一条指令，必须是 RETI 指令。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:10","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#ret"},{"categories":null,"content":"子程序指令 LCALL 该指令可调用存放在 64KB ROM 空间任何位置的子程序，跳转前会分别将 PCL （ PC 的低 8 位）与 PCH （ PC 的高 8 位）入栈，便于退出子程序后进行恢复。 LCALL addr16 ; (PC) \u003c- (PC) + 3 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC) \u003c- addr16 ACALL 与 AJMP 一样，跳转的子程序必须位于相同 ROM 的 2KB 区域 (000H-7FFH) 内。 ACALL addr11 ; (PC) \u003c- (PC) + 2 ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCL ; (SP) \u003c- (SP) + 1 ; ((SP)) \u003c- PCH ; (PC)[0..10] \u003c- addr11 由于 MCU 的 ROM 容量不再是问题，所以这条指令很少使用。 RET 从堆栈顶部的弹出子程序调用时，压入保护的断点地址到 PC 。子程序的最后一条指令必须是 RET 指令。 RET ; (PCH) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 ; (PCL) \u003c- ((SP)) ; (SP) \u003c- (SP) - 1 RETI 除具有 RET 的功能外,还可以恢复中断逻辑（不能互换使用），中断子程序的最后一条指令，必须是 RETI 指令。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:10","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#reti"},{"categories":null,"content":"空指令 NOP 无实际作用，占用一个机器周期时间。常用于软件延时。 NOP ; (PC) \u003c- (PC) + 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:11","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#空指令"},{"categories":null,"content":"空指令 NOP 无实际作用，占用一个机器周期时间。常用于软件延时。 NOP ; (PC) \u003c- (PC) + 1 ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:11","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#nop"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#伪指令"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#org"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#equ"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#db"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#dw"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#bit"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#end"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#ds"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#data"},{"categories":null,"content":"伪指令 伪指令是汇编程序需要的控制译码指令，不产生机器码，不影响程序的执行。 ORG 给出程序存放的起始地址，给程序或数据块的起始地址赋值。在一个源程序中可以多次使用，必须从小到大，不允许重叠。 ORG addr16 其中 addr16 是直接给出的 16 位二进制数。 EQU 给数据或表达式赋予字符名称，以便在 之后的 程序中直接用这个名称代替这个数据或表达式，并且还可以将汇编符号赋给符号名。 NAME EQU expr 如： DATA1 EQU 22H DB 将常数或字符 data 串存入标号开始的连续存储单元中，通常用于定义数据。 TABLE: DB data 如： TABLE: DB \"ABC\",1,2,3,FFH 在 51 单片机 中只能用于 ROM 中。 DW 将字或字串分成若干个字节，从高字节到低字节放入连续的存储单元中，通常用于定义地址。 LBAEL: DW data 如： LBAEL: DW 1234H, FFFFH 此时 LABEL 对应的存储单元里有 12H, 34H, FFH, FFH 。 DW 与 DB 定义的数表中数的个数不能超过 80 个，若超过需要使用多个命令进行定义。在 51 单片机 中只能用于 ROM 中。 BIT 给位地址 addr 赋予字符名称 NAME ，以便在程序中直接用这个名称代替这个位地址。 NAME BIT addr END 表示汇编程序的结束，一个程序中有且仅有一条。 END DS 使得汇编程序从标号开始保留若干个存储单元。 NAME: DS N 在 51 单片机 中只能用于 ROM 中。 DATA 给数据或表达式赋予字符名称，以便在 整个 程序中直接用这个名称代替这个数据或表达式。不能将汇编符号赋给符号名。 NAME DATA data XDATA ","date":"2022-03-29","objectID":"/posts/notes/8051/:9:12","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#xdata"},{"categories":null,"content":"C51 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:0","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#c51"},{"categories":null,"content":"变量 变量类型 标准 数据类型 位数 范围 标准 C 语言 signed char 8 -128-127 unsigned char 8 0-255 signed int 16 -32768-32767 unsigned int 16 0--65535 signed long 32 -2147483648-2147483647 unsigned long 32 0-4294967295 float 32 C51 bit 1 0-1 sbit 1 0-1 sfr 8 0-255 sfr16 16 0-65535 bit 用于声明一个位变量，其寻址空间在通用 RAM 中，位地址为 00H-7FH 的位空间。不能声明一个位变量的指针或数组。 sbit 用于声明一个特殊功能寄存器中的位变量，其寻址空间在特殊功能寄存器的可位寻址空间中。声明时指定的不是初始值，而是变量的地址，如： sbit P = 0xD0; 很像是 C++ 中的引用类型，本质上是一个地址，但进行赋值、运算等操作时会自动解引用。 sfr 定义特殊功能寄存器中的字节变量，与 sbit 一样，本质上是一个地址，如： sfr P0 = 0x80; = 后必须是 80H-FFH 之间的常数。 sfr16 定义特殊功能寄存器中的双字节变量，与 sfr 一样，本质上是一个地址，如： sfr16 DPTR = 0x82; // DPL = 0x82, DPH = 0x83 在变量定义中出现的是低字节地址。 变量位置 存储器类型 存储空间描述 大小 code 内部 ROM 64KB data 可直接访问的内部 RAM 低 128B idata 可间接访问的内部 RAM 256B bdata 可位寻址的内部 RAM 16B (20H-2FH) xdata 外部 RAM 最大 64KB pdata 分页的 RAM 256B/页 访问内部 RAM 比较快，应该把频繁使用的变量放置在内部 RAM 中。在变量类型和变量之间可以插入变量位置修饰符： int code i = 0; // 内部 ROM 如果未指定存储器类型（即变量的位置），编译器根据编译器参数（ SMALL, COMPACT, LARGE ）自动选择默认存储器类型： 存储模式 存储器类型 SMALL data COMPACT pdata LARGE xdata SMALL 缺省变量参数均装入内部 RAM，优点是访问速度快，缺点是空间有限，适用于小程序。 LARGE 缺省变量可放在 64KB 的外部 RAM 区，优点是空间大，可存变量多，缺点是速度较慢。 COMPACT 缺省变量均位于外部 RAM 区的一页 (256B)，速度和空间适中。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#变量"},{"categories":null,"content":"变量 变量类型 标准 数据类型 位数 范围 标准 C 语言 signed char 8 -128-127 unsigned char 8 0-255 signed int 16 -32768-32767 unsigned int 16 0--65535 signed long 32 -2147483648-2147483647 unsigned long 32 0-4294967295 float 32 C51 bit 1 0-1 sbit 1 0-1 sfr 8 0-255 sfr16 16 0-65535 bit 用于声明一个位变量，其寻址空间在通用 RAM 中，位地址为 00H-7FH 的位空间。不能声明一个位变量的指针或数组。 sbit 用于声明一个特殊功能寄存器中的位变量，其寻址空间在特殊功能寄存器的可位寻址空间中。声明时指定的不是初始值，而是变量的地址，如： sbit P = 0xD0; 很像是 C++ 中的引用类型，本质上是一个地址，但进行赋值、运算等操作时会自动解引用。 sfr 定义特殊功能寄存器中的字节变量，与 sbit 一样，本质上是一个地址，如： sfr P0 = 0x80; = 后必须是 80H-FFH 之间的常数。 sfr16 定义特殊功能寄存器中的双字节变量，与 sfr 一样，本质上是一个地址，如： sfr16 DPTR = 0x82; // DPL = 0x82, DPH = 0x83 在变量定义中出现的是低字节地址。 变量位置 存储器类型 存储空间描述 大小 code 内部 ROM 64KB data 可直接访问的内部 RAM 低 128B idata 可间接访问的内部 RAM 256B bdata 可位寻址的内部 RAM 16B (20H-2FH) xdata 外部 RAM 最大 64KB pdata 分页的 RAM 256B/页 访问内部 RAM 比较快，应该把频繁使用的变量放置在内部 RAM 中。在变量类型和变量之间可以插入变量位置修饰符： int code i = 0; // 内部 ROM 如果未指定存储器类型（即变量的位置），编译器根据编译器参数（ SMALL, COMPACT, LARGE ）自动选择默认存储器类型： 存储模式 存储器类型 SMALL data COMPACT pdata LARGE xdata SMALL 缺省变量参数均装入内部 RAM，优点是访问速度快，缺点是空间有限，适用于小程序。 LARGE 缺省变量可放在 64KB 的外部 RAM 区，优点是空间大，可存变量多，缺点是速度较慢。 COMPACT 缺省变量均位于外部 RAM 区的一页 (256B)，速度和空间适中。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#变量类型"},{"categories":null,"content":"变量 变量类型 标准 数据类型 位数 范围 标准 C 语言 signed char 8 -128-127 unsigned char 8 0-255 signed int 16 -32768-32767 unsigned int 16 0--65535 signed long 32 -2147483648-2147483647 unsigned long 32 0-4294967295 float 32 C51 bit 1 0-1 sbit 1 0-1 sfr 8 0-255 sfr16 16 0-65535 bit 用于声明一个位变量，其寻址空间在通用 RAM 中，位地址为 00H-7FH 的位空间。不能声明一个位变量的指针或数组。 sbit 用于声明一个特殊功能寄存器中的位变量，其寻址空间在特殊功能寄存器的可位寻址空间中。声明时指定的不是初始值，而是变量的地址，如： sbit P = 0xD0; 很像是 C++ 中的引用类型，本质上是一个地址，但进行赋值、运算等操作时会自动解引用。 sfr 定义特殊功能寄存器中的字节变量，与 sbit 一样，本质上是一个地址，如： sfr P0 = 0x80; = 后必须是 80H-FFH 之间的常数。 sfr16 定义特殊功能寄存器中的双字节变量，与 sfr 一样，本质上是一个地址，如： sfr16 DPTR = 0x82; // DPL = 0x82, DPH = 0x83 在变量定义中出现的是低字节地址。 变量位置 存储器类型 存储空间描述 大小 code 内部 ROM 64KB data 可直接访问的内部 RAM 低 128B idata 可间接访问的内部 RAM 256B bdata 可位寻址的内部 RAM 16B (20H-2FH) xdata 外部 RAM 最大 64KB pdata 分页的 RAM 256B/页 访问内部 RAM 比较快，应该把频繁使用的变量放置在内部 RAM 中。在变量类型和变量之间可以插入变量位置修饰符： int code i = 0; // 内部 ROM 如果未指定存储器类型（即变量的位置），编译器根据编译器参数（ SMALL, COMPACT, LARGE ）自动选择默认存储器类型： 存储模式 存储器类型 SMALL data COMPACT pdata LARGE xdata SMALL 缺省变量参数均装入内部 RAM，优点是访问速度快，缺点是空间有限，适用于小程序。 LARGE 缺省变量可放在 64KB 的外部 RAM 区，优点是空间大，可存变量多，缺点是速度较慢。 COMPACT 缺省变量均位于外部 RAM 区的一页 (256B)，速度和空间适中。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:1","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#变量位置"},{"categories":null,"content":"指针 通用指针 通用指针可以指向任意位置的变量，指针变量本身占用 3 字节的空间。 int *(data ptr); 特殊指针 指针变量本身可以指定变量位置，由于普通变量可以指定位置，指针大小会根据变量不同的位置改变。 int code *(data ptr); 根据 C 语言的变量定义等式，意思是位于 data 中的指针 ptr 经过解引用后得到位于 code 中的 int 变量。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#指针"},{"categories":null,"content":"指针 通用指针 通用指针可以指向任意位置的变量，指针变量本身占用 3 字节的空间。 int *(data ptr); 特殊指针 指针变量本身可以指定变量位置，由于普通变量可以指定位置，指针大小会根据变量不同的位置改变。 int code *(data ptr); 根据 C 语言的变量定义等式，意思是位于 data 中的指针 ptr 经过解引用后得到位于 code 中的 int 变量。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#通用指针"},{"categories":null,"content":"指针 通用指针 通用指针可以指向任意位置的变量，指针变量本身占用 3 字节的空间。 int *(data ptr); 特殊指针 指针变量本身可以指定变量位置，由于普通变量可以指定位置，指针大小会根据变量不同的位置改变。 int code *(data ptr); 根据 C 语言的变量定义等式，意思是位于 data 中的指针 ptr 经过解引用后得到位于 code 中的 int 变量。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:2","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#特殊指针"},{"categories":null,"content":"函数 在标准 C 语言函数定义的基础上，在函数原型定义和函数体之间可以加入修饰符： small, compact, large 函数里的变量存放位置。 reentrant 说明该函数可递归或重入的。 interrupt n 说明该函数是个中断处理子程序， n 的取值为 0-31 。 using n 指定函数使用的工作寄存器组。若不指定，则选用第 0 个工作寄存器组。 如： void function() compact reentrant interrupt 0 using 0 { } ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:3","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#函数"},{"categories":null,"content":"标准库 本征函数 C51 的本征库函数定义在 intrins.h 头文件中。 _crol_ 返回将 8 位整型 (char) 变量左移指定位数的结果。 _cror_ 返回将 8 位整型 (char) 变量右移指定位数的结果。 _irol_ 返回将 16 位整型 (int) 变量左移指定位数的结果。 _iror_ 返回将 16 位整型 (int) 变量右移指定位数的结果。 _lrol_ 返回将 32 位整型 (long) 变量左移指定位数的结果。 _lror_ 返回将 32 位整型 (long) 变量右移指定位数的结果。 _nop_ 相当于插入空指令 NOP 。 _testbit_ 相当于对位变量使用 JBC 。 _chkfloat_ 测试并返回浮点数状态。 非本征函数 效率与本征函数相比较低。 8051 库函数 reg51.h 包括了所有 8051 的特殊功能寄存器及其位定义，一般系统都必须包括本文件。 absacc.h 定义绝对存储器访问的宏，以确定各存储空间的绝对地址。 C 语言标准库 stdlib.h 包括数据类型转换和存储器分配函数。 string.h 包含字符串和缓存操作函数。 stdio.h 包含流输入输出的原型函数。 math.h 包含数学计算库函数。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#标准库"},{"categories":null,"content":"标准库 本征函数 C51 的本征库函数定义在 intrins.h 头文件中。 _crol_ 返回将 8 位整型 (char) 变量左移指定位数的结果。 _cror_ 返回将 8 位整型 (char) 变量右移指定位数的结果。 _irol_ 返回将 16 位整型 (int) 变量左移指定位数的结果。 _iror_ 返回将 16 位整型 (int) 变量右移指定位数的结果。 _lrol_ 返回将 32 位整型 (long) 变量左移指定位数的结果。 _lror_ 返回将 32 位整型 (long) 变量右移指定位数的结果。 _nop_ 相当于插入空指令 NOP 。 _testbit_ 相当于对位变量使用 JBC 。 _chkfloat_ 测试并返回浮点数状态。 非本征函数 效率与本征函数相比较低。 8051 库函数 reg51.h 包括了所有 8051 的特殊功能寄存器及其位定义，一般系统都必须包括本文件。 absacc.h 定义绝对存储器访问的宏，以确定各存储空间的绝对地址。 C 语言标准库 stdlib.h 包括数据类型转换和存储器分配函数。 string.h 包含字符串和缓存操作函数。 stdio.h 包含流输入输出的原型函数。 math.h 包含数学计算库函数。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#本征函数"},{"categories":null,"content":"标准库 本征函数 C51 的本征库函数定义在 intrins.h 头文件中。 _crol_ 返回将 8 位整型 (char) 变量左移指定位数的结果。 _cror_ 返回将 8 位整型 (char) 变量右移指定位数的结果。 _irol_ 返回将 16 位整型 (int) 变量左移指定位数的结果。 _iror_ 返回将 16 位整型 (int) 变量右移指定位数的结果。 _lrol_ 返回将 32 位整型 (long) 变量左移指定位数的结果。 _lror_ 返回将 32 位整型 (long) 变量右移指定位数的结果。 _nop_ 相当于插入空指令 NOP 。 _testbit_ 相当于对位变量使用 JBC 。 _chkfloat_ 测试并返回浮点数状态。 非本征函数 效率与本征函数相比较低。 8051 库函数 reg51.h 包括了所有 8051 的特殊功能寄存器及其位定义，一般系统都必须包括本文件。 absacc.h 定义绝对存储器访问的宏，以确定各存储空间的绝对地址。 C 语言标准库 stdlib.h 包括数据类型转换和存储器分配函数。 string.h 包含字符串和缓存操作函数。 stdio.h 包含流输入输出的原型函数。 math.h 包含数学计算库函数。 ","date":"2022-03-29","objectID":"/posts/notes/8051/:10:4","series":null,"tags":["单片机","汇编语言"],"title":"8051","uri":"/posts/notes/8051/#非本征函数"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:0:0","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#"},{"categories":null,"content":"Processor Architecture ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:1:0","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#processor-architecture"},{"categories":null,"content":"Harvard Architecture 程序存储器和数据存储器分为 2 个寻址空间，指令和数据可采用不同的数据宽度，具有较高的执行效率。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:1:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#harvard-architecture"},{"categories":null,"content":"Von Neumann Architecture 程序存储器和数据存储器合并在同一个寻址空间中。程序存储地址和数据存储地址指向同一个存储器的不同物理位置，程序指令和数据的宽度相同。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:1:2","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#von-neumann-architecture"},{"categories":null,"content":"Central Process Unit 中央处理器系统 中央处理器 按照面向测控对象、嵌入式应用和单芯片结构要求，专门设计的要保证有突出的控制功能。 时钟系统 满足中央处理器及片内各单元电路对时钟的要求。 复位电路 能满足上电复位、信号复位的最简化电路。 总线控制逻辑 要满足中央处理器对内部总线和外部总线的控制。 内部总线控制：用以实现片内各单元电路的协调操作。 外部总线控制：用于微控制器外围扩展时的操作管理。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:2:0","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#central-process-unit"},{"categories":null,"content":"Complex Instruction Set Computer 复杂指令集计算机。 优点 寻址方式多 指令丰富 一条指令往往可以完成一串动作，且具有专用指令（如各种运算、控制转移等）因此对于复杂计算与操作的程序设计相对容易，（汇编）编程效率较高。 缺点 指令的长度不同，执行速度低 CPU 硬件结构复杂 面积大 功耗大 对工艺要求高 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:2:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#complex-instruction-set-computer"},{"categories":null,"content":"Reduced Instruction Set Computer 精简指令集计算机。 优点 指令单周期、定长代码及一个地址对应一条指令的指令体系 每条指令都有归一化的取指、译码、操作、回授 4 个进程，则可实现 4 条指令相差一个进程的并行操作，即 实现“取指-执行”的流水线操作方式，并且CPU硬件结构简单。 缺点 实现特殊或复杂功能时，汇编语言程序设计难度增大，编程效率较低，并且一般需要较大的内存空间。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:2:2","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#reduced-instruction-set-computer"},{"categories":null,"content":"Memory 存储器主要由以下几个部分组成： 存储单元 地址译码器 存储器中的译码电路用于产生各存储单元的选通信号。译码器的输入是存储器的地址引脚，应连接到微控制器的地址线。存储器芯片的地址线位数决定其容量；微控制器的地址线数量决定其寻址能力。 读写控制 三态双向缓冲器 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:0","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#memory"},{"categories":null,"content":"Read Only Memory Programmable Read Only Memory One Time Programmable Read Only Memory Erasable Programmable Read Only Memory Electrically Erasable Programmable Read Only Memory Flash Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#read-only-memory"},{"categories":null,"content":"Read Only Memory Programmable Read Only Memory One Time Programmable Read Only Memory Erasable Programmable Read Only Memory Electrically Erasable Programmable Read Only Memory Flash Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#programmable-read-only-memory"},{"categories":null,"content":"Read Only Memory Programmable Read Only Memory One Time Programmable Read Only Memory Erasable Programmable Read Only Memory Electrically Erasable Programmable Read Only Memory Flash Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#one-time-programmable-read-only-memory"},{"categories":null,"content":"Read Only Memory Programmable Read Only Memory One Time Programmable Read Only Memory Erasable Programmable Read Only Memory Electrically Erasable Programmable Read Only Memory Flash Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#erasable-programmable-read-only-memory"},{"categories":null,"content":"Read Only Memory Programmable Read Only Memory One Time Programmable Read Only Memory Erasable Programmable Read Only Memory Electrically Erasable Programmable Read Only Memory Flash Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#electrically-erasable-programmable-read-only-memory"},{"categories":null,"content":"Read Only Memory Programmable Read Only Memory One Time Programmable Read Only Memory Erasable Programmable Read Only Memory Electrically Erasable Programmable Read Only Memory Flash Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#flash-memory"},{"categories":null,"content":"Random Access Memory Dynamic Random Access Memory Static Random Access Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:2","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#random-access-memory"},{"categories":null,"content":"Random Access Memory Dynamic Random Access Memory Static Random Access Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:2","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#dynamic-random-access-memory"},{"categories":null,"content":"Random Access Memory Dynamic Random Access Memory Static Random Access Memory ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:3:2","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#static-random-access-memory"},{"categories":null,"content":"Input/Output Interface 微控制器的 I/O 接口通过芯片引脚引出，为了减少引脚数量，微控制器的 I/O 接口大都有复用功能。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:4:0","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#input-output-interface"},{"categories":null,"content":"Bus 总线是计算机中各功能部件间传送信息的公共通道，是微型计算机的重要组成部分。它们可以是带状的扁平电缆线，也可以是印刷电路板上的一层极薄的金属连线。所有的信息都通过总线传送。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:5:0","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#bus"},{"categories":null,"content":"Data Bus 双向，用于传送数据，实现 CPU 与存储器、I/O 接口、各功能模块之间的信息交换，其方向取决于是读操作还是写操作。 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:5:1","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#data-bus"},{"categories":null,"content":"Address Bus 单向，由 CPU 发出地址信息，用来访问存储器和 I/O 接口 。地址总线的位数决定 CPU 可直接寻址的内存空间大小， ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:5:2","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#address-bus"},{"categories":null,"content":"Control Bus 单向，传送控制或时序信号，如： 读/写信号 中断申请信号 复位信号 ","date":"2022-03-29","objectID":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/:5:3","series":null,"tags":["单片机"],"title":"微机原理","uri":"/posts/notes/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/#control-bus"},{"categories":null,"content":"引言 本人目前将 EMMS 作为主力本地音乐播放器使用，因为 EMMS 不仅可以方便地用于播放列表管理、歌曲评分管理，还能在敲代码时用余光瞄一眼歌词。 EMMS 虽然可以实现外部 .lrc 文件的加载以及网络歌词的下载，但对于自己下载的本地歌词而言，本人还是习惯于将歌词文件嵌入到音乐的标签数据中，这样不仅可以没有顾虑地随意移动或者重命名音乐文件，还可以让存放音乐的文件夹更加简洁。目前上很多播放器都支持内嵌歌词的功能，但是 EMMS 原生是不支持这个功能的，于是就打算自己添加了。 ","date":"2022-03-06","objectID":"/posts/blog/%E8%AE%A9-emms-%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BA%E9%9F%B3%E4%B9%90%E6%96%87%E4%BB%B6%E5%86%85%E5%B5%8C%E6%AD%8C%E8%AF%8D/:1:0","series":null,"tags":["EMMS","Emacs"],"title":"让 EMMS 读取并显示音乐文件内嵌歌词","uri":"/posts/blog/%E8%AE%A9-emms-%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BA%E9%9F%B3%E4%B9%90%E6%96%87%E4%BB%B6%E5%86%85%E5%B5%8C%E6%AD%8C%E8%AF%8D/#引言"},{"categories":null,"content":"实现 研究了一段时间，发现只需要修改 2 个函数即可实现：现在的 EMMS 大部分音乐的元数据主要由 emms-info-native 提供，里面定义了这个列表常量： (defconst emms-info-native--accepted-vorbis-fields '(\"album\" \"albumartist\" \"albumartistsort\" \"albumsort\" \"artist\" \"artistsort\" \"composer\" \"composersort\" \"date\" \"discnumber\" \"genre\" \"label\" \"originaldate\" \"originalyear\" \"performer\" \"title\" \"titlesort\" \"tracknumber\" \"year\") \"EMMS info fields that are extracted from Vorbis comments.\") 这个列表常量用于指定 EMMS 读取的音乐文件的标签类型，我个人不太清楚 EMMS 作者将它定义成常量的意图，但是不影响修改它，为它增加 \"lyrics\" 元素： (push \"lyrics\" emms-info-native--accepted-vorbis-fields) 至此， EMMS 已经可以读取文件的 info-lyrics 了，但是 emms-info-native 默认标签数据不含有换行的，而歌词文件中是以换行分割不同时间的歌词的，如： [00:29.25]过完整个夏天 [00:34.74]忧伤并没有好一些 [00:41.18]开车行驶在公路无际无边 [00:47.32]有离开自己的感觉 [00:52.45] [00:53.34]唱不完一首歌 [00:59.37]疲倦还剩下黑眼圈 ... 因此还需要修改 emms-info-native 中，标签解析函数的正则表达式： (defun emms-info-native--split-vorbis-comment-multiline (comment) (let ((comment-string (decode-coding-string (mapconcat #'byte-to-string comment nil) 'utf-8))) (when (string-match \"^\\\\(.+?\\\\)=\\\\([\\0-\\377[:nonascii:]]*\\\\)\" comment-string) (cons (downcase (match-string 1 comment-string)) (match-string 2 comment-string))))) (advice-add #'emms-info-native--split-vorbis-comment :override #'emms-info-native--split-vorbis-comment-multiline) 现在内嵌歌词就可以被正确地载入至轨道信息中了，下面就可以扩展 emms-lyrics 中查找歌词文件的函数了： (defconst emms-info-lyrics-temp-file (make-temp-file \"emms-info-lyrics-\" nil \".lrc\")) (defun emms-lyrics-find-with-info-lyric (file) (if-let ((file (emms-lyrics-find-lyric file))) file (when-let ((embedded-lyric (emms-track-get (emms-playlist-current-selected-track) 'info-lyrics))) (with-temp-buffer (insert embedded-lyric) (write-region (point-min) (point-max) emms-info-lyrics-temp-file nil)) emms-info-lyrics-temp-file))) (setq emms-lyrics-find-lyric-function #'emms-lyrics-find-with-info-lyric) (add-hook 'kill-emacs-hook (lambda () (when (file-exists-p emms-info-lyrics-temp-file) (delete-file emms-info-lyrics-temp-file)))) 这里在临时目录创建了一个临时的歌词文件，写入当前播放曲目内嵌的歌词并作为 emms-lyrics-find-with-info-lyric 的返回值，可以通过 emms-lyrics-visit-lyric 进行访问。这样， EMMS 就可以像其他播放器那样加载内嵌歌词了，并且功能与加载一般歌词文件没有太大区别。 ","date":"2022-03-06","objectID":"/posts/blog/%E8%AE%A9-emms-%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BA%E9%9F%B3%E4%B9%90%E6%96%87%E4%BB%B6%E5%86%85%E5%B5%8C%E6%AD%8C%E8%AF%8D/:2:0","series":null,"tags":["EMMS","Emacs"],"title":"让 EMMS 读取并显示音乐文件内嵌歌词","uri":"/posts/blog/%E8%AE%A9-emms-%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%98%BE%E7%A4%BA%E9%9F%B3%E4%B9%90%E6%96%87%E4%BB%B6%E5%86%85%E5%B5%8C%E6%AD%8C%E8%AF%8D/#实现"},{"categories":null,"content":"序言 本人目前不是很经常使用电子邮件，一个简单的邮件客户端用于在不打开浏览器的情况下查看邮件文本内容就够用了，想到 Emacs 上可以使用 mu4e 来收发邮件，今天尝试自己配置的过程中，无意中发现了 mu-wizard 这个脚本，可以很方便地完成 mu4e 的配置。 ","date":"2022-03-05","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/:1:0","series":null,"tags":["org-mode","Emacs"],"title":"使用 mu-wizard 配置 mu4e 邮件客户端","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/#序言"},{"categories":null,"content":"步骤 ","date":"2022-03-05","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/:2:0","series":null,"tags":["org-mode","Emacs"],"title":"使用 mu-wizard 配置 mu4e 邮件客户端","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/#步骤"},{"categories":null,"content":"安装 mu-wizard Arch 系的发行版在 AUR 中找到 mu-wizard-git 这个包安装即可： 其余的发行安装好依赖后 make install 也是可以的。 ","date":"2022-03-05","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/:2:1","series":null,"tags":["org-mode","Emacs"],"title":"使用 mu-wizard 配置 mu4e 邮件客户端","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/#安装-mu-wizard"},{"categories":null,"content":"配置密码存储 先生成 GPG 密钥，这一步会提示输入姓名、邮箱与密码： gpg --gen-key 然后使用 pass 命令初始化密码储存，邮箱需要与刚才输入的一致： pass init 1281299809@qq.com ","date":"2022-03-05","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/:2:2","series":null,"tags":["org-mode","Emacs"],"title":"使用 mu-wizard 配置 mu4e 邮件客户端","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/#配置密码存储"},{"categories":null,"content":"配置邮箱 接着使用 muw 命令添加邮箱地址（这里以 QQ 邮箱为例）： muw add -a \"1281299809@qq.com\" 对于 QQ 邮箱而言需要确保 IMAP/SMTP 服务已经开启，并两次输入授权码： 最终得到如下输出： Your domain information was found!' The following information will be used: Domain: qq.com IMAP: imap.qq.com:993 SMTP: smtp.qq.com:587 Enter your full name you want to be identified on this account. Real name: 1281299809@qq.com Enter a short, one-word identifier for this email account that will distinguish them from any other accounts you add Account name: qq If your account has a special username different from your address, insert it now. Otherwise leave this blank. Login: 1281299809 mkdir: 已创建目录 '/home/coco24/.password-store/muw' Enter password for muw/1281299809@qq.com: Retype password for muw/1281299809@qq.com: All done. You can now run 'muw sync qq' in order to sync this account. 在运行 muw sync 之前，需要先执行 muw mu-init 刷新缓存，否则会出现文件缺失的错误： muw mu-init maildir : /home/coco24/.local/share/mail database-path : /home/coco24/.cache/mu/xapian schema-version : 452 max-message-size : 100000000 batch-size : 250000 messages in store : 0 created : 2022年03月05日 星期六 19时15分22秒 personal-address : 1281299809@qq.com 最后执行（这里的 qq 是之前设置的 Account Name）： muw sync qq 如果没有出现错误，那么邮箱就配置完成了。 ","date":"2022-03-05","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/:2:3","series":null,"tags":["org-mode","Emacs"],"title":"使用 mu-wizard 配置 mu4e 邮件客户端","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/#配置邮箱"},{"categories":null,"content":"配置 mu4e 作者给出了一个短短几行的 mu4e-config.el 文件，个人觉得没有必要单独弄成一个文件加载，这里给出 use-package 配置范例： (use-package mu4e :when (and (boundp 'use-mu4e) use-mu4e) :defer t :commands (mu4e) :config (setq mu4e-get-mail-command \"mbsync -a\" mail-user-agent 'mu4e-user-agent message-send-mail-function 'message-send-mail-with-sendmail sendmail-program (executable-find \"msmtp\")) (setq mu4e-contexts nil) (dolist (file (directory-files (expand-file-name \"mu4e/accounts\" (or (getenv \"XDG_CONFIG_HOME\") \"~/.config\")) t \"\\\\.el$\" nil)) (load file))) 需要注意的是 mu4e 无法使用 ELPA 安装，它是随着系统的包管理器安装 mu 时一起被安装进 Emacs 的 load-path 中的，因此为了保证配置文件的通用性，我使用 use-mu4e 这个变量控制 mu4e 的加载。然后在 Emacs 中运行： M-x mu4e 就可以使用配置好的 mu4e 了。 ","date":"2022-03-05","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/:2:4","series":null,"tags":["org-mode","Emacs"],"title":"使用 mu-wizard 配置 mu4e 邮件客户端","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-mu-wizard-%E9%85%8D%E7%BD%AE-mu4e-%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/#配置-mu4e"},{"categories":null,"content":"序言 最近学校查看近期的课程很不方便，干脆就直接用 org-mode 来录入学校的课程表，然后用 org-agenda 来进行显示和时间规划，顺便分享一下自己的一点经验。 ","date":"2022-03-03","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/:1:0","series":null,"tags":["org-mode","Emacs"],"title":"使用 Org-agenda 实现课程表","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/#序言"},{"categories":null,"content":"问题 录入课程表主要面临有几个问题： 学校课程的日期安排，不是以日期的形式来安排的，而是以开学以来的周数+周几来表示的，如果录入时手动换算会比较麻烦。 学校课程的安排比较灵活，很多课是以周数的区间形式来安排的，比如 1~14,15,17~18周，并且有可能出现单双周，我希望能以类似的格式直接进行录入。 学校每天课程时间安排比较固定，比如每天的第一节课就固定是 8:00~9:35 ，重复地输入这个时间段显然是比较繁琐的。 ","date":"2022-03-03","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/:2:0","series":null,"tags":["org-mode","Emacs"],"title":"使用 Org-agenda 实现课程表","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/#问题"},{"categories":null,"content":"解决方案 ","date":"2022-03-03","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/:3:0","series":null,"tags":["org-mode","Emacs"],"title":"使用 Org-agenda 实现课程表","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/#解决方案"},{"categories":null,"content":"自定义时间戳 折腾了一段时间，下面给出解决方案：首先是针对第1点和第2点，使用S-表达式时间戳，然后在里面调用自己写的 Elisp 函数即可： (require 'cal-iso) (defconst school-term-start-date '(9 6 2021)) ;定义开学周 (defun iso-week-to-date (week day year) \"从ISO时间标准周转换为日期\" (calendar-gregorian-from-absolute (calendar-iso-to-absolute (list week day year)))) (defun iso-week-from-date (month day year) \"从日期转换为ISO时间标准周\" (calendar-iso-from-absolute (calendar-absolute-from-gregorian (list month day year)))) (defun school-week-to-date (week day) \"把学期开始的周数和周几转换为日期\" (let ((week (+ (nth 0 (iso-week-from-date school-term-start-date)) week -1))) (iso-week-to-date (list week day (calendar-extract-year school-term-start-date))))) (defun school-class (weeks day) \"输入周数和周几，并判断和org-agenda当前检索的日期是否匹配\" (let (ret) (setq ret (or ret (pcase weeks ((pred integerp) (let* ((date1 (school-week-to-date week day))) (and (equal date date1) entry))) ((and (pred proper-list-p) list) (dolist (week weeks ret) (setq ret (or ret (school-class week day))))) (`((,from-week . ,to-week) . ,odd-or-even) (school-class (-filter (lambda (x) (= (% x 2) (pcase odd-or-even ('odd 1) ('even 0)))) (number-sequence from-week to-week)) day)) (`(,from-week . ,to-week) (let* ((date1 (school-week-to-date from-week day)) (date2 (school-week-to-date to-week day)) (year1 (calendar-extract-year date1)) (month1 (calendar-extract-month date1)) (day1 (calendar-extract-day date1)) (year2 (calendar-extract-year date2)) (month2 (calendar-extract-month date2)) (day2 (calendar-extract-day date2))) (org-class year1 month1 day1 year2 month2 day2 day)))))) ret)) 接着就可以在 org-agenda-files 中使用了： * 数字电路与逻辑设计 :PROPERTIES: :CATEGORY: 数字电路与逻辑设计 方怡冰 :END: ** 10:05-11:40 禹州406 \u003c%%(school-class '(((1 . 12) . even) (14 . 16)) 1)\u003e ** 10:05-11:40 美岭314 \u003c%%(school-class '(((1 . 12) . odd) (14 . 16)) 4)\u003e school-class 这个函数接受一个列表和整数，列表里面可以是整数或者是一个表示周范围（可以指定单双周）的二元组，第二个整数参数表明是周几，第一个和第二个问题解决。 ","date":"2022-03-03","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/:3:1","series":null,"tags":["org-mode","Emacs"],"title":"使用 Org-agenda 实现课程表","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/#自定义时间戳"},{"categories":null,"content":"自定义时间段显示 对于第三个问题，也就是时间段的输入问题，我个人是使用 org-mode 的宏替换来解决。但是宏替换仅在导出时进行，而在 Org Agenda View 中是不会进行宏替换的，所以要通过修改 org-agenda-get-day-entries 函数，实现先对 org-agenda-files 的 buffer 进行宏替换，再从 buffer 中获取对应的 entries ，最后再撤销宏替换（这里直接使用 undo 来实现）： (defun org-agenda-get-day-entries (file date \u0026rest args) \"Does the work for `org-diary' and `org-agenda'. FILE is the path to a file to be checked for entries. DATE is date like the one returned by `calendar-current-date'. ARGS are symbols indicating which kind of entries should be extracted. For details about these, see the documentation of `org-diary'.\" (let* ((org-startup-folded nil) (org-startup-align-all-tables nil) (buffer (if (file-exists-p file) (org-get-agenda-file-buffer file) (error \"No such file %s\" file)))) (if (not buffer) ;; If file does not exist, signal it in diary nonetheless. (list (format \"ORG-AGENDA-ERROR: No such org-file %s\" file)) (with-current-buffer buffer (unless (derived-mode-p 'org-mode) (error \"Agenda file %s is not in Org mode\" file)) (setq org-agenda-buffer (or org-agenda-buffer buffer)) (setf org-agenda-current-date date) (undo-boundary) (org-macro-replace-all org-macro-templates) (let ((ret (save-excursion (save-restriction (if (eq buffer org-agenda-restrict) (narrow-to-region org-agenda-restrict-begin org-agenda-restrict-end) (widen)) ;; Rationalize ARGS. Also make sure `:deadline' comes ;; first in order to populate DEADLINES before passing it. ;; ;; We use `delq' since `org-uniquify' duplicates ARGS, ;; guarding us from modifying `org-agenda-entry-types'. (setf args (org-uniquify (or args org-agenda-entry-types))) (when (and (memq :scheduled args) (memq :scheduled* args)) (setf args (delq :scheduled* args))) (cond ((memq :deadline args) (setf args (cons :deadline (delq :deadline (delq :deadline* args))))) ((memq :deadline* args) (setf args (cons :deadline* (delq :deadline* args))))) ;; Collect list of headlines. Return them flattened. (let ((case-fold-search nil) results deadlines) (org-dlet ((date date)) (dolist (arg args (apply #'nconc (nreverse results))) (pcase arg ((and :todo (guard (org-agenda-today-p date))) (push (org-agenda-get-todos) results)) (:timestamp (push (org-agenda-get-blocks) results) (push (org-agenda-get-timestamps deadlines) results)) (:sexp (push (org-agenda-get-sexps) results)) (:scheduled (push (org-agenda-get-scheduled deadlines) results)) (:scheduled* (push (org-agenda-get-scheduled deadlines t) results)) (:closed (push (org-agenda-get-progress) results)) (:deadline (setf deadlines (org-agenda-get-deadlines)) (push deadlines results)) (:deadline* (setf deadlines (org-agenda-get-deadlines t)) (push deadlines results)))))))))) (primitive-undo 1 buffer-undo-list) ret))))) 然后就可以在课程表的 agenda 文件中定义一个 MACRO ： #+MACRO: school-time (eval (concat (cdr (assoc (string-to-number $1) school-time-periods)) \"（\" (cdr (assoc (string-to-number $1) school-time-class-nums)) \"）\")) 其中的 school-time-class-nums 和 school-time-periods 如下： (defconst school-time-class-nums '((1 . \"上午1、2节\") (2 . \"上午3、4节\") (3 . \"下午5、6节\") (4 . \"下午7、8节\") (5 . \"晚上9、10节\"))) (defconst school-time-periods '((1 . \"8:00-9:35\") (2 . \"10:05-11:40\") (3 . \"14:00-15:35\") (4 . \"15:55-17:30\") (5 . \"19:00-21:30\"))) 然后就可以愉快地将时间段用宏来代替了： ** {{{school-time(2)}}} 禹州406 \u003c%%(school-class '(((1 . 12) . even) (14 . 16)) 1)\u003e ** {{{school-time(2)}}} 美岭314 \u003c%%(school-class '(((1 . 12) . odd) (14 . 16)) 4)\u003e 虽然看上去字数反而变多了，但是每次输入只要进行复制粘贴后只更改一个数即可了，并且格式可以统一修改，最终效果如下： Thursday 3 March 2022 数学建模 畅航: 8:00-9:35 （上午1、2节） 章辉301 8:00...... ---------------- 10:00...... ---------------- 微机原理与接口技术 秦德兴:10:05-11:40 （上午3、4节） 美岭407 12:00...... ---------------- 13:57...... now - - - - - - - - - - - - - - - - - - - - - - - - - 信号与系统 冯文:14:00-15:35 （下午5、6节） 禹州205 14:00...... ---------------- 16:00...... ---------------- 18:00...... ---------------- 概率论与数理统计 王凤筵:19:00-21:30 （晚上9、10节） 建发315 20:00...... ---------------- ","date":"2022-03-03","objectID":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/:3:2","series":null,"tags":["org-mode","Emacs"],"title":"使用 Org-agenda 实现课程表","uri":"/posts/blog/%E4%BD%BF%E7%94%A8-org-agenda-%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E8%A1%A8/#自定义时间段显示"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:0:0","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#"},{"categories":null,"content":"数字逻辑 flowchart LR A[波形图] B[真值表] C[逻辑表达式] D[逻辑图] E[卡诺图] A \u003c--\u003e B B \u003c--\u003e C C \u003c--\u003e D B \u003c--\u003e E E \u003c--\u003e C ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#数字逻辑"},{"categories":null,"content":"机器码 原码 正数的符号位用“0”表示，负数的符号位用“1”，数值部分按二进制数的绝对值表示。 范围 有一位专门用于表示符号，意味着 0 将有两种表示方式： 00000000 和 10000000 ，因此范围上下限的绝对值是相同的。 运算 符号位不参与计算。 反码 使用最高位来表示正负，但在表示负数时，其余位在原码的基础上取反。 补码 正数的补码就是与原码相同，负数的补码为模减去该数的绝对值。因此对于同一个数不同的模（即不同的计算机位数），其补码是不同。 范围 当一个正数与一个负数的补码相同时，负数优先，这样最高位可以表示正负： 100 (4) 011 3 000 0 111 -1 ... 100 -4 因此补码的表示范围为\\([-2^{n-1},2^{n-1}-1]\\)。 运算 加减 在不溢出的情况下，加减法不用管符号位。 相反数 两种方法都可以： 其余位减去1再取反 其余位取反后加上1 例 0000 取相反数的过程为： 0000 -\u003e 1000 -\u003e 1111 -\u003e 0000 。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:1","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#机器码"},{"categories":null,"content":"机器码 原码 正数的符号位用“0”表示，负数的符号位用“1”，数值部分按二进制数的绝对值表示。 范围 有一位专门用于表示符号，意味着 0 将有两种表示方式： 00000000 和 10000000 ，因此范围上下限的绝对值是相同的。 运算 符号位不参与计算。 反码 使用最高位来表示正负，但在表示负数时，其余位在原码的基础上取反。 补码 正数的补码就是与原码相同，负数的补码为模减去该数的绝对值。因此对于同一个数不同的模（即不同的计算机位数），其补码是不同。 范围 当一个正数与一个负数的补码相同时，负数优先，这样最高位可以表示正负： 100 (4) 011 3 000 0 111 -1 ... 100 -4 因此补码的表示范围为\\([-2^{n-1},2^{n-1}-1]\\)。 运算 加减 在不溢出的情况下，加减法不用管符号位。 相反数 两种方法都可以： 其余位减去1再取反 其余位取反后加上1 例 0000 取相反数的过程为： 0000 -\u003e 1000 -\u003e 1111 -\u003e 0000 。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:1","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#原码"},{"categories":null,"content":"机器码 原码 正数的符号位用“0”表示，负数的符号位用“1”，数值部分按二进制数的绝对值表示。 范围 有一位专门用于表示符号，意味着 0 将有两种表示方式： 00000000 和 10000000 ，因此范围上下限的绝对值是相同的。 运算 符号位不参与计算。 反码 使用最高位来表示正负，但在表示负数时，其余位在原码的基础上取反。 补码 正数的补码就是与原码相同，负数的补码为模减去该数的绝对值。因此对于同一个数不同的模（即不同的计算机位数），其补码是不同。 范围 当一个正数与一个负数的补码相同时，负数优先，这样最高位可以表示正负： 100 (4) 011 3 000 0 111 -1 ... 100 -4 因此补码的表示范围为\\([-2^{n-1},2^{n-1}-1]\\)。 运算 加减 在不溢出的情况下，加减法不用管符号位。 相反数 两种方法都可以： 其余位减去1再取反 其余位取反后加上1 例 0000 取相反数的过程为： 0000 -\u003e 1000 -\u003e 1111 -\u003e 0000 。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:1","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#反码"},{"categories":null,"content":"机器码 原码 正数的符号位用“0”表示，负数的符号位用“1”，数值部分按二进制数的绝对值表示。 范围 有一位专门用于表示符号，意味着 0 将有两种表示方式： 00000000 和 10000000 ，因此范围上下限的绝对值是相同的。 运算 符号位不参与计算。 反码 使用最高位来表示正负，但在表示负数时，其余位在原码的基础上取反。 补码 正数的补码就是与原码相同，负数的补码为模减去该数的绝对值。因此对于同一个数不同的模（即不同的计算机位数），其补码是不同。 范围 当一个正数与一个负数的补码相同时，负数优先，这样最高位可以表示正负： 100 (4) 011 3 000 0 111 -1 ... 100 -4 因此补码的表示范围为\\([-2^{n-1},2^{n-1}-1]\\)。 运算 加减 在不溢出的情况下，加减法不用管符号位。 相反数 两种方法都可以： 其余位减去1再取反 其余位取反后加上1 例 0000 取相反数的过程为： 0000 -\u003e 1000 -\u003e 1111 -\u003e 0000 。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:1","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#补码"},{"categories":null,"content":"真值表 implicit class boolOps(a: Boolean) { def +(b: Boolean) = a || b def *(b: Boolean) = a \u0026\u0026 b def unary_- = !a } @main def main() = { def rec(vec: Vector[Boolean] = Vector.empty, i: Int = 0): Unit = if(i \u003c 3) { rec(vec :+ false, i + 1) rec(vec :+ true, i + 1) } else vec match { case Vector(a, b, c) =\u003e val res = -a + a * c + -b def booleanToNumString(b: Boolean) = b match { case true =\u003e \"1\" case false =\u003e \"0\" } println(s\"${vec.map(booleanToNumString).mkString(\" \")} ${booleanToNumString(res)}\") } rec() } ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#真值表"},{"categories":null,"content":"逻辑运算 运算规律 公式（与） 公式（或） 0-1律 自等律 重叠律 互补律 交换律 结合律 分配律 还原律 反演律 \\(\\overline{AB}=\\overline A+\\overline B\\) \\(\\overline{A+B}=\\overline A\\cdot\\overline B\\) 与 用 \\(\\times\\) 或 \\(\\cdot\\) 表示。 或 用 \\(+\\) 表示。 非 用 \\(\\overline{\\boxed{}}\\) 表示。 同或 用 \\(\\textcircled{$\\cdot$}\\) 表示。 异或 用 \\(\\textcircled+\\) 表示。异或可用于可控的取反： \\(a\\textcircled+1=\\bar a\\) \\(a\\textcircled+0=a\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#逻辑运算"},{"categories":null,"content":"逻辑运算 运算规律 公式（与） 公式（或） 0-1律 自等律 重叠律 互补律 交换律 结合律 分配律 还原律 反演律 \\(\\overline{AB}=\\overline A+\\overline B\\) \\(\\overline{A+B}=\\overline A\\cdot\\overline B\\) 与 用 \\(\\times\\) 或 \\(\\cdot\\) 表示。 或 用 \\(+\\) 表示。 非 用 \\(\\overline{\\boxed{}}\\) 表示。 同或 用 \\(\\textcircled{$\\cdot$}\\) 表示。 异或 用 \\(\\textcircled+\\) 表示。异或可用于可控的取反： \\(a\\textcircled+1=\\bar a\\) \\(a\\textcircled+0=a\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#与"},{"categories":null,"content":"逻辑运算 运算规律 公式（与） 公式（或） 0-1律 自等律 重叠律 互补律 交换律 结合律 分配律 还原律 反演律 \\(\\overline{AB}=\\overline A+\\overline B\\) \\(\\overline{A+B}=\\overline A\\cdot\\overline B\\) 与 用 \\(\\times\\) 或 \\(\\cdot\\) 表示。 或 用 \\(+\\) 表示。 非 用 \\(\\overline{\\boxed{}}\\) 表示。 同或 用 \\(\\textcircled{$\\cdot$}\\) 表示。 异或 用 \\(\\textcircled+\\) 表示。异或可用于可控的取反： \\(a\\textcircled+1=\\bar a\\) \\(a\\textcircled+0=a\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#或"},{"categories":null,"content":"逻辑运算 运算规律 公式（与） 公式（或） 0-1律 自等律 重叠律 互补律 交换律 结合律 分配律 还原律 反演律 \\(\\overline{AB}=\\overline A+\\overline B\\) \\(\\overline{A+B}=\\overline A\\cdot\\overline B\\) 与 用 \\(\\times\\) 或 \\(\\cdot\\) 表示。 或 用 \\(+\\) 表示。 非 用 \\(\\overline{\\boxed{}}\\) 表示。 同或 用 \\(\\textcircled{$\\cdot$}\\) 表示。 异或 用 \\(\\textcircled+\\) 表示。异或可用于可控的取反： \\(a\\textcircled+1=\\bar a\\) \\(a\\textcircled+0=a\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#非"},{"categories":null,"content":"逻辑运算 运算规律 公式（与） 公式（或） 0-1律 自等律 重叠律 互补律 交换律 结合律 分配律 还原律 反演律 \\(\\overline{AB}=\\overline A+\\overline B\\) \\(\\overline{A+B}=\\overline A\\cdot\\overline B\\) 与 用 \\(\\times\\) 或 \\(\\cdot\\) 表示。 或 用 \\(+\\) 表示。 非 用 \\(\\overline{\\boxed{}}\\) 表示。 同或 用 \\(\\textcircled{$\\cdot$}\\) 表示。 异或 用 \\(\\textcircled+\\) 表示。异或可用于可控的取反： \\(a\\textcircled+1=\\bar a\\) \\(a\\textcircled+0=a\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#同或"},{"categories":null,"content":"逻辑运算 运算规律 公式（与） 公式（或） 0-1律 自等律 重叠律 互补律 交换律 结合律 分配律 还原律 反演律 \\(\\overline{AB}=\\overline A+\\overline B\\) \\(\\overline{A+B}=\\overline A\\cdot\\overline B\\) 与 用 \\(\\times\\) 或 \\(\\cdot\\) 表示。 或 用 \\(+\\) 表示。 非 用 \\(\\overline{\\boxed{}}\\) 表示。 同或 用 \\(\\textcircled{$\\cdot$}\\) 表示。 异或 用 \\(\\textcircled+\\) 表示。异或可用于可控的取反： \\(a\\textcircled+1=\\bar a\\) \\(a\\textcircled+0=a\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#异或"},{"categories":null,"content":"逻辑表达式 与或式 \\[F=AB+CD\\] 或与式 \\[F=(A+C)(A+D)(B+C)(B+D)\\] 与非-与非式 \\[F=\\overline{\\overline{AB}\\cdot\\overline{CD}}\\] 或非-或非式 \\[F=\\overline{\\overline{A+C}+\\overline{A+D}+\\overline{B+C}+\\overline{B+D}}\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#逻辑表达式"},{"categories":null,"content":"逻辑表达式 与或式 \\[F=AB+CD\\] 或与式 \\[F=(A+C)(A+D)(B+C)(B+D)\\] 与非-与非式 \\[F=\\overline{\\overline{AB}\\cdot\\overline{CD}}\\] 或非-或非式 \\[F=\\overline{\\overline{A+C}+\\overline{A+D}+\\overline{B+C}+\\overline{B+D}}\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#与或式"},{"categories":null,"content":"逻辑表达式 与或式 \\[F=AB+CD\\] 或与式 \\[F=(A+C)(A+D)(B+C)(B+D)\\] 与非-与非式 \\[F=\\overline{\\overline{AB}\\cdot\\overline{CD}}\\] 或非-或非式 \\[F=\\overline{\\overline{A+C}+\\overline{A+D}+\\overline{B+C}+\\overline{B+D}}\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#或与式"},{"categories":null,"content":"逻辑表达式 与或式 \\[F=AB+CD\\] 或与式 \\[F=(A+C)(A+D)(B+C)(B+D)\\] 与非-与非式 \\[F=\\overline{\\overline{AB}\\cdot\\overline{CD}}\\] 或非-或非式 \\[F=\\overline{\\overline{A+C}+\\overline{A+D}+\\overline{B+C}+\\overline{B+D}}\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#与非-与非式"},{"categories":null,"content":"逻辑表达式 与或式 \\[F=AB+CD\\] 或与式 \\[F=(A+C)(A+D)(B+C)(B+D)\\] 与非-与非式 \\[F=\\overline{\\overline{AB}\\cdot\\overline{CD}}\\] 或非-或非式 \\[F=\\overline{\\overline{A+C}+\\overline{A+D}+\\overline{B+C}+\\overline{B+D}}\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#或非-或非式"},{"categories":null,"content":"逻辑函数 注意：一个逻辑函数只能表示多个逻辑（输入）和一个逻辑（输出）的关系，如果要表示多个逻辑与多个逻辑的关系，对于每一个输出逻辑，都需要列一个逻辑表达式。 逻辑函数展开式 最小项表达式 \\[\\begin{aligned} \u0026f(A, B, C) \\\\ =\u0026A \\cdot f(1, B, C)+\\bar{A} \\cdot f(0, B, C) \\\\ =\u0026A B f(1,1, C)+A \\bar{B} f(1,0, C)+\\bar{A} B f(0.1, C)+\\bar{A} \\bar{B} f(0.0, C) \\\\ =\u0026A B C f(1,1,1)+A B \\bar{C} f(1,1,0)+A \\bar{B} C f(1,0,1)+A \\bar{B} \\bar{C} f(1,0,0) \\\\ \u0026+\\bar{A} B C f(0.1,1)+\\bar{A} B \\bar{C} f(0.1,0)+\\bar{A} \\bar{B} C f(0,0.1)+\\bar{A} \\bar{B} \\bar{C} f(0,0,0) \\end{aligned}\\] 其中 \\(f(\\dots)\\) 代表对于一组输入的输出情况。对于为0的输入要取反，是为了确保整个项是有意义的。像这样把每一项都写出来的叫做标准与或式（最小项表达式）。只留下有意义的项（舍去已知为0的项），得到与或式： \\[\\begin{aligned} L 1\u0026=\\bar{A} \\bar{B} \\bar{C} \\cdot 0+\\bar{A} \\bar{B} C \\cdot 0+\\bar{A} B \\bar{C} \\cdot 0+\\bar{A} B C \\cdot 1+A \\bar{B} \\bar{C} \\cdot 0+A \\bar{B} C \\cdot 1+A B \\bar{C} \\cdot 1+A B C \\cdot 1 \\\\ \u0026=\\bar{A} B C+A \\bar{B} C+A B \\bar{C}+A B C\\\\ \u0026=\\mathrm{m}_{3}+m_{5}+m_{6}+m_{7}=\\sum m(3,5,6,7) \\end{aligned}\\] 其中\\(m\\)代表最小项的意思。 最大项表达式 用于表示负逻辑，基本就是最小项表达式的对偶（\\(\\cdot\\)与\\(+\\)互换），标准或与式（最大项表达式）的定义也可以参考最小项表达式。： \\[\\begin{aligned} L 1\u0026=(A+B+C+f(0,0,0)) \\cdot(A+B+\\bar{C}+\\mathrm{f}(0,0,1)) \\cdot(A+\\bar{B}+C+\\mathrm{f}(0,1,0)) \\cdot A+\\bar{B}+\\bar{C}+\\mathrm{f}(0,1,1)) \\cdot(\\bar{A}+B+C+\\mathrm{f}(1,0,0)) \\cdot(\\bar{A}+B+\\bar{C}+\\mathrm{f}(1,0,1)) \\cdot(\\bar{A}+\\bar{B}+C+\\mathrm{f}(1,1,0)) \\cdot(\\bar{A}+\\bar{B}+\\bar{C}+\\mathrm{f}(1,1,1))\\\\ \u0026=(A+B+C+0) \\cdot(A+B+\\bar{C}+0) \\cdot(A+\\bar{B}+C+0) \\cdot A+\\bar{B}+\\bar{C}+1) \\cdot(\\bar{A}+B+C+0) \\cdot(\\bar{A}+B+\\bar{C}+1) \\cdot(\\bar{A}+\\bar{B}+C+1) \\cdot(\\bar{A}+\\bar{B}+\\bar{C}+1)\\\\ \u0026=(A+B+C) \\cdot(A+B+\\bar{C}) \\cdot(A+\\bar{B}+C) \\cdot(\\bar{A}+B+C)\\\\ \u0026=M_{0} \\cdot M_{1} \\cdot M_{2} \\cdot M_{4}=\\prod M(0,1,2,4) \\end{aligned}\\] 其中\\(M\\)代表最大项的意思。 不完全确定的逻辑函数 有时候对于可能的输入的数量小于其对于二进制可表示的数量时，多出来的输入就是不需要考虑的。比如BCD 码的处理电路就存在6个不可能的输入（伪码），如果真的产生了这些输入，输出值可以不一定是假，而是可以任意，这样可以简化电路。对于不可能的输入，可以在卡诺图中用“d”来表示，在画圈时既可以当作”1“，又可以当作”0“，目的是让圈画得更大更多： 注意：”d“不能单独成圈，一个圈中至少要有1个”1“。 最小项表达式可以写成这样： \\[F(A, B, C, D)=\\sum m(0, 3, 5, 6, 9)+\\sum d(10, 11, 12, 13, 14, 15)\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:5","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#逻辑函数"},{"categories":null,"content":"逻辑函数 注意：一个逻辑函数只能表示多个逻辑（输入）和一个逻辑（输出）的关系，如果要表示多个逻辑与多个逻辑的关系，对于每一个输出逻辑，都需要列一个逻辑表达式。 逻辑函数展开式 最小项表达式 \\[\\begin{aligned} \u0026f(A, B, C) \\\\ =\u0026A \\cdot f(1, B, C)+\\bar{A} \\cdot f(0, B, C) \\\\ =\u0026A B f(1,1, C)+A \\bar{B} f(1,0, C)+\\bar{A} B f(0.1, C)+\\bar{A} \\bar{B} f(0.0, C) \\\\ =\u0026A B C f(1,1,1)+A B \\bar{C} f(1,1,0)+A \\bar{B} C f(1,0,1)+A \\bar{B} \\bar{C} f(1,0,0) \\\\ \u0026+\\bar{A} B C f(0.1,1)+\\bar{A} B \\bar{C} f(0.1,0)+\\bar{A} \\bar{B} C f(0,0.1)+\\bar{A} \\bar{B} \\bar{C} f(0,0,0) \\end{aligned}\\] 其中 \\(f(\\dots)\\) 代表对于一组输入的输出情况。对于为0的输入要取反，是为了确保整个项是有意义的。像这样把每一项都写出来的叫做标准与或式（最小项表达式）。只留下有意义的项（舍去已知为0的项），得到与或式： \\[\\begin{aligned} L 1\u0026=\\bar{A} \\bar{B} \\bar{C} \\cdot 0+\\bar{A} \\bar{B} C \\cdot 0+\\bar{A} B \\bar{C} \\cdot 0+\\bar{A} B C \\cdot 1+A \\bar{B} \\bar{C} \\cdot 0+A \\bar{B} C \\cdot 1+A B \\bar{C} \\cdot 1+A B C \\cdot 1 \\\\ \u0026=\\bar{A} B C+A \\bar{B} C+A B \\bar{C}+A B C\\\\ \u0026=\\mathrm{m}_{3}+m_{5}+m_{6}+m_{7}=\\sum m(3,5,6,7) \\end{aligned}\\] 其中\\(m\\)代表最小项的意思。 最大项表达式 用于表示负逻辑，基本就是最小项表达式的对偶（\\(\\cdot\\)与\\(+\\)互换），标准或与式（最大项表达式）的定义也可以参考最小项表达式。： \\[\\begin{aligned} L 1\u0026=(A+B+C+f(0,0,0)) \\cdot(A+B+\\bar{C}+\\mathrm{f}(0,0,1)) \\cdot(A+\\bar{B}+C+\\mathrm{f}(0,1,0)) \\cdot A+\\bar{B}+\\bar{C}+\\mathrm{f}(0,1,1)) \\cdot(\\bar{A}+B+C+\\mathrm{f}(1,0,0)) \\cdot(\\bar{A}+B+\\bar{C}+\\mathrm{f}(1,0,1)) \\cdot(\\bar{A}+\\bar{B}+C+\\mathrm{f}(1,1,0)) \\cdot(\\bar{A}+\\bar{B}+\\bar{C}+\\mathrm{f}(1,1,1))\\\\ \u0026=(A+B+C+0) \\cdot(A+B+\\bar{C}+0) \\cdot(A+\\bar{B}+C+0) \\cdot A+\\bar{B}+\\bar{C}+1) \\cdot(\\bar{A}+B+C+0) \\cdot(\\bar{A}+B+\\bar{C}+1) \\cdot(\\bar{A}+\\bar{B}+C+1) \\cdot(\\bar{A}+\\bar{B}+\\bar{C}+1)\\\\ \u0026=(A+B+C) \\cdot(A+B+\\bar{C}) \\cdot(A+\\bar{B}+C) \\cdot(\\bar{A}+B+C)\\\\ \u0026=M_{0} \\cdot M_{1} \\cdot M_{2} \\cdot M_{4}=\\prod M(0,1,2,4) \\end{aligned}\\] 其中\\(M\\)代表最大项的意思。 不完全确定的逻辑函数 有时候对于可能的输入的数量小于其对于二进制可表示的数量时，多出来的输入就是不需要考虑的。比如BCD 码的处理电路就存在6个不可能的输入（伪码），如果真的产生了这些输入，输出值可以不一定是假，而是可以任意，这样可以简化电路。对于不可能的输入，可以在卡诺图中用“d”来表示，在画圈时既可以当作”1“，又可以当作”0“，目的是让圈画得更大更多： 注意：”d“不能单独成圈，一个圈中至少要有1个”1“。 最小项表达式可以写成这样： \\[F(A, B, C, D)=\\sum m(0, 3, 5, 6, 9)+\\sum d(10, 11, 12, 13, 14, 15)\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:5","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#逻辑函数展开式"},{"categories":null,"content":"逻辑函数 注意：一个逻辑函数只能表示多个逻辑（输入）和一个逻辑（输出）的关系，如果要表示多个逻辑与多个逻辑的关系，对于每一个输出逻辑，都需要列一个逻辑表达式。 逻辑函数展开式 最小项表达式 \\[\\begin{aligned} \u0026f(A, B, C) \\\\ =\u0026A \\cdot f(1, B, C)+\\bar{A} \\cdot f(0, B, C) \\\\ =\u0026A B f(1,1, C)+A \\bar{B} f(1,0, C)+\\bar{A} B f(0.1, C)+\\bar{A} \\bar{B} f(0.0, C) \\\\ =\u0026A B C f(1,1,1)+A B \\bar{C} f(1,1,0)+A \\bar{B} C f(1,0,1)+A \\bar{B} \\bar{C} f(1,0,0) \\\\ \u0026+\\bar{A} B C f(0.1,1)+\\bar{A} B \\bar{C} f(0.1,0)+\\bar{A} \\bar{B} C f(0,0.1)+\\bar{A} \\bar{B} \\bar{C} f(0,0,0) \\end{aligned}\\] 其中 \\(f(\\dots)\\) 代表对于一组输入的输出情况。对于为0的输入要取反，是为了确保整个项是有意义的。像这样把每一项都写出来的叫做标准与或式（最小项表达式）。只留下有意义的项（舍去已知为0的项），得到与或式： \\[\\begin{aligned} L 1\u0026=\\bar{A} \\bar{B} \\bar{C} \\cdot 0+\\bar{A} \\bar{B} C \\cdot 0+\\bar{A} B \\bar{C} \\cdot 0+\\bar{A} B C \\cdot 1+A \\bar{B} \\bar{C} \\cdot 0+A \\bar{B} C \\cdot 1+A B \\bar{C} \\cdot 1+A B C \\cdot 1 \\\\ \u0026=\\bar{A} B C+A \\bar{B} C+A B \\bar{C}+A B C\\\\ \u0026=\\mathrm{m}_{3}+m_{5}+m_{6}+m_{7}=\\sum m(3,5,6,7) \\end{aligned}\\] 其中\\(m\\)代表最小项的意思。 最大项表达式 用于表示负逻辑，基本就是最小项表达式的对偶（\\(\\cdot\\)与\\(+\\)互换），标准或与式（最大项表达式）的定义也可以参考最小项表达式。： \\[\\begin{aligned} L 1\u0026=(A+B+C+f(0,0,0)) \\cdot(A+B+\\bar{C}+\\mathrm{f}(0,0,1)) \\cdot(A+\\bar{B}+C+\\mathrm{f}(0,1,0)) \\cdot A+\\bar{B}+\\bar{C}+\\mathrm{f}(0,1,1)) \\cdot(\\bar{A}+B+C+\\mathrm{f}(1,0,0)) \\cdot(\\bar{A}+B+\\bar{C}+\\mathrm{f}(1,0,1)) \\cdot(\\bar{A}+\\bar{B}+C+\\mathrm{f}(1,1,0)) \\cdot(\\bar{A}+\\bar{B}+\\bar{C}+\\mathrm{f}(1,1,1))\\\\ \u0026=(A+B+C+0) \\cdot(A+B+\\bar{C}+0) \\cdot(A+\\bar{B}+C+0) \\cdot A+\\bar{B}+\\bar{C}+1) \\cdot(\\bar{A}+B+C+0) \\cdot(\\bar{A}+B+\\bar{C}+1) \\cdot(\\bar{A}+\\bar{B}+C+1) \\cdot(\\bar{A}+\\bar{B}+\\bar{C}+1)\\\\ \u0026=(A+B+C) \\cdot(A+B+\\bar{C}) \\cdot(A+\\bar{B}+C) \\cdot(\\bar{A}+B+C)\\\\ \u0026=M_{0} \\cdot M_{1} \\cdot M_{2} \\cdot M_{4}=\\prod M(0,1,2,4) \\end{aligned}\\] 其中\\(M\\)代表最大项的意思。 不完全确定的逻辑函数 有时候对于可能的输入的数量小于其对于二进制可表示的数量时，多出来的输入就是不需要考虑的。比如BCD 码的处理电路就存在6个不可能的输入（伪码），如果真的产生了这些输入，输出值可以不一定是假，而是可以任意，这样可以简化电路。对于不可能的输入，可以在卡诺图中用“d”来表示，在画圈时既可以当作”1“，又可以当作”0“，目的是让圈画得更大更多： 注意：”d“不能单独成圈，一个圈中至少要有1个”1“。 最小项表达式可以写成这样： \\[F(A, B, C, D)=\\sum m(0, 3, 5, 6, 9)+\\sum d(10, 11, 12, 13, 14, 15)\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:5","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#不完全确定的逻辑函数"},{"categories":null,"content":"卡诺图 是一个表格。在列举逻辑的时候，表格的轴作为输入，表格填写的内容是输出。条件可能不止两个，导致表格的两个轴放不下，这时候要把输入分成两组，用格雷码来穷举每一组输入的所有可能。观察表格中1的特性：画圈时，里面的元素只能是偶数个，可以重叠。如果对“1”画圈，则得到与或式，对“0”画圈，得到或与式。 存在多个”对称“的”1“：使用与或式转化为与非门来表示。卡诺图在转换为与非式的时候，观察表格中所有1的输入组合，把它们组合内部相乘（因为一个组合中有一个输入为0就导致整个组合为0，所以对于为0的输入要取反），组合与组合之间相加。由于卡诺图使用了格雷码，可以观察如果有1是连续的，说明肯定有输入不影响最终的输出，在写式子的时候就可以直接把这个输入省略掉，就可以避免后续的化简。从图上可以最直观地去看圈起来的两个项，然后找输入的差别，把发生变化的去掉。注意：只能画含有\\(2^n\\)个元素的圈。 找对称： flowchart TD I[把当前位数所有可能的格雷码按顺序作为当前部分] A{当前部分是否可分} B[将当前部分中目标项镜像对称的项添加到列表] C[把当前部分分成两半并取含有目标项的那一半作为当前部分] D[列表中的项就是与目标项只差一位的项] I --\u003e A A --是--\u003e B B --\u003e C C --\u003e A A --否--\u003e D 以下两种相邻的必定对称： 位置上相邻 边缘扩展相邻：假设有这张卡诺图的上下左右都是这张卡诺图，看边缘上是否存在跨边缘的相邻”1“。 存在多个相间的相同输出：往往和1或0个数的奇偶性有关。和奇偶性有关要想到异或运算。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:6","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#卡诺图"},{"categories":null,"content":"数字编码 伪码 未使用的编码。 BCD 码 用二进制表示十进制的 每一位 数。 8421码 就相当于直接把0~9的数转换为二进制数，后面的6个数不用。8421码在进行加法运算时可以直接使用二进制加法，若结果落在伪码中说明运算后十进制没有进位，因此落在伪码中时需要手动加上6（有6个伪码），得到结果。若在16进制下出现进位，则也需要加上6。 5421码 最高位代表5，当数字大于5是最高位必须为1。好处是低3位有规律，可以复用功能。 2421码 从5开始，比原二进制多6，因此出现伪码时候需要加上6。由于是中间有6个数不用，一旦十六进制下发生进位一定意味着十进制下也发生进位。相加的结果肯定不可能出现在伪码区之后，只可能在伪码区中或在伪码区之前。如果是把十进制在十六进制中进行相加，必须保证在相加的过程中，最多只有6的余量。如果进位且出现在伪码区中，一定是两个在伪码区之后的2421码相加，已经多出12了，因此需要减6跳出伪码区。 口诀 有进位有伪码减6；无进位有伪码加6。 格雷码 门电路的运作和通过电子和空穴的运动产生的，门的跳变不可能同时发生。因此会产生竞争与冒险（产生了不应该有的干扰信号）。格雷码相邻的数字二进制只有一位跳变。通过n-1位的格雷码，通过逆序，就能得出n位格雷码。手写的时候可以这么写： 对于个位： 0110 0110 0110 ... 对于十位： 00111100 00111100 ... 对于百位： 000111111000 000111111000 ... 生成： @main def main(n: Int) = { def grayCodes(i: Int = n): List[List[Int]] = i match { case 0 =\u003e Nil :: Nil case _ =\u003e grayCodes(i - 1).map(0 :: _) ::: grayCodes(i - 1).reverse.map(1 :: _) } println(grayCodes().map(_.mkString).mkString(\"\\n\")) } (defun gray-codes (n) (pcase n (`0 '(())) (n (let ((codes (gray-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) (reverse codes))))))) (defun binary-codes (n) (pcase n (`1 '((0) (1))) (_ (let ((codes (binary-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) codes)))))) (defun binary-codes-to-strings (codes) (-map (lambda (code) (-reduce #'concat (-map #'number-to-string code))) codes)) (defun gray-code-strings-with-decimal (n) (--map (format \"%s%4s\" it (format \"(%d)\" (string-to-number it 2))) (binary-codes-to-strings (gray-codes n)))) (defun gray-code-table (rows columns) (-map-indexed (lambda (index row-str) (cons row-str (pcase index (`0 (gray-code-strings-with-decimal columns)) (i (-repeat columns \"\"))))) (cons \"\" (gray-code-strings-with-decimal rows)))) (gray-code-table 3 3) 余3格雷码 前面3组格雷码和后面3组格雷码进行丢弃。 与自然二进制码的相互转换 自然二进制码转格雷码 \\[G_n=B_n, G_i=B_{i+1}\\textcircled+ B_i\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:7","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#数字编码"},{"categories":null,"content":"数字编码 伪码 未使用的编码。 BCD 码 用二进制表示十进制的 每一位 数。 8421码 就相当于直接把0~9的数转换为二进制数，后面的6个数不用。8421码在进行加法运算时可以直接使用二进制加法，若结果落在伪码中说明运算后十进制没有进位，因此落在伪码中时需要手动加上6（有6个伪码），得到结果。若在16进制下出现进位，则也需要加上6。 5421码 最高位代表5，当数字大于5是最高位必须为1。好处是低3位有规律，可以复用功能。 2421码 从5开始，比原二进制多6，因此出现伪码时候需要加上6。由于是中间有6个数不用，一旦十六进制下发生进位一定意味着十进制下也发生进位。相加的结果肯定不可能出现在伪码区之后，只可能在伪码区中或在伪码区之前。如果是把十进制在十六进制中进行相加，必须保证在相加的过程中，最多只有6的余量。如果进位且出现在伪码区中，一定是两个在伪码区之后的2421码相加，已经多出12了，因此需要减6跳出伪码区。 口诀 有进位有伪码减6；无进位有伪码加6。 格雷码 门电路的运作和通过电子和空穴的运动产生的，门的跳变不可能同时发生。因此会产生竞争与冒险（产生了不应该有的干扰信号）。格雷码相邻的数字二进制只有一位跳变。通过n-1位的格雷码，通过逆序，就能得出n位格雷码。手写的时候可以这么写： 对于个位： 0110 0110 0110 ... 对于十位： 00111100 00111100 ... 对于百位： 000111111000 000111111000 ... 生成： @main def main(n: Int) = { def grayCodes(i: Int = n): List[List[Int]] = i match { case 0 =\u003e Nil :: Nil case _ =\u003e grayCodes(i - 1).map(0 :: _) ::: grayCodes(i - 1).reverse.map(1 :: _) } println(grayCodes().map(_.mkString).mkString(\"\\n\")) } (defun gray-codes (n) (pcase n (`0 '(())) (n (let ((codes (gray-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) (reverse codes))))))) (defun binary-codes (n) (pcase n (`1 '((0) (1))) (_ (let ((codes (binary-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) codes)))))) (defun binary-codes-to-strings (codes) (-map (lambda (code) (-reduce #'concat (-map #'number-to-string code))) codes)) (defun gray-code-strings-with-decimal (n) (--map (format \"%s%4s\" it (format \"(%d)\" (string-to-number it 2))) (binary-codes-to-strings (gray-codes n)))) (defun gray-code-table (rows columns) (-map-indexed (lambda (index row-str) (cons row-str (pcase index (`0 (gray-code-strings-with-decimal columns)) (i (-repeat columns \"\"))))) (cons \"\" (gray-code-strings-with-decimal rows)))) (gray-code-table 3 3) 余3格雷码 前面3组格雷码和后面3组格雷码进行丢弃。 与自然二进制码的相互转换 自然二进制码转格雷码 \\[G_n=B_n, G_i=B_{i+1}\\textcircled+ B_i\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:7","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#伪码"},{"categories":null,"content":"数字编码 伪码 未使用的编码。 BCD 码 用二进制表示十进制的 每一位 数。 8421码 就相当于直接把0~9的数转换为二进制数，后面的6个数不用。8421码在进行加法运算时可以直接使用二进制加法，若结果落在伪码中说明运算后十进制没有进位，因此落在伪码中时需要手动加上6（有6个伪码），得到结果。若在16进制下出现进位，则也需要加上6。 5421码 最高位代表5，当数字大于5是最高位必须为1。好处是低3位有规律，可以复用功能。 2421码 从5开始，比原二进制多6，因此出现伪码时候需要加上6。由于是中间有6个数不用，一旦十六进制下发生进位一定意味着十进制下也发生进位。相加的结果肯定不可能出现在伪码区之后，只可能在伪码区中或在伪码区之前。如果是把十进制在十六进制中进行相加，必须保证在相加的过程中，最多只有6的余量。如果进位且出现在伪码区中，一定是两个在伪码区之后的2421码相加，已经多出12了，因此需要减6跳出伪码区。 口诀 有进位有伪码减6；无进位有伪码加6。 格雷码 门电路的运作和通过电子和空穴的运动产生的，门的跳变不可能同时发生。因此会产生竞争与冒险（产生了不应该有的干扰信号）。格雷码相邻的数字二进制只有一位跳变。通过n-1位的格雷码，通过逆序，就能得出n位格雷码。手写的时候可以这么写： 对于个位： 0110 0110 0110 ... 对于十位： 00111100 00111100 ... 对于百位： 000111111000 000111111000 ... 生成： @main def main(n: Int) = { def grayCodes(i: Int = n): List[List[Int]] = i match { case 0 =\u003e Nil :: Nil case _ =\u003e grayCodes(i - 1).map(0 :: _) ::: grayCodes(i - 1).reverse.map(1 :: _) } println(grayCodes().map(_.mkString).mkString(\"\\n\")) } (defun gray-codes (n) (pcase n (`0 '(())) (n (let ((codes (gray-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) (reverse codes))))))) (defun binary-codes (n) (pcase n (`1 '((0) (1))) (_ (let ((codes (binary-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) codes)))))) (defun binary-codes-to-strings (codes) (-map (lambda (code) (-reduce #'concat (-map #'number-to-string code))) codes)) (defun gray-code-strings-with-decimal (n) (--map (format \"%s%4s\" it (format \"(%d)\" (string-to-number it 2))) (binary-codes-to-strings (gray-codes n)))) (defun gray-code-table (rows columns) (-map-indexed (lambda (index row-str) (cons row-str (pcase index (`0 (gray-code-strings-with-decimal columns)) (i (-repeat columns \"\"))))) (cons \"\" (gray-code-strings-with-decimal rows)))) (gray-code-table 3 3) 余3格雷码 前面3组格雷码和后面3组格雷码进行丢弃。 与自然二进制码的相互转换 自然二进制码转格雷码 \\[G_n=B_n, G_i=B_{i+1}\\textcircled+ B_i\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:7","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#bcd-码"},{"categories":null,"content":"数字编码 伪码 未使用的编码。 BCD 码 用二进制表示十进制的 每一位 数。 8421码 就相当于直接把0~9的数转换为二进制数，后面的6个数不用。8421码在进行加法运算时可以直接使用二进制加法，若结果落在伪码中说明运算后十进制没有进位，因此落在伪码中时需要手动加上6（有6个伪码），得到结果。若在16进制下出现进位，则也需要加上6。 5421码 最高位代表5，当数字大于5是最高位必须为1。好处是低3位有规律，可以复用功能。 2421码 从5开始，比原二进制多6，因此出现伪码时候需要加上6。由于是中间有6个数不用，一旦十六进制下发生进位一定意味着十进制下也发生进位。相加的结果肯定不可能出现在伪码区之后，只可能在伪码区中或在伪码区之前。如果是把十进制在十六进制中进行相加，必须保证在相加的过程中，最多只有6的余量。如果进位且出现在伪码区中，一定是两个在伪码区之后的2421码相加，已经多出12了，因此需要减6跳出伪码区。 口诀 有进位有伪码减6；无进位有伪码加6。 格雷码 门电路的运作和通过电子和空穴的运动产生的，门的跳变不可能同时发生。因此会产生竞争与冒险（产生了不应该有的干扰信号）。格雷码相邻的数字二进制只有一位跳变。通过n-1位的格雷码，通过逆序，就能得出n位格雷码。手写的时候可以这么写： 对于个位： 0110 0110 0110 ... 对于十位： 00111100 00111100 ... 对于百位： 000111111000 000111111000 ... 生成： @main def main(n: Int) = { def grayCodes(i: Int = n): List[List[Int]] = i match { case 0 =\u003e Nil :: Nil case _ =\u003e grayCodes(i - 1).map(0 :: _) ::: grayCodes(i - 1).reverse.map(1 :: _) } println(grayCodes().map(_.mkString).mkString(\"\\n\")) } (defun gray-codes (n) (pcase n (`0 '(())) (n (let ((codes (gray-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) (reverse codes))))))) (defun binary-codes (n) (pcase n (`1 '((0) (1))) (_ (let ((codes (binary-codes (- n 1)))) (-concat (--map (cons 0 it) codes) (--map (cons 1 it) codes)))))) (defun binary-codes-to-strings (codes) (-map (lambda (code) (-reduce #'concat (-map #'number-to-string code))) codes)) (defun gray-code-strings-with-decimal (n) (--map (format \"%s%4s\" it (format \"(%d)\" (string-to-number it 2))) (binary-codes-to-strings (gray-codes n)))) (defun gray-code-table (rows columns) (-map-indexed (lambda (index row-str) (cons row-str (pcase index (`0 (gray-code-strings-with-decimal columns)) (i (-repeat columns \"\"))))) (cons \"\" (gray-code-strings-with-decimal rows)))) (gray-code-table 3 3) 余3格雷码 前面3组格雷码和后面3组格雷码进行丢弃。 与自然二进制码的相互转换 自然二进制码转格雷码 \\[G_n=B_n, G_i=B_{i+1}\\textcircled+ B_i\\] ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:1:7","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#格雷码"},{"categories":null,"content":"数字电路 规模 规模 等效门数量 SSI（小规模） \\(\u003c10\\) MSI（中规模） \\(\u003c100\\) LSI \\(\u003c10^4\\) VLSI（超大规模） \\(\u003e10^4\\) ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:0","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#数字电路"},{"categories":null,"content":"竞争与冒险 冒险类型 描述 静态冒险 输出本不该产生变化却产生了变化 动态冒险 输出本该产生变化却产生了多余的变化 逻辑冒险 由一个输入端引起的冒险 功能冒险 由多个输入端引起的冒险 从卡诺图理解冒险的类型：卡诺图用的是格雷码，门的跳变不可能同时发生，因此从一个逻辑到另一个逻辑会沿着卡诺图的正交方向从多条路径到达另一个逻辑，如果跳变前后的逻辑是相邻的就是逻辑冒险，否则为功能冒险。如果跳变前后逻辑是相同的就为静态冒险，否则为动态冒险。静态逻辑冒险的消除：产生静态逻辑冒险的本质是我想保持一个电平而去改变其他电平，但由于我的输入信号到不同门中产生了不同时间的跳变，导致这个电平无法保持住。解决办法是让这个输出取决于更多的信号，这样当我一个输入信号改变时，这个电平依然能保持住。新加入的信号一定不能影响输出的逻辑。画卡诺图的时候，只要相邻的相同元素均可画圈，如果要求圈越少越好，圈最少的时候可能会产生“缝隙”，也就是两个圈有相邻元素但不重叠的情况，这时候应该补圈使得相邻的元素都在一个圈内，消除缝隙，即可消除静态逻辑冒险。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#竞争与冒险"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如：  S1 S0 \\ S3 S2   00   01   11   10   00               0    0    0    1   01               0    1    0    1   11               0    1    0    0   10               0    1    0    1  假如上下两个为一组：  S1 S0 \\ S3 S2   00   01   11   10   00                   0              S0             0              1         01              11                   0              1              0             !S0        10             就可以把 S0 去掉：  S1 \\ S3 S2   00   01   11    10            0    0   S0    0     1            1    0    1    0   !S0  于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 \u003c/ox-hugo/2022-01-06_04-24-25_74hc151.pdf\u003e 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 \u003c/ox-hugo/2022-01-06_04-26-29_74hc153.pdf\u003e 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 \u003c/ox-hugo/2022-01-06_04-30-04_74hc157.pdf\u003e 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 \u003c/ox-hugo/2022-01-06_06-36-45_74hc85.pdf\u003e A\u003eB 、 A=B 、 A\u003cB 用于级联。当于 A\u003eB 或 A\u003cB 有效时，直接输出 QA\u003eB 或 QA\u003cB 有效。当 A=B 有效时，通过 A0~A3 和 B0~B3 输入两个4位二进制数进行比较： A 大于 B 时 QA\u003eB 有效 A 小于 B 时 QA\u003cB 有效 A 等于 B 时 QA=B 有效 编码器 把非二进制输入编码成二进制。 代码描述 基本 entity common_encoder is port (A, B, C, D, E, F, CLK : in std_logic; -- 输入信号 F2, F1, F0 : out std_logic); -- 输出信号 end common_encoder; architecture abc of common_encoder is -- 定义一个结构，一个实体可能有多个结构 signal INA : std_logic_vector(5 downto 0); begin INA \u003c= A \u0026 B \u0026 C \u0026 D \u0026 E \u0026 F; -- 也就是 5 \u0026 4 \u0026 3 \u0026 2 \u0026 1 \u0026 0 process(INA, CLK) begin if CLK'event and CLK = '1' then -- event 代表跳变 case INA is when \"111110\" =\u003e F2 \u003c= '0'; F1 \u003c= '0'; F0 \u003c= '0'; when \"111101\" =\u003e F2 \u003c= '0'; F1 \u003c= '0'; F0 \u003c= '1'; -- ... when others =\u003e F2 \u003c= '1'; F1 \u003c= '1'; F0 \u003c= '1'; -- 表示输入无效时，输出也无效（必需） end case; end if; end process; end abc; 优先编码器 级联 有时候一个芯片的引脚可能不够用，或者一个芯片不能满足指定的编码要求，这时可以用多个支持级联的芯片进行级联。一般数字电路不希望在输入不同的情况下得到相同的输出，也就是要能够从输出来判断输入的状态。因此编码器的输出不止可以有编码的输出，还可以多加若干输出用于判断是否使能，或者输入是否错误等。在级联中，这些”多余“的引脚十分重要，因为下一级的芯片要在上一级输入无效的情况下，才进行使能，这是上一级传给下一级的额外信息。如果上一级不使能，下面的所有级都不会使能。当所有级的芯片已经正确地处理了自己负责的逻辑后，把可能还需要把芯片之间的输出取或（如果是低电平低电平有效则要取与，因为正逻辑的与，就是负逻辑的或），得到最终的输出。 芯片 74xx147 \u003c/ox-hugo/2022-01-06_04-41-43_74hc147.pdf\u003e 10位（ 0000000001~1000000000 ）转4位BCD码优先编码器， EI 作为使能端，所有引脚低电平有效。 74xx148 \u003c/ox-hugo/2022-01-06_04-51-03_74hc148.pdf\u003e 可级联的8位（ 00000001~10000000 ）转3位BCD码优先编码器，所有引脚低电平有效。要根据每种BCD码自身的特点来设计电路。假设要把10个按键输入进行4位BCD编码。这个芯片只有8个输入端，因此要进行级联。 EI 引脚 使能引脚。 EO 引脚 只有在使能且未能够进行编码（输入全为 0 不算进行编码）的情况下，才会输出0。这样当自身无法进行编码时，才会使能下一级。注意和 GS 引脚并不是单纯的相反逻辑，因为它们要输出0都有一个条件，就是这一级被使能。 GS 引脚 只有在使能且进行编码后，才会输出0（这块芯片是低电平有效）。因此可以通过改变使用的输入端口，直接让芯片负责后3位的编码，然后 GS 引脚","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#组合逻辑电路"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如： S1 S0 \\ S3 S2 00 01 11 10 00 0 0 0 1 01 0 1 0 1 11 0 1 0 0 10 0 1 0 1 假如上下两个为一组： S1 S0 \\ S3 S2 00 01 11 10 00 0 S0 0 1 01 11 0 1 0 !S0 10 就可以把 S0 去掉： S1 \\ S3 S2 00 01 11 10 0 0 S0 0 1 1 0 1 0 !S0 于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 A\u003eB 、 A=B 、 AB 或 AB 或 QAB 有效 A 小于 B 时 QA","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#门电路"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如： S1 S0 \\ S3 S2 00 01 11 10 00 0 0 0 1 01 0 1 0 1 11 0 1 0 0 10 0 1 0 1 假如上下两个为一组： S1 S0 \\ S3 S2 00 01 11 10 00 0 S0 0 1 01 11 0 1 0 !S0 10 就可以把 S0 去掉： S1 \\ S3 S2 00 01 11 10 0 0 S0 0 1 1 0 1 0 !S0 于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 A\u003eB 、 A=B 、 AB 或 AB 或 QAB 有效 A 小于 B 时 QA","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#数据选择器"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如： S1 S0 \\ S3 S2 00 01 11 10 00 0 0 0 1 01 0 1 0 1 11 0 1 0 0 10 0 1 0 1 假如上下两个为一组： S1 S0 \\ S3 S2 00 01 11 10 00 0 S0 0 1 01 11 0 1 0 !S0 10 就可以把 S0 去掉： S1 \\ S3 S2 00 01 11 10 0 0 S0 0 1 1 0 1 0 !S0 于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 A\u003eB 、 A=B 、 AB 或 AB 或 QAB 有效 A 小于 B 时 QA","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#数值比较器"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如： S1 S0 \\ S3 S2 00 01 11 10 00 0 0 0 1 01 0 1 0 1 11 0 1 0 0 10 0 1 0 1 假如上下两个为一组： S1 S0 \\ S3 S2 00 01 11 10 00 0 S0 0 1 01 11 0 1 0 !S0 10 就可以把 S0 去掉： S1 \\ S3 S2 00 01 11 10 0 0 S0 0 1 1 0 1 0 !S0 于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 A\u003eB 、 A=B 、 AB 或 AB 或 QAB 有效 A 小于 B 时 QA","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#编码器"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如： S1 S0 \\ S3 S2 00 01 11 10 00 0 0 0 1 01 0 1 0 1 11 0 1 0 0 10 0 1 0 1 假如上下两个为一组： S1 S0 \\ S3 S2 00 01 11 10 00 0 S0 0 1 01 11 0 1 0 !S0 10 就可以把 S0 去掉： S1 \\ S3 S2 00 01 11 10 0 0 S0 0 1 1 0 1 0 !S0 于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 A\u003eB 、 A=B 、 AB 或 AB 或 QAB 有效 A 小于 B 时 QA","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#译码器"},{"categories":null,"content":"组合逻辑电路 输出仅取决于当前的输入。所有芯片的使能端为低电平有效。 门电路 一般使用与非门和或非门，降低电路的复杂程度。因此往往要对得到的逻辑表达式取两次反，然后通过反演律来变换内层的取反，最后使用转换成非门电路。如果逻辑表达式中，一个门的输入有很多，则需要再用一次反演律来拆成3个输入以下的门。 芯片复用技巧： 一个芯片往往不止一个输入，如果可以高效地利用一个芯片就可以减少芯片的数量。 一个非可以用一个两个输入端同时连接一个输入的与非门来代替。 一个或可以用或非门加上一个非实现。 参数 电压传输特性 最大低电平输出\\(V_\\mathrm{OL(\\max)}\\) 最小高电平输出\\(V_\\mathrm{OH(\\min)}\\) 最大低电平输入\\(V_\\mathrm{IL(\\max)}\\) 最小高电平输入\\(V_\\mathrm{IH(\\min)}\\) 噪声容限\\(V_\\mathrm{NH}\\) 扇出系数：门电路带同类门的个数：LSTTL为个位数 输入特性 输入低电平电流\\(I_\\mathrm{IL}\\) 输入高电平电流\\(I_\\mathrm{IH}\\) \\(R_\\mathrm{ON}\\) \\(R_\\mathrm{OFF}\\) 输出特性 \\(t_\\mathrm{PD}\\)：平均延时 \\(P_\\mathrm{D}\\)：动态功率 转折电压\\(V_T\\) 噪声容限：感觉像是多个相同芯片进行级联的时候，对噪声的容忍限度。 例如：高电平噪声容限=高电平输出-最小高电平输入，也就是输出高电平波动在噪声容限内，不会对下一级的输出产生影响。 芯片 型号 逻辑门 输入端口数 路数 74LS00 与非门 2 4 74LS02 或非门 2 4 74LS04 非门 1 6 74LS08 与门 2 4 74LS10 与非门 3 3 74LS11 与门 3 3 74LS27 或非门 3 3 74LS30 与非门 8 1 74LS32 或门 2 4 74LS86 异或门 2 4 74LS135 异或门 2 4 74LS260 或非门 5 2 类型 非门 与门 或门 异或门 同或门 与非门 用 \\(\\\u0026\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。圈（斜杠）是低电平有效，也就是正逻辑下两个高电平输出低电平。 或非门 用 \\(\\geq 1\\) 表示。由于是非门，门的输出还有一个圈（斜杠）。 TTL门电路 特点 悬空相当于高电平 输出端接的电阻大于1kΩ，低电平可能无法传到下一级 CMOS门电路 OD门 线与 OD门的输出是灌电流的，可以使用导线相连来表示与非门。 数据选择器 相当于多路开关，输出的个数少于输入，因此有地址选择端用于决定每一路输出取决于哪一路输入。有的芯片可以通过模拟信号，有的芯片只能通过数字信号。只要给数据选择器的一路输入接上高低电平信号，这路就可以用来表示一个真值表或卡诺图。当输入逻辑的数目超过数据选择器地址选端的数目时，可以通过卡诺图的降维，来使用一个数据选择器处理超过其地址选择端数量的逻辑。 卡诺图降维 卡诺图的压缩，可以把卡诺图两个两个为一组画圈，如： S1 S0 \\ S3 S2 00 01 11 10 00 0 0 0 1 01 0 1 0 1 11 0 1 0 0 10 0 1 0 1 假如上下两个为一组： S1 S0 \\ S3 S2 00 01 11 10 00 0 S0 0 1 01 11 0 1 0 !S0 10 就可以把 S0 去掉： S1 \\ S3 S2 00 01 11 10 0 0 S0 0 1 1 0 1 0 !S0 于是把 S0 作为这个数据选择器的输入（非地址选端）即可。 芯片 74xx151 八选一数据选择器。 X1~X8 为8个输入端，当使能端 E （低电平有效）有效时，通过 A~C 输入三位二进制进行选择，输出 Y 。 74xx153 双路四选一数据选择器。 八选一数据选择器。 1X1~1X4 和 2X1~2X4 分别为2个通道的4个输入端，通过 A~B 输入二位二进制进行选择，输出 Y 。 74xx157 四路二选一数据选择器。 1A/1B 、 2A/2B 、 3A/3B 、 4A/4B 分别为4路输入端，通过 A/B 引脚进行选择。 74xx4051 可以输出模拟信号。 数值比较器 比较两组输入的二进制数的大小，对于3种情况可能有不同的输出。 级联 数值比较器也可以进行级联，比如一块芯片负责比较两组二进制的高4位，只有在前一级芯片输出相等的时候，下一块芯片才会进行进行低位的比较，否则直接输出上一块芯片的比较结果。 芯片 74xx85 ：4位二进制数值比较器 A\u003eB 、 A=B 、 AB 或 AB 或 QAB 有效 A 小于 B 时 QA","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#加法器"},{"categories":null,"content":"时序逻辑电路 输出取决于当前和之前的输入。结构上的特征是有反馈信号。 类型 米里型：输出取决于状态的转移（与输入有关） 摩尔型：输出取决于当前状态 自启动 卡诺图的画圈是用于化简的，有多种方法，且任意项（也就是没有包含在状态表里的输入）可以不包含在圈内。任意项的包含与否决定着电路是否能自启动。 移位寄存器 工作方式 串入串出：相当于时钟上的分割 串入并出 并入串出 并入并出 芯片 74xx164 ：8位串入并出移位寄存寄存器，异步清零 \u003c/ox-hugo/2022-01-06_05-08-47_74hc164.pdf\u003e 2个输入通过自带的1个与门输入，在时钟上跳变时，从最高位（第7位移入），异步清零（低电平有效）。 74xx194 ：双向通用移位寄存器，同步预置、异步清零 \u003c/ox-hugo/2022-01-06_05-12-48_74hc194.pdf\u003e D0~D3 负责当 S0 和 S1 均有效时的异步预置输入。 S1 控制时钟上跳变时将 SL 作为输入进行左移， S0 控制时钟上跳变时将 SR 作为输入进行左移， MR （低电平有效）负责异步清零。 74xx195 ：并行存取移位寄存器 \u003c/ox-hugo/2022-01-06_05-19-53_74hc195.pdf\u003e 反馈移位寄存器 在移位寄存器向右移位一位以后，左边就会空出一位，这时如果采用一个反馈函数，以寄存器中已有的某些序列作为反馈函数的输入，在函数中经过一定的运算后，将反馈函数输出的结果填充到移位寄存器的最左端，那么这样的移位寄存器就会有源源不断的输出。这样的，拥有反馈函数的移位寄存器称为反馈移位寄存器（Feedback Shift Register，FSR）。 线性反馈移位寄存器 线性反馈移位寄存器（LFSR）的反馈函数就是简单地对移位寄存器中的某些位进行异或，并将异或的结果填充到其最左端，如图所示。对于移位寄存器中的每一位数据，可以参与异或，也可以不参与异或。其中： 抽头：参与异或的位 级数：移位寄存器的长度 状态：当前移位寄存器中的序列。 一个线性反馈移位寄存器最多只能遍历\\(2^n-1\\)个状态（排除移位寄存器中全为0的情况）。 特征多项式 \\[b_{n+1}=c_1b_1\\textcircled+ c_2b_2\\textcircled+ \\cdots \\textcircled+ c_nb_n\\] 其中（\\(c_n\\)用于表示该位是否参与异或），对应的特征多项式为： \\[f(x)=c_nx^n+c_{n-1}+\\cdots +c_2x^2+c_1x^1+1\\] M序列：周期为\\(2^n-1\\)（\\(n\\)为级数）的线性反馈移位寄存器产生的序列。 计数器 预置 异步预置 异步预置导致两个数占用同一个周期的问题，因此清零必须在下一个（刚好溢出）周期进行。 芯片 74xx169 ：4位可逆同步计数器（16进制），同步预置 DA~DD 负责数据当 LD （低电平有效）有效时的同步预置输入（ D 为最高位）， QA~QD 负责数据输出。有两个使能端 ENP 和 ENT （均为低电平有效），均有效时才会在时钟上跳变时进行计数，具有加减控制端 U/D ，有效时进行加法，无效时进行减法。当加法即将进位（ 1111 ）或减法即将退位（ 0000 ）时， RCO （低电平有效）有效 。注意，只有预置功能，没有清零功能。 74xx192 ：BCD同步可逆计数器（10进制），异步预置 \u003c/ox-hugo/2022-01-06_05-32-35_74hc192.pdf\u003e CPU 负责加计数的时钟信号， CPD 负责减计数的时钟信号，均为上跳变触发。 MR 用于异步清零。 D0~D3 负责当 PL （低电平有效）有效时的异步预置。 TCU 和 TCD 用于进位输出，平时为高，在即将进位（ 1001 ）或即将退位（ 0000 ）时，随时钟信号变化，用于级联时，上跳变就意味着下一级的进位或退位。 锁存器 使能端有效时，输出等于输入，否则保持之前的输出。 D锁存器 芯片 74xx373 ：8通道D锁存器 \u003c/ox-hugo/2022-01-06_05-49-46_74hc373.pdf\u003e Q0~Q7 用于输出。 LE 是锁存器的使能端，有效时从 D0~D7 写入锁存器，无效时进行所存。 OE （低电平有效）用于输出使能，无效时输出为高阻。 触发器 RS 触发器 当 S 为 1 时，置 1 ；当 R 为 1 时清零，因此 R 和 S 最多只能有 1 个等于 1 。也就是： S R Q 0 0 不变 1 0 1 0 1 0 1 1 不允许 \\[RS=0\\Rightarrow Q^{n+1}=S+\\overline{R}Q^n\\] 或非门实现 与非门实现 D 触发器 RS 触发器有如下缺点，设置一个值需要两个输入同时参与，并且具有非法输入。而D 触发器更像一个锁存器，一个输入用于使能写入，一个输入用于设置写入的值。当写入没有被使能时，无论写入的值如何变化，储存的值都不会发生改变。 \\[Q^{n+1}=D\\] EN 决定是否输入为 00 ，D的值决定RS 触发器的输入为 10 还是 01 。 芯片 74xx374 ：8通道D触发器 \u003c/ox-hugo/2022-01-06_05-56-42_74hc374.pdf\u003e 除了将使能端替换为上跳变触发的时钟输入端外，其余的与 74xx373 一样。 74XX74 ：带置位复位正触发的双D触发器 \u003c/ox-hugo/2022-01-06_05-59-26_74hc74.pdf\u003e 与 74xx374 不同的是，它既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为D触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 JK 触发器 既可以直接设置触发器的值，又可以在不知道里面值的情况下对值进行翻转。 JK \\(Q^{n+1}\\) \\(\\overline{Q^{n+1}}\\) 00 \\(Q^n\\) \\(\\overline{Q^n}\\) 01 0 1 10 1 0 11 \\(\\overline{Q^n}\\) \\(Q^n\\) 方程为： \\[Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\] 只要JK为1，就会不停地翻转。 电路设计 一个逻辑总是可以写成与或式，因此至少可以用一个JK触发器来表示。首先要画卡诺图，对于每个下一个状态，都要画一张卡诺图。 技巧 在状态表里横着看，从前一个状态确定这一行在很多张卡诺图的位置，然后根据下一个输出结果依次填写到多张卡诺图中。 由于一定要写成\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)，因此要在一个输出（如\\(Q_2^{n+1}\\)）卡诺图中，分成两半： 找到对应输入\\(Q_2^n\\)为1的输入组合，也就是公式中的\\(Q^n\\) 找到对应输入为0的输入，也就是公式中的\\(\\overline{Q^n}\\)，剩下的\\(J,K\\)对应的就是其他引脚的输入。由于JK触发器是与或式，可以不管0的格子。 芯片 74xx112 ：双负沿JK触发器 \u003c/ox-hugo/2022-01-06_06-02-40_74hc112.pdf\u003e 既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为JK触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 主从JK触发器 JK 触发器的输入直接影响输出而输出又直接影响输入，导致可能不停翻转。解决办法是使用两个JK触发器（其实是1个JK 触发器和1个带使能端的RS 触发器），主从触发器只能轮流使能，反馈从从触发器引回到主触发器： 主触发器使能（ CP 为 1 ）：接受 JK 的变化，改变主触发器的值。 由于两个输出是互斥的，因此主触发器中RS 触发器的输入要么为 00 （对\\(\\overline S\\)和\\(\\overline R\\)取反），要么为\\(\\overline Q\\)和\\(Q\\)，也就是不变或者翻转。由于输出是一直不变的，因此如果翻转，最多只能翻转一次。 从触发器使能（ CP 为 0 ）：把主触发器的值直接给输出。 因此，只有在CP从1变成0时，输出才会变化。当CP等于1期间，如果JK发生翻转，由于从触发器反馈给主触发器的电平不变，会以第一次翻转为准，而不是CP从1变0那一瞬间的电平。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#时序逻辑电路"},{"categories":null,"content":"时序逻辑电路 输出取决于当前和之前的输入。结构上的特征是有反馈信号。 类型 米里型：输出取决于状态的转移（与输入有关） 摩尔型：输出取决于当前状态 自启动 卡诺图的画圈是用于化简的，有多种方法，且任意项（也就是没有包含在状态表里的输入）可以不包含在圈内。任意项的包含与否决定着电路是否能自启动。 移位寄存器 工作方式 串入串出：相当于时钟上的分割 串入并出 并入串出 并入并出 芯片 74xx164 ：8位串入并出移位寄存寄存器，异步清零 2个输入通过自带的1个与门输入，在时钟上跳变时，从最高位（第7位移入），异步清零（低电平有效）。 74xx194 ：双向通用移位寄存器，同步预置、异步清零 D0~D3 负责当 S0 和 S1 均有效时的异步预置输入。 S1 控制时钟上跳变时将 SL 作为输入进行左移， S0 控制时钟上跳变时将 SR 作为输入进行左移， MR （低电平有效）负责异步清零。 74xx195 ：并行存取移位寄存器 反馈移位寄存器 在移位寄存器向右移位一位以后，左边就会空出一位，这时如果采用一个反馈函数，以寄存器中已有的某些序列作为反馈函数的输入，在函数中经过一定的运算后，将反馈函数输出的结果填充到移位寄存器的最左端，那么这样的移位寄存器就会有源源不断的输出。这样的，拥有反馈函数的移位寄存器称为反馈移位寄存器（Feedback Shift Register，FSR）。 线性反馈移位寄存器 线性反馈移位寄存器（LFSR）的反馈函数就是简单地对移位寄存器中的某些位进行异或，并将异或的结果填充到其最左端，如图所示。对于移位寄存器中的每一位数据，可以参与异或，也可以不参与异或。其中： 抽头：参与异或的位 级数：移位寄存器的长度 状态：当前移位寄存器中的序列。 一个线性反馈移位寄存器最多只能遍历\\(2^n-1\\)个状态（排除移位寄存器中全为0的情况）。 特征多项式 \\[b_{n+1}=c_1b_1\\textcircled+ c_2b_2\\textcircled+ \\cdots \\textcircled+ c_nb_n\\] 其中（\\(c_n\\)用于表示该位是否参与异或），对应的特征多项式为： \\[f(x)=c_nx^n+c_{n-1}+\\cdots +c_2x^2+c_1x^1+1\\] M序列：周期为\\(2^n-1\\)（\\(n\\)为级数）的线性反馈移位寄存器产生的序列。 计数器 预置 异步预置 异步预置导致两个数占用同一个周期的问题，因此清零必须在下一个（刚好溢出）周期进行。 芯片 74xx169 ：4位可逆同步计数器（16进制），同步预置 DA~DD 负责数据当 LD （低电平有效）有效时的同步预置输入（ D 为最高位）， QA~QD 负责数据输出。有两个使能端 ENP 和 ENT （均为低电平有效），均有效时才会在时钟上跳变时进行计数，具有加减控制端 U/D ，有效时进行加法，无效时进行减法。当加法即将进位（ 1111 ）或减法即将退位（ 0000 ）时， RCO （低电平有效）有效 。注意，只有预置功能，没有清零功能。 74xx192 ：BCD同步可逆计数器（10进制），异步预置 CPU 负责加计数的时钟信号， CPD 负责减计数的时钟信号，均为上跳变触发。 MR 用于异步清零。 D0~D3 负责当 PL （低电平有效）有效时的异步预置。 TCU 和 TCD 用于进位输出，平时为高，在即将进位（ 1001 ）或即将退位（ 0000 ）时，随时钟信号变化，用于级联时，上跳变就意味着下一级的进位或退位。 锁存器 使能端有效时，输出等于输入，否则保持之前的输出。 D锁存器 芯片 74xx373 ：8通道D锁存器 Q0~Q7 用于输出。 LE 是锁存器的使能端，有效时从 D0~D7 写入锁存器，无效时进行所存。 OE （低电平有效）用于输出使能，无效时输出为高阻。 触发器 RS 触发器 当 S 为 1 时，置 1 ；当 R 为 1 时清零，因此 R 和 S 最多只能有 1 个等于 1 。也就是： S R Q 0 0 不变 1 0 1 0 1 0 1 1 不允许 \\[RS=0\\Rightarrow Q^{n+1}=S+\\overline{R}Q^n\\] 或非门实现 与非门实现 D 触发器 RS 触发器有如下缺点，设置一个值需要两个输入同时参与，并且具有非法输入。而D 触发器更像一个锁存器，一个输入用于使能写入，一个输入用于设置写入的值。当写入没有被使能时，无论写入的值如何变化，储存的值都不会发生改变。 \\[Q^{n+1}=D\\] EN 决定是否输入为 00 ，D的值决定RS 触发器的输入为 10 还是 01 。 芯片 74xx374 ：8通道D触发器 除了将使能端替换为上跳变触发的时钟输入端外，其余的与 74xx373 一样。 74XX74 ：带置位复位正触发的双D触发器 与 74xx374 不同的是，它既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为D触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 JK 触发器 既可以直接设置触发器的值，又可以在不知道里面值的情况下对值进行翻转。 JK \\(Q^{n+1}\\) \\(\\overline{Q^{n+1}}\\) 00 \\(Q^n\\) \\(\\overline{Q^n}\\) 01 0 1 10 1 0 11 \\(\\overline{Q^n}\\) \\(Q^n\\) 方程为： \\[Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\] 只要JK为1，就会不停地翻转。 电路设计 一个逻辑总是可以写成与或式，因此至少可以用一个JK触发器来表示。首先要画卡诺图，对于每个下一个状态，都要画一张卡诺图。 技巧 在状态表里横着看，从前一个状态确定这一行在很多张卡诺图的位置，然后根据下一个输出结果依次填写到多张卡诺图中。 由于一定要写成\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)，因此要在一个输出（如\\(Q_2^{n+1}\\)）卡诺图中，分成两半： 找到对应输入\\(Q_2^n\\)为1的输入组合，也就是公式中的\\(Q^n\\) 找到对应输入为0的输入，也就是公式中的\\(\\overline{Q^n}\\)，剩下的\\(J,K\\)对应的就是其他引脚的输入。由于JK触发器是与或式，可以不管0的格子。 芯片 74xx112 ：双负沿JK触发器 既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为JK触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 主从JK触发器 JK 触发器的输入直接影响输出而输出又直接影响输入，导致可能不停翻转。解决办法是使用两个JK触发器（其实是1个JK 触发器和1个带使能端的RS 触发器），主从触发器只能轮流使能，反馈从从触发器引回到主触发器： 主触发器使能（ CP 为 1 ）：接受 JK 的变化，改变主触发器的值。 由于两个输出是互斥的，因此主触发器中RS 触发器的输入要么为 00 （对\\(\\overline S\\)和\\(\\overline R\\)取反），要么为\\(\\overline Q\\)和\\(Q\\)，也就是不变或者翻转。由于输出是一直不变的，因此如果翻转，最多只能翻转一次。 从触发器使能（ CP 为 0 ）：把主触发器的值直接给输出。 因此，只有在CP从1变成0时，输出才会变化。当CP等于1期间，如果JK发生翻转，由于从触发器反馈给主触发器的电平不变，会以第一次翻转为准，而不是CP从1变0那一瞬间的电平。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#移位寄存器"},{"categories":null,"content":"时序逻辑电路 输出取决于当前和之前的输入。结构上的特征是有反馈信号。 类型 米里型：输出取决于状态的转移（与输入有关） 摩尔型：输出取决于当前状态 自启动 卡诺图的画圈是用于化简的，有多种方法，且任意项（也就是没有包含在状态表里的输入）可以不包含在圈内。任意项的包含与否决定着电路是否能自启动。 移位寄存器 工作方式 串入串出：相当于时钟上的分割 串入并出 并入串出 并入并出 芯片 74xx164 ：8位串入并出移位寄存寄存器，异步清零 2个输入通过自带的1个与门输入，在时钟上跳变时，从最高位（第7位移入），异步清零（低电平有效）。 74xx194 ：双向通用移位寄存器，同步预置、异步清零 D0~D3 负责当 S0 和 S1 均有效时的异步预置输入。 S1 控制时钟上跳变时将 SL 作为输入进行左移， S0 控制时钟上跳变时将 SR 作为输入进行左移， MR （低电平有效）负责异步清零。 74xx195 ：并行存取移位寄存器 反馈移位寄存器 在移位寄存器向右移位一位以后，左边就会空出一位，这时如果采用一个反馈函数，以寄存器中已有的某些序列作为反馈函数的输入，在函数中经过一定的运算后，将反馈函数输出的结果填充到移位寄存器的最左端，那么这样的移位寄存器就会有源源不断的输出。这样的，拥有反馈函数的移位寄存器称为反馈移位寄存器（Feedback Shift Register，FSR）。 线性反馈移位寄存器 线性反馈移位寄存器（LFSR）的反馈函数就是简单地对移位寄存器中的某些位进行异或，并将异或的结果填充到其最左端，如图所示。对于移位寄存器中的每一位数据，可以参与异或，也可以不参与异或。其中： 抽头：参与异或的位 级数：移位寄存器的长度 状态：当前移位寄存器中的序列。 一个线性反馈移位寄存器最多只能遍历\\(2^n-1\\)个状态（排除移位寄存器中全为0的情况）。 特征多项式 \\[b_{n+1}=c_1b_1\\textcircled+ c_2b_2\\textcircled+ \\cdots \\textcircled+ c_nb_n\\] 其中（\\(c_n\\)用于表示该位是否参与异或），对应的特征多项式为： \\[f(x)=c_nx^n+c_{n-1}+\\cdots +c_2x^2+c_1x^1+1\\] M序列：周期为\\(2^n-1\\)（\\(n\\)为级数）的线性反馈移位寄存器产生的序列。 计数器 预置 异步预置 异步预置导致两个数占用同一个周期的问题，因此清零必须在下一个（刚好溢出）周期进行。 芯片 74xx169 ：4位可逆同步计数器（16进制），同步预置 DA~DD 负责数据当 LD （低电平有效）有效时的同步预置输入（ D 为最高位）， QA~QD 负责数据输出。有两个使能端 ENP 和 ENT （均为低电平有效），均有效时才会在时钟上跳变时进行计数，具有加减控制端 U/D ，有效时进行加法，无效时进行减法。当加法即将进位（ 1111 ）或减法即将退位（ 0000 ）时， RCO （低电平有效）有效 。注意，只有预置功能，没有清零功能。 74xx192 ：BCD同步可逆计数器（10进制），异步预置 CPU 负责加计数的时钟信号， CPD 负责减计数的时钟信号，均为上跳变触发。 MR 用于异步清零。 D0~D3 负责当 PL （低电平有效）有效时的异步预置。 TCU 和 TCD 用于进位输出，平时为高，在即将进位（ 1001 ）或即将退位（ 0000 ）时，随时钟信号变化，用于级联时，上跳变就意味着下一级的进位或退位。 锁存器 使能端有效时，输出等于输入，否则保持之前的输出。 D锁存器 芯片 74xx373 ：8通道D锁存器 Q0~Q7 用于输出。 LE 是锁存器的使能端，有效时从 D0~D7 写入锁存器，无效时进行所存。 OE （低电平有效）用于输出使能，无效时输出为高阻。 触发器 RS 触发器 当 S 为 1 时，置 1 ；当 R 为 1 时清零，因此 R 和 S 最多只能有 1 个等于 1 。也就是： S R Q 0 0 不变 1 0 1 0 1 0 1 1 不允许 \\[RS=0\\Rightarrow Q^{n+1}=S+\\overline{R}Q^n\\] 或非门实现 与非门实现 D 触发器 RS 触发器有如下缺点，设置一个值需要两个输入同时参与，并且具有非法输入。而D 触发器更像一个锁存器，一个输入用于使能写入，一个输入用于设置写入的值。当写入没有被使能时，无论写入的值如何变化，储存的值都不会发生改变。 \\[Q^{n+1}=D\\] EN 决定是否输入为 00 ，D的值决定RS 触发器的输入为 10 还是 01 。 芯片 74xx374 ：8通道D触发器 除了将使能端替换为上跳变触发的时钟输入端外，其余的与 74xx373 一样。 74XX74 ：带置位复位正触发的双D触发器 与 74xx374 不同的是，它既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为D触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 JK 触发器 既可以直接设置触发器的值，又可以在不知道里面值的情况下对值进行翻转。 JK \\(Q^{n+1}\\) \\(\\overline{Q^{n+1}}\\) 00 \\(Q^n\\) \\(\\overline{Q^n}\\) 01 0 1 10 1 0 11 \\(\\overline{Q^n}\\) \\(Q^n\\) 方程为： \\[Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\] 只要JK为1，就会不停地翻转。 电路设计 一个逻辑总是可以写成与或式，因此至少可以用一个JK触发器来表示。首先要画卡诺图，对于每个下一个状态，都要画一张卡诺图。 技巧 在状态表里横着看，从前一个状态确定这一行在很多张卡诺图的位置，然后根据下一个输出结果依次填写到多张卡诺图中。 由于一定要写成\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)，因此要在一个输出（如\\(Q_2^{n+1}\\)）卡诺图中，分成两半： 找到对应输入\\(Q_2^n\\)为1的输入组合，也就是公式中的\\(Q^n\\) 找到对应输入为0的输入，也就是公式中的\\(\\overline{Q^n}\\)，剩下的\\(J,K\\)对应的就是其他引脚的输入。由于JK触发器是与或式，可以不管0的格子。 芯片 74xx112 ：双负沿JK触发器 既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为JK触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 主从JK触发器 JK 触发器的输入直接影响输出而输出又直接影响输入，导致可能不停翻转。解决办法是使用两个JK触发器（其实是1个JK 触发器和1个带使能端的RS 触发器），主从触发器只能轮流使能，反馈从从触发器引回到主触发器： 主触发器使能（ CP 为 1 ）：接受 JK 的变化，改变主触发器的值。 由于两个输出是互斥的，因此主触发器中RS 触发器的输入要么为 00 （对\\(\\overline S\\)和\\(\\overline R\\)取反），要么为\\(\\overline Q\\)和\\(Q\\)，也就是不变或者翻转。由于输出是一直不变的，因此如果翻转，最多只能翻转一次。 从触发器使能（ CP 为 0 ）：把主触发器的值直接给输出。 因此，只有在CP从1变成0时，输出才会变化。当CP等于1期间，如果JK发生翻转，由于从触发器反馈给主触发器的电平不变，会以第一次翻转为准，而不是CP从1变0那一瞬间的电平。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#计数器"},{"categories":null,"content":"时序逻辑电路 输出取决于当前和之前的输入。结构上的特征是有反馈信号。 类型 米里型：输出取决于状态的转移（与输入有关） 摩尔型：输出取决于当前状态 自启动 卡诺图的画圈是用于化简的，有多种方法，且任意项（也就是没有包含在状态表里的输入）可以不包含在圈内。任意项的包含与否决定着电路是否能自启动。 移位寄存器 工作方式 串入串出：相当于时钟上的分割 串入并出 并入串出 并入并出 芯片 74xx164 ：8位串入并出移位寄存寄存器，异步清零 2个输入通过自带的1个与门输入，在时钟上跳变时，从最高位（第7位移入），异步清零（低电平有效）。 74xx194 ：双向通用移位寄存器，同步预置、异步清零 D0~D3 负责当 S0 和 S1 均有效时的异步预置输入。 S1 控制时钟上跳变时将 SL 作为输入进行左移， S0 控制时钟上跳变时将 SR 作为输入进行左移， MR （低电平有效）负责异步清零。 74xx195 ：并行存取移位寄存器 反馈移位寄存器 在移位寄存器向右移位一位以后，左边就会空出一位，这时如果采用一个反馈函数，以寄存器中已有的某些序列作为反馈函数的输入，在函数中经过一定的运算后，将反馈函数输出的结果填充到移位寄存器的最左端，那么这样的移位寄存器就会有源源不断的输出。这样的，拥有反馈函数的移位寄存器称为反馈移位寄存器（Feedback Shift Register，FSR）。 线性反馈移位寄存器 线性反馈移位寄存器（LFSR）的反馈函数就是简单地对移位寄存器中的某些位进行异或，并将异或的结果填充到其最左端，如图所示。对于移位寄存器中的每一位数据，可以参与异或，也可以不参与异或。其中： 抽头：参与异或的位 级数：移位寄存器的长度 状态：当前移位寄存器中的序列。 一个线性反馈移位寄存器最多只能遍历\\(2^n-1\\)个状态（排除移位寄存器中全为0的情况）。 特征多项式 \\[b_{n+1}=c_1b_1\\textcircled+ c_2b_2\\textcircled+ \\cdots \\textcircled+ c_nb_n\\] 其中（\\(c_n\\)用于表示该位是否参与异或），对应的特征多项式为： \\[f(x)=c_nx^n+c_{n-1}+\\cdots +c_2x^2+c_1x^1+1\\] M序列：周期为\\(2^n-1\\)（\\(n\\)为级数）的线性反馈移位寄存器产生的序列。 计数器 预置 异步预置 异步预置导致两个数占用同一个周期的问题，因此清零必须在下一个（刚好溢出）周期进行。 芯片 74xx169 ：4位可逆同步计数器（16进制），同步预置 DA~DD 负责数据当 LD （低电平有效）有效时的同步预置输入（ D 为最高位）， QA~QD 负责数据输出。有两个使能端 ENP 和 ENT （均为低电平有效），均有效时才会在时钟上跳变时进行计数，具有加减控制端 U/D ，有效时进行加法，无效时进行减法。当加法即将进位（ 1111 ）或减法即将退位（ 0000 ）时， RCO （低电平有效）有效 。注意，只有预置功能，没有清零功能。 74xx192 ：BCD同步可逆计数器（10进制），异步预置 CPU 负责加计数的时钟信号， CPD 负责减计数的时钟信号，均为上跳变触发。 MR 用于异步清零。 D0~D3 负责当 PL （低电平有效）有效时的异步预置。 TCU 和 TCD 用于进位输出，平时为高，在即将进位（ 1001 ）或即将退位（ 0000 ）时，随时钟信号变化，用于级联时，上跳变就意味着下一级的进位或退位。 锁存器 使能端有效时，输出等于输入，否则保持之前的输出。 D锁存器 芯片 74xx373 ：8通道D锁存器 Q0~Q7 用于输出。 LE 是锁存器的使能端，有效时从 D0~D7 写入锁存器，无效时进行所存。 OE （低电平有效）用于输出使能，无效时输出为高阻。 触发器 RS 触发器 当 S 为 1 时，置 1 ；当 R 为 1 时清零，因此 R 和 S 最多只能有 1 个等于 1 。也就是： S R Q 0 0 不变 1 0 1 0 1 0 1 1 不允许 \\[RS=0\\Rightarrow Q^{n+1}=S+\\overline{R}Q^n\\] 或非门实现 与非门实现 D 触发器 RS 触发器有如下缺点，设置一个值需要两个输入同时参与，并且具有非法输入。而D 触发器更像一个锁存器，一个输入用于使能写入，一个输入用于设置写入的值。当写入没有被使能时，无论写入的值如何变化，储存的值都不会发生改变。 \\[Q^{n+1}=D\\] EN 决定是否输入为 00 ，D的值决定RS 触发器的输入为 10 还是 01 。 芯片 74xx374 ：8通道D触发器 除了将使能端替换为上跳变触发的时钟输入端外，其余的与 74xx373 一样。 74XX74 ：带置位复位正触发的双D触发器 与 74xx374 不同的是，它既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为D触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 JK 触发器 既可以直接设置触发器的值，又可以在不知道里面值的情况下对值进行翻转。 JK \\(Q^{n+1}\\) \\(\\overline{Q^{n+1}}\\) 00 \\(Q^n\\) \\(\\overline{Q^n}\\) 01 0 1 10 1 0 11 \\(\\overline{Q^n}\\) \\(Q^n\\) 方程为： \\[Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\] 只要JK为1，就会不停地翻转。 电路设计 一个逻辑总是可以写成与或式，因此至少可以用一个JK触发器来表示。首先要画卡诺图，对于每个下一个状态，都要画一张卡诺图。 技巧 在状态表里横着看，从前一个状态确定这一行在很多张卡诺图的位置，然后根据下一个输出结果依次填写到多张卡诺图中。 由于一定要写成\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)，因此要在一个输出（如\\(Q_2^{n+1}\\)）卡诺图中，分成两半： 找到对应输入\\(Q_2^n\\)为1的输入组合，也就是公式中的\\(Q^n\\) 找到对应输入为0的输入，也就是公式中的\\(\\overline{Q^n}\\)，剩下的\\(J,K\\)对应的就是其他引脚的输入。由于JK触发器是与或式，可以不管0的格子。 芯片 74xx112 ：双负沿JK触发器 既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为JK触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 主从JK触发器 JK 触发器的输入直接影响输出而输出又直接影响输入，导致可能不停翻转。解决办法是使用两个JK触发器（其实是1个JK 触发器和1个带使能端的RS 触发器），主从触发器只能轮流使能，反馈从从触发器引回到主触发器： 主触发器使能（ CP 为 1 ）：接受 JK 的变化，改变主触发器的值。 由于两个输出是互斥的，因此主触发器中RS 触发器的输入要么为 00 （对\\(\\overline S\\)和\\(\\overline R\\)取反），要么为\\(\\overline Q\\)和\\(Q\\)，也就是不变或者翻转。由于输出是一直不变的，因此如果翻转，最多只能翻转一次。 从触发器使能（ CP 为 0 ）：把主触发器的值直接给输出。 因此，只有在CP从1变成0时，输出才会变化。当CP等于1期间，如果JK发生翻转，由于从触发器反馈给主触发器的电平不变，会以第一次翻转为准，而不是CP从1变0那一瞬间的电平。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#锁存器"},{"categories":null,"content":"时序逻辑电路 输出取决于当前和之前的输入。结构上的特征是有反馈信号。 类型 米里型：输出取决于状态的转移（与输入有关） 摩尔型：输出取决于当前状态 自启动 卡诺图的画圈是用于化简的，有多种方法，且任意项（也就是没有包含在状态表里的输入）可以不包含在圈内。任意项的包含与否决定着电路是否能自启动。 移位寄存器 工作方式 串入串出：相当于时钟上的分割 串入并出 并入串出 并入并出 芯片 74xx164 ：8位串入并出移位寄存寄存器，异步清零 2个输入通过自带的1个与门输入，在时钟上跳变时，从最高位（第7位移入），异步清零（低电平有效）。 74xx194 ：双向通用移位寄存器，同步预置、异步清零 D0~D3 负责当 S0 和 S1 均有效时的异步预置输入。 S1 控制时钟上跳变时将 SL 作为输入进行左移， S0 控制时钟上跳变时将 SR 作为输入进行左移， MR （低电平有效）负责异步清零。 74xx195 ：并行存取移位寄存器 反馈移位寄存器 在移位寄存器向右移位一位以后，左边就会空出一位，这时如果采用一个反馈函数，以寄存器中已有的某些序列作为反馈函数的输入，在函数中经过一定的运算后，将反馈函数输出的结果填充到移位寄存器的最左端，那么这样的移位寄存器就会有源源不断的输出。这样的，拥有反馈函数的移位寄存器称为反馈移位寄存器（Feedback Shift Register，FSR）。 线性反馈移位寄存器 线性反馈移位寄存器（LFSR）的反馈函数就是简单地对移位寄存器中的某些位进行异或，并将异或的结果填充到其最左端，如图所示。对于移位寄存器中的每一位数据，可以参与异或，也可以不参与异或。其中： 抽头：参与异或的位 级数：移位寄存器的长度 状态：当前移位寄存器中的序列。 一个线性反馈移位寄存器最多只能遍历\\(2^n-1\\)个状态（排除移位寄存器中全为0的情况）。 特征多项式 \\[b_{n+1}=c_1b_1\\textcircled+ c_2b_2\\textcircled+ \\cdots \\textcircled+ c_nb_n\\] 其中（\\(c_n\\)用于表示该位是否参与异或），对应的特征多项式为： \\[f(x)=c_nx^n+c_{n-1}+\\cdots +c_2x^2+c_1x^1+1\\] M序列：周期为\\(2^n-1\\)（\\(n\\)为级数）的线性反馈移位寄存器产生的序列。 计数器 预置 异步预置 异步预置导致两个数占用同一个周期的问题，因此清零必须在下一个（刚好溢出）周期进行。 芯片 74xx169 ：4位可逆同步计数器（16进制），同步预置 DA~DD 负责数据当 LD （低电平有效）有效时的同步预置输入（ D 为最高位）， QA~QD 负责数据输出。有两个使能端 ENP 和 ENT （均为低电平有效），均有效时才会在时钟上跳变时进行计数，具有加减控制端 U/D ，有效时进行加法，无效时进行减法。当加法即将进位（ 1111 ）或减法即将退位（ 0000 ）时， RCO （低电平有效）有效 。注意，只有预置功能，没有清零功能。 74xx192 ：BCD同步可逆计数器（10进制），异步预置 CPU 负责加计数的时钟信号， CPD 负责减计数的时钟信号，均为上跳变触发。 MR 用于异步清零。 D0~D3 负责当 PL （低电平有效）有效时的异步预置。 TCU 和 TCD 用于进位输出，平时为高，在即将进位（ 1001 ）或即将退位（ 0000 ）时，随时钟信号变化，用于级联时，上跳变就意味着下一级的进位或退位。 锁存器 使能端有效时，输出等于输入，否则保持之前的输出。 D锁存器 芯片 74xx373 ：8通道D锁存器 Q0~Q7 用于输出。 LE 是锁存器的使能端，有效时从 D0~D7 写入锁存器，无效时进行所存。 OE （低电平有效）用于输出使能，无效时输出为高阻。 触发器 RS 触发器 当 S 为 1 时，置 1 ；当 R 为 1 时清零，因此 R 和 S 最多只能有 1 个等于 1 。也就是： S R Q 0 0 不变 1 0 1 0 1 0 1 1 不允许 \\[RS=0\\Rightarrow Q^{n+1}=S+\\overline{R}Q^n\\] 或非门实现 与非门实现 D 触发器 RS 触发器有如下缺点，设置一个值需要两个输入同时参与，并且具有非法输入。而D 触发器更像一个锁存器，一个输入用于使能写入，一个输入用于设置写入的值。当写入没有被使能时，无论写入的值如何变化，储存的值都不会发生改变。 \\[Q^{n+1}=D\\] EN 决定是否输入为 00 ，D的值决定RS 触发器的输入为 10 还是 01 。 芯片 74xx374 ：8通道D触发器 除了将使能端替换为上跳变触发的时钟输入端外，其余的与 74xx373 一样。 74XX74 ：带置位复位正触发的双D触发器 与 74xx374 不同的是，它既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为D触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 JK 触发器 既可以直接设置触发器的值，又可以在不知道里面值的情况下对值进行翻转。 JK \\(Q^{n+1}\\) \\(\\overline{Q^{n+1}}\\) 00 \\(Q^n\\) \\(\\overline{Q^n}\\) 01 0 1 10 1 0 11 \\(\\overline{Q^n}\\) \\(Q^n\\) 方程为： \\[Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\] 只要JK为1，就会不停地翻转。 电路设计 一个逻辑总是可以写成与或式，因此至少可以用一个JK触发器来表示。首先要画卡诺图，对于每个下一个状态，都要画一张卡诺图。 技巧 在状态表里横着看，从前一个状态确定这一行在很多张卡诺图的位置，然后根据下一个输出结果依次填写到多张卡诺图中。 由于一定要写成\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)，因此要在一个输出（如\\(Q_2^{n+1}\\)）卡诺图中，分成两半： 找到对应输入\\(Q_2^n\\)为1的输入组合，也就是公式中的\\(Q^n\\) 找到对应输入为0的输入，也就是公式中的\\(\\overline{Q^n}\\)，剩下的\\(J,K\\)对应的就是其他引脚的输入。由于JK触发器是与或式，可以不管0的格子。 芯片 74xx112 ：双负沿JK触发器 既可以作为D触发器使用，又可以作为RS 触发器使用或者置位。作为JK触发器用时， R 和 S 端应当使触发器保持不变（由于是低电平有效，因此应当为高电平）。 主从JK触发器 JK 触发器的输入直接影响输出而输出又直接影响输入，导致可能不停翻转。解决办法是使用两个JK触发器（其实是1个JK 触发器和1个带使能端的RS 触发器），主从触发器只能轮流使能，反馈从从触发器引回到主触发器： 主触发器使能（ CP 为 1 ）：接受 JK 的变化，改变主触发器的值。 由于两个输出是互斥的，因此主触发器中RS 触发器的输入要么为 00 （对\\(\\overline S\\)和\\(\\overline R\\)取反），要么为\\(\\overline Q\\)和\\(Q\\)，也就是不变或者翻转。由于输出是一直不变的，因此如果翻转，最多只能翻转一次。 从触发器使能（ CP 为 0 ）：把主触发器的值直接给输出。 因此，只有在CP从1变成0时，输出才会变化。当CP等于1期间，如果JK发生翻转，由于从触发器反馈给主触发器的电平不变，会以第一次翻转为准，而不是CP从1变0那一瞬间的电平。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#触发器"},{"categories":null,"content":"模数混合电路 定时器 NE555 清零端 R 高触发端 THR 低触发端 TR 输出 Q 放电管 DIS 触发器 0 0 0 RESET 1 0 1 保持上一状态 保持上一状态 保持上一状态 1 1 0 保持上一状态 保持上一状态 保持上一状态 1 0 0 1 1 SET 1 1 1 0 0 RESET 1脚：外接电源负端 VSS 一般情况下接地。 8脚：外接电源 VCC 双极型时基电路 VCC 的范围是\\(4.5\\sim 16\\text{V}\\)，CMOS型时基电路VCC的范围为\\(3\\sim 18\\text{V}\\)。一般用\\(5\\text{V}\\)。 3脚：输出端 Q 2脚：低触发端 TR 只接受低电平（\\(0\\sim \\frac{V_\\mathrm{CC}}{3}\\)）。 6脚：高触发端 THR 只接受高电平（\\(\\frac{2V_\\mathrm{CC}}{3}\\sim V_\\mathrm{CC}\\)）。 4脚：直接清零端 R 当此端接低电平，则时基电路不工作，此时不论 TR 、 THR 处于何电平，时基电路输出为低电平，该端不用时应接高电平。 5脚：控制电压端 CV 若此端外接电压，则可改变内部两个比较器的基准电压，当该端不用时，应将该端串入一只\\(0.01\\mu\\text{F}\\)电容接地，以防引入干扰。 7脚：放电端 DIS 该端与放电管集电极相连，用做定时器时电容的放电。该引脚与3脚 Q 输出同步，输出电平一致，但不输出电流，只能灌电流了，所以被称为称为虚高。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#模数混合电路"},{"categories":null,"content":"模数混合电路 定时器 NE555 清零端 R 高触发端 THR 低触发端 TR 输出 Q 放电管 DIS 触发器 0 0 0 RESET 1 0 1 保持上一状态 保持上一状态 保持上一状态 1 1 0 保持上一状态 保持上一状态 保持上一状态 1 0 0 1 1 SET 1 1 1 0 0 RESET 1脚：外接电源负端 VSS 一般情况下接地。 8脚：外接电源 VCC 双极型时基电路 VCC 的范围是\\(4.5\\sim 16\\text{V}\\)，CMOS型时基电路VCC的范围为\\(3\\sim 18\\text{V}\\)。一般用\\(5\\text{V}\\)。 3脚：输出端 Q 2脚：低触发端 TR 只接受低电平（\\(0\\sim \\frac{V_\\mathrm{CC}}{3}\\)）。 6脚：高触发端 THR 只接受高电平（\\(\\frac{2V_\\mathrm{CC}}{3}\\sim V_\\mathrm{CC}\\)）。 4脚：直接清零端 R 当此端接低电平，则时基电路不工作，此时不论 TR 、 THR 处于何电平，时基电路输出为低电平，该端不用时应接高电平。 5脚：控制电压端 CV 若此端外接电压，则可改变内部两个比较器的基准电压，当该端不用时，应将该端串入一只\\(0.01\\mu\\text{F}\\)电容接地，以防引入干扰。 7脚：放电端 DIS 该端与放电管集电极相连，用做定时器时电容的放电。该引脚与3脚 Q 输出同步，输出电平一致，但不输出电流，只能灌电流了，所以被称为称为虚高。 ","date":"2022-03-03","objectID":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/:2:4","series":null,"tags":["数字电路"],"title":"数字电路与逻辑设计","uri":"/posts/notes/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/#定时器"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/bash/:0:0","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#"},{"categories":null,"content":"变量 NAME=\"Bash\" echo $NAME echo \"Hello $NAME\" echo \"Hello ${NAME}ing\" ","date":"2022-03-02","objectID":"/posts/notes/bash/:1:0","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#变量"},{"categories":null,"content":"函数 get_name() { echo \"John\" } echo \"You are $(get_name)\" ","date":"2022-03-02","objectID":"/posts/notes/bash/:2:0","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#函数"},{"categories":null,"content":"条件 if [[ X \u0026\u0026 Y ]]; then ... fi [[ ! EXPR ]] ：非 [[ X \u0026\u0026 Y ]] ：与 [[ X || Y ]] ：或 ","date":"2022-03-02","objectID":"/posts/notes/bash/:3:0","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#条件"},{"categories":null,"content":"常用条件语句 条件语句 含义 [[ -z STRING ]] 字符串是否为空 [[ -n STRING ]] 字符串是否非空 [[ STRING == STRING ]] 字符串是否相等 [[ STRING != STRING ]] 字符串是否不相等 [[ NUM -eq NUM ]] 数值相等 [[ NUM -ne NUM ]] 数值不相等 [[ NUM -lt NUM ]] 数值小于 [[ NUM -le NUM ]] 数值小于等于 [[ NUM -gt NUM ]] 数值大于 [[ NUM -ge NUM ]] 数值大于等于 [[ STRING = ~ STRING ]] 字符串是否匹配正则表达式 ","date":"2022-03-02","objectID":"/posts/notes/bash/:3:1","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#常用条件语句"},{"categories":null,"content":"文件条件语句 条件 含义 [[ -e FILE ]] 存在 [[ -r FILE ]] 可读 [[ -h FILE ]] 是否为符号链接 [[ -d FILE ]] 是否为文件夹 [[ -w FILE ]] 可写 [[ -s FILE ]] 文件是否大于0字节 [[ -f FILE ]] 是否为文件 [[ -x FILE ]] 是否为可执行文件 [[ FILE1 -nt FILE2 ]] 文件1是否比文件2更晚访问 [[ FILE1 -ot FILE2 ]] 文件2是否比文件1更晚访问 [[ FILE1 -ef FILE2 ]] 是否为相同文件 ","date":"2022-03-02","objectID":"/posts/notes/bash/:3:2","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#文件条件语句"},{"categories":null,"content":"循环 ","date":"2022-03-02","objectID":"/posts/notes/bash/:4:0","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#循环"},{"categories":null,"content":"for 循环 for i in /etc/*.d; do echo $i done for ((i = 0 ; i \u003c 100 ; i++)); do echo $i done for i in {5..50..8}; do echo \"Welcome $i\" done ","date":"2022-03-02","objectID":"/posts/notes/bash/:4:1","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#for-循环"},{"categories":null,"content":"while 循环 while true; do ··· done ","date":"2022-03-02","objectID":"/posts/notes/bash/:4:2","series":null,"tags":["编程语言","GNU/Linux"],"title":"Bash","uri":"/posts/notes/bash/#while-循环"},{"categories":null,"content":"类型系统 没有强类型系统，在运行时检查类型。 在Elisp中， 断言类型的函数通常以 p 结尾。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:1:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#类型系统"},{"categories":null,"content":"求值 自求值 例如字符串、数字。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:1:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#求值"},{"categories":null,"content":"求值 自求值 例如字符串、数字。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:1:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#自求值"},{"categories":null,"content":"运行 把光标放在函数、宏里，键入 M-C-x 。 把光标放在最后一个闭合的括号后，键入 C-x C-e 。 M-: 或 M-x eval-expression 。 M-x eval-buffer 。 M-x eshell 。 M-x ielm 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:2:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#运行"},{"categories":null,"content":"注释 (+ 1 1) ; I am a comment ","date":"2022-03-02","objectID":"/posts/notes/elisp/:3:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#注释"},{"categories":null,"content":"基本数据类型 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#基本数据类型"},{"categories":null,"content":"字符串 字符串使用双引号包裹。 \"He's said: \\\"Emacs Rules\\\" one time too many.\" 一个字符串中一个包括多行。 \"Oh Argentina! Your little tin of pink meat Soars o'er the Pampas\" ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#字符串"},{"categories":null,"content":"字符 ?x 代表 x 的ASCII字符（ ?a 代表ASCII码为97的’a’）。涉及到Elisp语法的字符需要转义（ ?\\( 、 ?\\) 、 ?\\\\ ）。Unicode字符不在讨论的范畴。这些的字符在内部的表示均为ASCII码（整数），因此可以对它们进行数学运算。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#字符"},{"categories":null,"content":"数字 整数 整数的精度为 29-bit 。 十进制： -32, 0, 157 二进制（以 #b 为前缀）： #b10010110 八进制（以 #o 为前缀）： #o377 十六进制（以 #x 为前缀）： #xDEADBEE 浮点数 浮点数的精度为 64-bit 。 一般表示： -10.005 、 0.0 、 3.14159265 科学计数法： 6.02e23 、 5e-10 大数 使用 calc 库。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#数字"},{"categories":null,"content":"数字 整数 整数的精度为 29-bit 。 十进制： -32, 0, 157 二进制（以 #b 为前缀）： #b10010110 八进制（以 #o 为前缀）： #o377 十六进制（以 #x 为前缀）： #xDEADBEE 浮点数 浮点数的精度为 64-bit 。 一般表示： -10.005 、 0.0 、 3.14159265 科学计数法： 6.02e23 、 5e-10 大数 使用 calc 库。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#整数"},{"categories":null,"content":"数字 整数 整数的精度为 29-bit 。 十进制： -32, 0, 157 二进制（以 #b 为前缀）： #b10010110 八进制（以 #o 为前缀）： #o377 十六进制（以 #x 为前缀）： #xDEADBEE 浮点数 浮点数的精度为 64-bit 。 一般表示： -10.005 、 0.0 、 3.14159265 科学计数法： 6.02e23 、 5e-10 大数 使用 calc 库。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#浮点数"},{"categories":null,"content":"数字 整数 整数的精度为 29-bit 。 十进制： -32, 0, 157 二进制（以 #b 为前缀）： #b10010110 八进制（以 #o 为前缀）： #o377 十六进制（以 #x 为前缀）： #xDEADBEE 浮点数 浮点数的精度为 64-bit 。 一般表示： -10.005 、 0.0 、 3.14159265 科学计数法： 6.02e23 、 5e-10 大数 使用 calc 库。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#大数"},{"categories":null,"content":"布尔值 真： t （在逻辑运算中所有非假值均会当成真） 假： nil 或者 '() ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#布尔值"},{"categories":null,"content":"符号 quote (quote (a b c)) ：用于构建列表，和 alist 的区别是它把列表元素当作符号常量，不进行求值。 (quote a) ：创建一个符号常量，不进行求值。对于本来就不是自求值的对象是没有意义的。 ' 是 quote 表达式的语法糖。 'a 与 (quote a) 等价。 ` （反引号） 和 ' 基本一致。但是在构建列表是，对于跟在 , 后面的元素会进行求值。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:5","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#符号"},{"categories":null,"content":"符号 quote (quote (a b c)) ：用于构建列表，和 alist 的区别是它把列表元素当作符号常量，不进行求值。 (quote a) ：创建一个符号常量，不进行求值。对于本来就不是自求值的对象是没有意义的。 ' 是 quote 表达式的语法糖。 'a 与 (quote a) 等价。 ` （反引号） 和 ' 基本一致。但是在构建列表是，对于跟在 , 后面的元素会进行求值。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:5","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#quote"},{"categories":null,"content":"符号 quote (quote (a b c)) ：用于构建列表，和 alist 的区别是它把列表元素当作符号常量，不进行求值。 (quote a) ：创建一个符号常量，不进行求值。对于本来就不是自求值的对象是没有意义的。 ' 是 quote 表达式的语法糖。 'a 与 (quote a) 等价。 ` （反引号） 和 ' 基本一致。但是在构建列表是，对于跟在 , 后面的元素会进行求值。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:5","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#310c6e"},{"categories":null,"content":"符号 quote (quote (a b c)) ：用于构建列表，和 alist 的区别是它把列表元素当作符号常量，不进行求值。 (quote a) ：创建一个符号常量，不进行求值。对于本来就不是自求值的对象是没有意义的。 ' 是 quote 表达式的语法糖。 'a 与 (quote a) 等价。 ` （反引号） 和 ' 基本一致。但是在构建列表是，对于跟在 , 后面的元素会进行求值。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:4:5","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#反引号"},{"categories":null,"content":"容器 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#容器"},{"categories":null,"content":"数组（Vector） 使用 [] 来初始化。 [-2 0 2 4 6 8 10] [\"No\" \"Sir\" \"I\" \"am\" \"a\" \"real\" \"horse\"] 数组可以嵌套，也可以包含不同类型的元素。 [\"hi\" 22 120 89.6 2748 [3 \"a\"]] 也可以使用 make-vector 来创建数组。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#数组-vector"},{"categories":null,"content":"列表（List） Elisp中大量使用链表（Linked List），因此有语法来直接创建它，但本质上还是通过函数调用来创建链表的。 直接声明列表的元素： (quote (1 2 3)) 或简写成 '(1 2 3) 使用函数创建有规则的列表： (list 1 (+ 1 1) 3) 或简写成 `(1 ,(+ 1 1) 3) mapcar 对 sequence 使用 function 进行映射。 mapcan 对 sequence 使用 function 进行映射，并进行 flatten 操作。 dash.el 库 (defun -flatmap (fn list) (pcase list (`nil nil) (_ (-concat (apply fn (list (-first-item list))) (-flatmap fn (cdr list)))))) remove 返回删除元素后的新列表。 delete 有副作用（原地）删除一个元素。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#列表-list"},{"categories":null,"content":"列表（List） Elisp中大量使用链表（Linked List），因此有语法来直接创建它，但本质上还是通过函数调用来创建链表的。 直接声明列表的元素： (quote (1 2 3)) 或简写成 '(1 2 3) 使用函数创建有规则的列表： (list 1 (+ 1 1) 3) 或简写成 `(1 ,(+ 1 1) 3) mapcar 对 sequence 使用 function 进行映射。 mapcan 对 sequence 使用 function 进行映射，并进行 flatten 操作。 dash.el 库 (defun -flatmap (fn list) (pcase list (`nil nil) (_ (-concat (apply fn (list (-first-item list))) (-flatmap fn (cdr list)))))) remove 返回删除元素后的新列表。 delete 有副作用（原地）删除一个元素。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#mapcar"},{"categories":null,"content":"列表（List） Elisp中大量使用链表（Linked List），因此有语法来直接创建它，但本质上还是通过函数调用来创建链表的。 直接声明列表的元素： (quote (1 2 3)) 或简写成 '(1 2 3) 使用函数创建有规则的列表： (list 1 (+ 1 1) 3) 或简写成 `(1 ,(+ 1 1) 3) mapcar 对 sequence 使用 function 进行映射。 mapcan 对 sequence 使用 function 进行映射，并进行 flatten 操作。 dash.el 库 (defun -flatmap (fn list) (pcase list (`nil nil) (_ (-concat (apply fn (list (-first-item list))) (-flatmap fn (cdr list)))))) remove 返回删除元素后的新列表。 delete 有副作用（原地）删除一个元素。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#mapcan"},{"categories":null,"content":"列表（List） Elisp中大量使用链表（Linked List），因此有语法来直接创建它，但本质上还是通过函数调用来创建链表的。 直接声明列表的元素： (quote (1 2 3)) 或简写成 '(1 2 3) 使用函数创建有规则的列表： (list 1 (+ 1 1) 3) 或简写成 `(1 ,(+ 1 1) 3) mapcar 对 sequence 使用 function 进行映射。 mapcan 对 sequence 使用 function 进行映射，并进行 flatten 操作。 dash.el 库 (defun -flatmap (fn list) (pcase list (`nil nil) (_ (-concat (apply fn (list (-first-item list))) (-flatmap fn (cdr list)))))) remove 返回删除元素后的新列表。 delete 有副作用（原地）删除一个元素。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#dash-dot-el-库"},{"categories":null,"content":"列表（List） Elisp中大量使用链表（Linked List），因此有语法来直接创建它，但本质上还是通过函数调用来创建链表的。 直接声明列表的元素： (quote (1 2 3)) 或简写成 '(1 2 3) 使用函数创建有规则的列表： (list 1 (+ 1 1) 3) 或简写成 `(1 ,(+ 1 1) 3) mapcar 对 sequence 使用 function 进行映射。 mapcan 对 sequence 使用 function 进行映射，并进行 flatten 操作。 dash.el 库 (defun -flatmap (fn list) (pcase list (`nil nil) (_ (-concat (apply fn (list (-first-item list))) (-flatmap fn (cdr list)))))) remove 返回删除元素后的新列表。 delete 有副作用（原地）删除一个元素。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#remove"},{"categories":null,"content":"列表（List） Elisp中大量使用链表（Linked List），因此有语法来直接创建它，但本质上还是通过函数调用来创建链表的。 直接声明列表的元素： (quote (1 2 3)) 或简写成 '(1 2 3) 使用函数创建有规则的列表： (list 1 (+ 1 1) 3) 或简写成 `(1 ,(+ 1 1) 3) mapcar 对 sequence 使用 function 进行映射。 mapcan 对 sequence 使用 function 进行映射，并进行 flatten 操作。 dash.el 库 (defun -flatmap (fn list) (pcase list (`nil nil) (_ (-concat (apply fn (list (-first-item list))) (-flatmap fn (cdr list)))))) remove 返回删除元素后的新列表。 delete 有副作用（原地）删除一个元素。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#delete"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#二元组-pair"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#cons"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#car"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#cdr"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#append"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#nconc"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#reverse"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#push"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#pop"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#butlast"},{"categories":null,"content":"二元组（Pair） 列表的节点。 cons 创建一个二元组。 (cons 1 2) 或简写成 '(1 . 2) 创建链表：创建列表节点。 (list 1 2 3) 等价于 (cons 1 (cons 2 (cons 3 nil))) 。 列表前面添加元素： (let ((foo '(2 3))) (cons 1 foo)) car 获取 cons 的前一个元素。 cdr 获取 cons 的后一个元素。 append 拼接多个列表，返回一个新的列表。 nconc 拼接多个列表到第一个列表上，返回第一个列表。 reverse 翻转列表。 push 添加元素到传入列表上，返回这个列表。 pop 移除并返回列表的第一个元素。 butlast 除去 list 除了最后 n 个元素，返回一个新的列表。 butlast 除去 list 除了最后 n 个元素，返回 list 。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#butlast"},{"categories":null,"content":"关联表（Associative List） 就是二元组（Pair）的列表（List）。 '( (apple . \"red\") (banana . \"yellow\") (orange . \"orange\") ) assoc 通过键查找键对。 rassoc 通过值查找键对。 assoc-delete-all 删除所有以 key 为键的元素，使用 equal 函数进行比较。虽然这个函数是有副作用的，但是其返回值为修改后的列表是有意义的。比如下面的代码无法达到预期的效果。 (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (assoc-delete-all \"a\" my-alist) (print my-alist) (assoc-delete-all \"b\" my-alist) (print my-alist) (assoc-delete-all \"c\" my-alist) (print my-alist)) 而是应当： (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (setf my-alist (assoc-delete-all \"a\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"b\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"c\" my-alist)) (print my-alist)) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#关联表-associative-list"},{"categories":null,"content":"关联表（Associative List） 就是二元组（Pair）的列表（List）。 '( (apple . \"red\") (banana . \"yellow\") (orange . \"orange\") ) assoc 通过键查找键对。 rassoc 通过值查找键对。 assoc-delete-all 删除所有以 key 为键的元素，使用 equal 函数进行比较。虽然这个函数是有副作用的，但是其返回值为修改后的列表是有意义的。比如下面的代码无法达到预期的效果。 (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (assoc-delete-all \"a\" my-alist) (print my-alist) (assoc-delete-all \"b\" my-alist) (print my-alist) (assoc-delete-all \"c\" my-alist) (print my-alist)) 而是应当： (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (setf my-alist (assoc-delete-all \"a\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"b\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"c\" my-alist)) (print my-alist)) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#assoc"},{"categories":null,"content":"关联表（Associative List） 就是二元组（Pair）的列表（List）。 '( (apple . \"red\") (banana . \"yellow\") (orange . \"orange\") ) assoc 通过键查找键对。 rassoc 通过值查找键对。 assoc-delete-all 删除所有以 key 为键的元素，使用 equal 函数进行比较。虽然这个函数是有副作用的，但是其返回值为修改后的列表是有意义的。比如下面的代码无法达到预期的效果。 (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (assoc-delete-all \"a\" my-alist) (print my-alist) (assoc-delete-all \"b\" my-alist) (print my-alist) (assoc-delete-all \"c\" my-alist) (print my-alist)) 而是应当： (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (setf my-alist (assoc-delete-all \"a\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"b\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"c\" my-alist)) (print my-alist)) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#rassoc"},{"categories":null,"content":"关联表（Associative List） 就是二元组（Pair）的列表（List）。 '( (apple . \"red\") (banana . \"yellow\") (orange . \"orange\") ) assoc 通过键查找键对。 rassoc 通过值查找键对。 assoc-delete-all 删除所有以 key 为键的元素，使用 equal 函数进行比较。虽然这个函数是有副作用的，但是其返回值为修改后的列表是有意义的。比如下面的代码无法达到预期的效果。 (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (assoc-delete-all \"a\" my-alist) (print my-alist) (assoc-delete-all \"b\" my-alist) (print my-alist) (assoc-delete-all \"c\" my-alist) (print my-alist)) 而是应当： (let ((my-alist '((\"a\" . 1) (\"b\" . 2) (\"c\" . 3)))) (setf my-alist (assoc-delete-all \"a\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"b\" my-alist)) (print my-alist) (setf my-alist (assoc-delete-all \"c\" my-alist)) (print my-alist)) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:5:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#assoc-delete-all"},{"categories":null,"content":"运算符 运算符就像函数，进行运算的元素就像函数的参数，因此运算符都是前置的。 (% (* #x15 (+ 8.2 (lsh 7 3))) 2) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:6:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#运算符"},{"categories":null,"content":"相等性 = ：数学上相等 (= 2 (+ 1 1)) /= ：数学上不相等 (/= 2 3) eq ：值相等（整数相等或对象的引用相同） (eq 'foo 2) eql ：浮点数相等（也可以直接使用 = ） (eql (/ 6.28 2) 3.14) equal ：结构相等（Deep Equality） (equal '(1 2 (3 4)) (list 1 2 (list 3 (* 2 2)))) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:6:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#相等性"},{"categories":null,"content":"字符串 concat ：连接若干个字符串 (concat \"foo\" \"bar\" \"baz\") string= ：判断相等（也可以直接使用 equal ） (string= \"foo\" \"baz\") substring ：提取字串 (substring \"foobar\" 0 3) upcase ：全部变为大写 (upcase \"foobar\") ","date":"2022-03-02","objectID":"/posts/notes/elisp/:6:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#字符串"},{"categories":null,"content":"算术 C/Java/JS 运算符 Emacs Lisp 示例 结果 + + (+ 1 2 3 4 5) 15 * * (* 2 -1 4.2) -8.4 / / (/ 10 3) 3 % % (% 10 2) 0 \u003c\u003c lsh (lsh 1 5) 32 \u003e\u003e ash (偏移量取负) (ash -32 -4) -2 \u003e\u003e\u003e lsh (偏移量取负) (lsh 32 -4) 2 ++ incf (需要 'cl 库) (incf x 6) x+6 ? : （三目运算符） (if test-expr then-expr else-expr) (if t 3 4) 3 \u0026\u0026 and (and t t t nil) nil \\vert\\vert or (or nil nil nil t) t ! (逻辑非) not (not 3) nil ~ (按位取反) lognot (lognot #b1001) -10 ^ (按位异或) logxor (logxor 5 3) 6 \u0026 (按位与) logand (logand 1 3) 1 \\vert (按位或) logior (logior 1 3) 3 \u003c \u003c (\u003c 5 3) nil \u003e \u003e (\u003e 5 3) t \u003c= \u003c= (\u003c= 3 3) t \u003e= \u003e= (\u003e= 5 3) t . （字段访问） 参考下面的 setf [] (数组访问) aref/aset (aref [2 4 6] 1) 4 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:6:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#算术"},{"categories":null,"content":"流程控制 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#流程控制"},{"categories":null,"content":"分支 单分支 无 else 分支 (if (\u003e= 3 2) (message \"hello there\")) 有 else 分支 (if (today-is-friday) ; test-expr (message \"yay, friday\") ; then-expr (message \"boo, other day\")) ; else-expr else-if (if 'sunday (message \"sunday!\") ; then-expr (if 'saturday ; else-if (message \"saturday!\") ; next then-expr (message (\"weekday!\")))) ; final else 无 else 分支（无括号的多表达式） when (when (\u003e 5 1) (blah) (blah-blah) (blah blah blah)) unless 除非条件满足，否则就执行语句。 (unless (weekend-p) (message \"another day at work\") (get-back-to-work)) 多分支 Elisp并没有使用跳转表进行优化，因此多分支语句本质上还是多个单分支语句的嵌套。 cond (cond (test-1 ; branch 1 do-stuff-1) (test-2 ; branch 2 do-stuff-2) (t ; default branch do-default-stuff)) 在条件后面可以跟任意数量的语句，不用括号包裹。并且当一个分支只有条件而没有语句时，如果该条件不为 nil 则进入分支直接把条件作为整个表达的值。 case （需要 'cl 库） (case 12 (5 \"five\") (1 \"one\") (12 \"twelve\") (otherwise \"I only know five, one and twelve.\")) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#分支"},{"categories":null,"content":"分支 单分支 无 else 分支 (if (\u003e= 3 2) (message \"hello there\")) 有 else 分支 (if (today-is-friday) ; test-expr (message \"yay, friday\") ; then-expr (message \"boo, other day\")) ; else-expr else-if (if 'sunday (message \"sunday!\") ; then-expr (if 'saturday ; else-if (message \"saturday!\") ; next then-expr (message (\"weekday!\")))) ; final else 无 else 分支（无括号的多表达式） when (when (\u003e 5 1) (blah) (blah-blah) (blah blah blah)) unless 除非条件满足，否则就执行语句。 (unless (weekend-p) (message \"another day at work\") (get-back-to-work)) 多分支 Elisp并没有使用跳转表进行优化，因此多分支语句本质上还是多个单分支语句的嵌套。 cond (cond (test-1 ; branch 1 do-stuff-1) (test-2 ; branch 2 do-stuff-2) (t ; default branch do-default-stuff)) 在条件后面可以跟任意数量的语句，不用括号包裹。并且当一个分支只有条件而没有语句时，如果该条件不为 nil 则进入分支直接把条件作为整个表达的值。 case （需要 'cl 库） (case 12 (5 \"five\") (1 \"one\") (12 \"twelve\") (otherwise \"I only know five, one and twelve.\")) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#单分支"},{"categories":null,"content":"分支 单分支 无 else 分支 (if (\u003e= 3 2) (message \"hello there\")) 有 else 分支 (if (today-is-friday) ; test-expr (message \"yay, friday\") ; then-expr (message \"boo, other day\")) ; else-expr else-if (if 'sunday (message \"sunday!\") ; then-expr (if 'saturday ; else-if (message \"saturday!\") ; next then-expr (message (\"weekday!\")))) ; final else 无 else 分支（无括号的多表达式） when (when (\u003e 5 1) (blah) (blah-blah) (blah blah blah)) unless 除非条件满足，否则就执行语句。 (unless (weekend-p) (message \"another day at work\") (get-back-to-work)) 多分支 Elisp并没有使用跳转表进行优化，因此多分支语句本质上还是多个单分支语句的嵌套。 cond (cond (test-1 ; branch 1 do-stuff-1) (test-2 ; branch 2 do-stuff-2) (t ; default branch do-default-stuff)) 在条件后面可以跟任意数量的语句，不用括号包裹。并且当一个分支只有条件而没有语句时，如果该条件不为 nil 则进入分支直接把条件作为整个表达的值。 case （需要 'cl 库） (case 12 (5 \"five\") (1 \"one\") (12 \"twelve\") (otherwise \"I only know five, one and twelve.\")) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#多分支"},{"categories":null,"content":"循环 while (setq x 10 total 0) (while (plusp x) ; while x is positive (incf total x) ; add x to total (decf x)) ; subtract 1 from x loop （需要 'cl 库） do-while (loop do (setq x (1+ x)) while (\u003c x 10)) for (loop with result = '() ; one-time initialization for i downfrom 10 ; count i down from 10 for j from 0 by 2 ; count j up from 0 by 2 while (\u003c j 10) ; stop when j \u003e= 10 do (push (+ i j) result) ; fast-accumulate i+j finally return (nreverse result)) ; reverse and return result 等价的JavaScript代码 var result = []; for (var i = 10, j = 0; j \u003c= 10; i--, j += 2) { result.push(i + j); } for-in (loop for i in '(1 2 3 4 5 6) collect (* i i)) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#循环"},{"categories":null,"content":"跳转 执行到内层的语句时，可以通过 throw 跳转到外层对应的 catch 后面，达到循环中类似 break 或 continue 关键字的效果，并且可以跨函数跳转。 break (setq x 0 total 0) (catch 'break (while t (incf total x) (if (\u003e (incf x) 10) (throw 'break total)))) continue (setq x 0 total 0) (while (\u003c x 100) (catch 'continue (incf x) (if (zerop (% x 5)) (throw 'continue nil)) (incf total x))) 用于 catch 和 throw 的标识符可以自定义以作区分。 (setq x 0 total 0) (catch 'break (while t (catch 'continue (incf x) (if (\u003e= x 100) (throw 'break nil)) (if (zerop (% x 5)) (throw 'continue nil)) (incf total x)))) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#跳转"},{"categories":null,"content":"模式匹配 pcase 模式 (pred function) 把一个返回布尔值的单参数函数 function 作为模式守卫。进行匹配的时候，会把被匹配的对象作为参数传入 function ，如果返回的值为非 nil ，则匹配成功。 (app function pattern) 对一个单参数函数 function 的返回值再模式匹配。进行匹配的时候，会把被匹配的对象作为参数传入 function ，再把返回值和 pattern 进行匹配和绑定。 (guard boolean-expression) 把一个布尔表达式作为模式守卫。 (let pattern expr) 对 expr 进行求值，然后把结果和 pattern 进行匹配和绑定。 序列模式 合并多种模式进行匹配。 (and pattern1…) 待匹配的对象必须满足多个模式才能匹配成功。 (or pattern1 pattern2…) 待匹配的对象只要满足其中一个模式即可匹配成功。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#模式匹配"},{"categories":null,"content":"模式匹配 pcase 模式 (pred function) 把一个返回布尔值的单参数函数 function 作为模式守卫。进行匹配的时候，会把被匹配的对象作为参数传入 function ，如果返回的值为非 nil ，则匹配成功。 (app function pattern) 对一个单参数函数 function 的返回值再模式匹配。进行匹配的时候，会把被匹配的对象作为参数传入 function ，再把返回值和 pattern 进行匹配和绑定。 (guard boolean-expression) 把一个布尔表达式作为模式守卫。 (let pattern expr) 对 expr 进行求值，然后把结果和 pattern 进行匹配和绑定。 序列模式 合并多种模式进行匹配。 (and pattern1…) 待匹配的对象必须满足多个模式才能匹配成功。 (or pattern1 pattern2…) 待匹配的对象只要满足其中一个模式即可匹配成功。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:7:4","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#pcase"},{"categories":null,"content":"函数 使用 defun 来定义一个函数。函数参数后面跟着字符串作为函数的说明，可以用 M-x describe-function 来查看。 有参数 (defun square (x) \"Return X squared.\" (* x x)) 无参数 (defun hello () \"Print the string `hello' to the minibuffer.\" (message \"hello!\")) 函数体可以有任意个表达式，以最后一个表达式作为返回值。也可以手动使用 return 表达式来返回。 如果要定义一个可以通过 M-x 调用的函数，需要以 (interactive) 作为函数的第一个表达式。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:8:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#函数"},{"categories":null,"content":"Lambda表达式 (lambda (x) \"Return the hyperbolic cosine of X.\" (* 0.5 (+ (exp x) (exp (- x))))) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:8:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#lambda表达式"},{"categories":null,"content":"常用函数 save-excursion 保存当前缓冲区和光标的位置，执行 BODY ，然后恢复缓冲区和光标。 funcall 调用指定函数。多参数的情况下可以省略括号。 apply 调用指定函数。最后一个参数是一个列表，作为传入调用函数的参数列表。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:8:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#常用函数"},{"categories":null,"content":"常用函数 save-excursion 保存当前缓冲区和光标的位置，执行 BODY ，然后恢复缓冲区和光标。 funcall 调用指定函数。多参数的情况下可以省略括号。 apply 调用指定函数。最后一个参数是一个列表，作为传入调用函数的参数列表。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:8:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#save-excursion"},{"categories":null,"content":"常用函数 save-excursion 保存当前缓冲区和光标的位置，执行 BODY ，然后恢复缓冲区和光标。 funcall 调用指定函数。多参数的情况下可以省略括号。 apply 调用指定函数。最后一个参数是一个列表，作为传入调用函数的参数列表。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:8:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#funcall"},{"categories":null,"content":"常用函数 save-excursion 保存当前缓冲区和光标的位置，执行 BODY ，然后恢复缓冲区和光标。 funcall 调用指定函数。多参数的情况下可以省略括号。 apply 调用指定函数。最后一个参数是一个列表，作为传入调用函数的参数列表。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:8:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#apply"},{"categories":null,"content":"变量 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#变量"},{"categories":null,"content":"本地变量 使用 let 表达式来声明本地变量。可以不指定初始值。 (let ((name1 value1) (name2 value2) name3 name4 (name5 value5))) 如果在一个 let 表达式里后面定义的变量需要用到前面定义的变量，需要使用 let* 。 (let* ((x 1) (y x))) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#本地变量"},{"categories":null,"content":"全局变量 声明 可变量 使用 defvar 来声明一个变量。最后的字符串代表的是该变量的说明文档。第二次定义相同的变量的时候，不会进行赋值操作。 (defvar i 1 \"This is a variable.\") 常量 使用 defconst 来声明一个常量。最后的字符串代表的是该常量的说明文档。 (defconst pi 3.14159 \"A gross approximation of pi.\") 修改 使用 setf 来原地修改一个值。 (let ((list '(1 2 3 4))) (setf (nth 0 list) 0) list) 设置 使用 setq （“set quote”的缩写）来声明全局变量。 (setq foo \"bar\") ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#全局变量"},{"categories":null,"content":"全局变量 声明 可变量 使用 defvar 来声明一个变量。最后的字符串代表的是该变量的说明文档。第二次定义相同的变量的时候，不会进行赋值操作。 (defvar i 1 \"This is a variable.\") 常量 使用 defconst 来声明一个常量。最后的字符串代表的是该常量的说明文档。 (defconst pi 3.14159 \"A gross approximation of pi.\") 修改 使用 setf 来原地修改一个值。 (let ((list '(1 2 3 4))) (setf (nth 0 list) 0) list) 设置 使用 setq （“set quote”的缩写）来声明全局变量。 (setq foo \"bar\") ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#声明"},{"categories":null,"content":"全局变量 声明 可变量 使用 defvar 来声明一个变量。最后的字符串代表的是该变量的说明文档。第二次定义相同的变量的时候，不会进行赋值操作。 (defvar i 1 \"This is a variable.\") 常量 使用 defconst 来声明一个常量。最后的字符串代表的是该常量的说明文档。 (defconst pi 3.14159 \"A gross approximation of pi.\") 修改 使用 setf 来原地修改一个值。 (let ((list '(1 2 3 4))) (setf (nth 0 list) 0) list) 设置 使用 setq （“set quote”的缩写）来声明全局变量。 (setq foo \"bar\") ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#修改"},{"categories":null,"content":"全局变量 声明 可变量 使用 defvar 来声明一个变量。最后的字符串代表的是该变量的说明文档。第二次定义相同的变量的时候，不会进行赋值操作。 (defvar i 1 \"This is a variable.\") 常量 使用 defconst 来声明一个常量。最后的字符串代表的是该常量的说明文档。 (defconst pi 3.14159 \"A gross approximation of pi.\") 修改 使用 setf 来原地修改一个值。 (let ((list '(1 2 3 4))) (setf (nth 0 list) 0) list) 设置 使用 setq （“set quote”的缩写）来声明全局变量。 (setq foo \"bar\") ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:2","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#设置"},{"categories":null,"content":"动态作用域 C++有引用类型，因此可以在函数中修改函数调用方中的值。Elisp中的动态作用域也可以实现类似的功能。 (defun foo () (let ((x 6)) ; define a local (i.e., stack) variable x initialized to 6 (bar) ; call bar x)) ; return x (defun bar () (setq x 7)) ; finds and modifies x in the caller's stack frame (foo) ","date":"2022-03-02","objectID":"/posts/notes/elisp/:9:3","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#动态作用域"},{"categories":null,"content":"异常 condition-case 实现类似 try-catch 的异常处理。 (condition-case nil (progn ; try (do-something) (do-something-else)) (error ; catch (message \"oh no!\") (do-recovery-stuff))) progn 用于多个表达式的执行。 ignore-errors 实现空 catch 块的异常捕获。在Emacs的启动配置文件中比较有用，可以在部分代码执行出错的情况下继续执行配置文件。 (ignore-errors (do-something) (do-something-else)) unwind-protect 实现类似空 catch 块的 try-catch-finally 的功能。 (unwind-protect (progn ; try (do-something) (do-something-else)) (first-finally-expr) ; finally (second-finally-expr)) 把它与 condition-case 进行结合，就可以实现完整的 try-catch-finally 的功能。 (unwind-protect ; finally (condition-case nil ; try (progn ; { (do-something) ; body-1 (do-something-else)) ; body-2 } (error ; catch (message \"oh no!\") ; { catch 1 (poop-pants))) ; catch 2 } (first-finally-expr) ; { finally 1 (second-finally-expr)) ; finally 2 } ","date":"2022-03-02","objectID":"/posts/notes/elisp/:10:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#异常"},{"categories":null,"content":"抽象 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:11:0","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#抽象"},{"categories":null,"content":"面向对象 封装 Elisp不是一门面向对象的语言，但 'cl 包提供了部分面向对象的功能。使用 defstruct 定义一个结构体。 (require 'cl) ; top of file (defstruct person \"A person structure.\" name (age 0) (height 0.0)) 使用 make-\u003c结构体名\u003e 来创建结构体。 (make-person) ; new Person() (make-person :age 39) ; new Person(39) (make-person :name \"Steve\" :height 5.83 :age 39) ; new Person(\"Steve\", 39, 5.83) 使用 \u003c结构体名-成员变量名\u003e 来访问结构体中的成员变量。使用 setf 来设置成员变量。 (setq e (make-employee)) (setf (employee-name e) \"Steve\" (employee-age e) 39 (employee-company e) \"Google\" (employee-title e) \"Janitor\") 继承 可以使用单继承来扩展一个结构体。 (defstruct (employee (:include person)) \"An employee structure.\" company (level 1) (title \"n00b\")) defstruct 宏会自动生成 \u003c结构体名\u003e-p 的函数用于判断一个变量是不是该结构体类型。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:11:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#面向对象"},{"categories":null,"content":"面向对象 封装 Elisp不是一门面向对象的语言，但 'cl 包提供了部分面向对象的功能。使用 defstruct 定义一个结构体。 (require 'cl) ; top of file (defstruct person \"A person structure.\" name (age 0) (height 0.0)) 使用 make-\u003c结构体名\u003e 来创建结构体。 (make-person) ; new Person() (make-person :age 39) ; new Person(39) (make-person :name \"Steve\" :height 5.83 :age 39) ; new Person(\"Steve\", 39, 5.83) 使用 \u003c结构体名-成员变量名\u003e 来访问结构体中的成员变量。使用 setf 来设置成员变量。 (setq e (make-employee)) (setf (employee-name e) \"Steve\" (employee-age e) 39 (employee-company e) \"Google\" (employee-title e) \"Janitor\") 继承 可以使用单继承来扩展一个结构体。 (defstruct (employee (:include person)) \"An employee structure.\" company (level 1) (title \"n00b\")) defstruct 宏会自动生成 \u003c结构体名\u003e-p 的函数用于判断一个变量是不是该结构体类型。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:11:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#封装"},{"categories":null,"content":"面向对象 封装 Elisp不是一门面向对象的语言，但 'cl 包提供了部分面向对象的功能。使用 defstruct 定义一个结构体。 (require 'cl) ; top of file (defstruct person \"A person structure.\" name (age 0) (height 0.0)) 使用 make-\u003c结构体名\u003e 来创建结构体。 (make-person) ; new Person() (make-person :age 39) ; new Person(39) (make-person :name \"Steve\" :height 5.83 :age 39) ; new Person(\"Steve\", 39, 5.83) 使用 \u003c结构体名-成员变量名\u003e 来访问结构体中的成员变量。使用 setf 来设置成员变量。 (setq e (make-employee)) (setf (employee-name e) \"Steve\" (employee-age e) 39 (employee-company e) \"Google\" (employee-title e) \"Janitor\") 继承 可以使用单继承来扩展一个结构体。 (defstruct (employee (:include person)) \"An employee structure.\" company (level 1) (title \"n00b\")) defstruct 宏会自动生成 \u003c结构体名\u003e-p 的函数用于判断一个变量是不是该结构体类型。 ","date":"2022-03-02","objectID":"/posts/notes/elisp/:11:1","series":null,"tags":["编程语言","Emacs"],"title":"Emacs Lisp","uri":"/posts/notes/elisp/#继承"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:0:0","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#"},{"categories":null,"content":"优点 用户无需关心时间信息：内核负责计时，并由相关的API完成，从而使得用户的应用程序代码结构更简单。 模块化、可拓展性强：也正是由于第一点的原因，程序性能不易受底层硬件更改的影响。并且，各个任务是独立的模块，每个模块都有明确的目的，降低了代码的耦合性。 效率高：内核可以让软件完全由事件驱动，因次，轮询未发生的事件是不浪费时间的。相当于用中断来进行任务切换。 中断进程更短：通过把中断的处理推迟到用户创建的任务中，可以使得中断处理程序非常短。 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:1:0","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#优点"},{"categories":null,"content":"事件驱动 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:1:1","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#事件驱动"},{"categories":null,"content":"功能 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:0","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#功能"},{"categories":null,"content":"时间管理 延时函数 相对延时函数 vTaskDelay() ：延时的时间是从调用时开始计算的，如果调用该函数的任务执行耗时操作，则不能保证以延时的时间为周期执行任务。 void vTaskDelay(portTickType xTicksToDelay); xTicksToDelay ：延时时间总数，单位是系统时钟节拍周期。 用法： void task(void *pvParameters) { const portTickType xDelay = pdMS_TO_TICKS(1000); for( ;; ) { /****************/ /* 任务主体代码 */ /****************/ vTaskDelay(xDelay); } } 绝对延时函数 vTaskDelayUntil() ：保证每次调用该函数的周期为指定延迟的时长。 void vTaskDelayUntil(TickType_t *pxPreviousWakeTime, const TickType_txTimeIncrement); pxPreviousWakeTime ：指向一个变量的 指针 ，该变量保存任务最后一次解除阻塞的时间。第一次使用前，该变量必须初始化为当前时间。之后这个变量会在 vTaskDelayUntil() 函数内 自动更新 。 xTimeIncrement ：周期循环时间。当时间等于 (*pxPreviousWakeTime + xTimeIncrement) 时，任务解除阻塞。如果不改变参数 xTimeIncrement 的值，调用该函数的任务会按照固定频率执行。 用法： void task(void *pvParameters) { static portTickType xLastWakeTime; //注意是静态变量，只会被初始化一次 const portTickType xDelay = pdMS_TO_TICKS(1000); xLastWakeTime = xTaskGetTickCount(); for( ;; ) { vTaskDelayUntil(\u0026xLastWakeTime, xDelay); //注意取地址 /****************/ /* 任务主体代码 */ /****************/ } } ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:1","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#时间管理"},{"categories":null,"content":"时间管理 延时函数 相对延时函数 vTaskDelay() ：延时的时间是从调用时开始计算的，如果调用该函数的任务执行耗时操作，则不能保证以延时的时间为周期执行任务。 void vTaskDelay(portTickType xTicksToDelay); xTicksToDelay ：延时时间总数，单位是系统时钟节拍周期。 用法： void task(void *pvParameters) { const portTickType xDelay = pdMS_TO_TICKS(1000); for( ;; ) { /****************/ /* 任务主体代码 */ /****************/ vTaskDelay(xDelay); } } 绝对延时函数 vTaskDelayUntil() ：保证每次调用该函数的周期为指定延迟的时长。 void vTaskDelayUntil(TickType_t *pxPreviousWakeTime, const TickType_txTimeIncrement); pxPreviousWakeTime ：指向一个变量的 指针 ，该变量保存任务最后一次解除阻塞的时间。第一次使用前，该变量必须初始化为当前时间。之后这个变量会在 vTaskDelayUntil() 函数内 自动更新 。 xTimeIncrement ：周期循环时间。当时间等于 (*pxPreviousWakeTime + xTimeIncrement) 时，任务解除阻塞。如果不改变参数 xTimeIncrement 的值，调用该函数的任务会按照固定频率执行。 用法： void task(void *pvParameters) { static portTickType xLastWakeTime; //注意是静态变量，只会被初始化一次 const portTickType xDelay = pdMS_TO_TICKS(1000); xLastWakeTime = xTaskGetTickCount(); for( ;; ) { vTaskDelayUntil(\u0026xLastWakeTime, xDelay); //注意取地址 /****************/ /* 任务主体代码 */ /****************/ } } ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:1","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#延时函数"},{"categories":null,"content":"内存管理 C文件 优点 缺点 heap1.c 分配简单、时间确定 只分配，不回收 heap2.c 动态分配、最佳匹配 碎片、时间不定 heap3.c 调用标准库函数 速度慢、时间不定 heap4.c 相邻空闲内存合并 碎片、合并效率低 heap5.c 跨非连续内存区域 碎片、合并效率低 heap1.c ：这是所有实现中最简单的一个。一旦分配内存之后，它甚至不允许释放分配的内存。因为大多数深度嵌入式应用只是在系统启动时创建所有任务、队列、信号量等，并且直到程序结束都会一直使用它们，永远不需要删除。 函数/定义 #define configTOTAL_HEAP_SIZE ：总的可分配堆内存大小。 xPortGetFreeHeapSize() ：返回未分配的堆堆内存大小。 特点 用于从不会删除任务、队列、信号量、互斥量等的应用程序（实际上大多数使用FreeRTOS的应用程序都符合这个条件） 执行时间是确定的并且不会产生内存碎片 实现和分配过程非常简单，需要的内存是从一个静态数组中分配的，意味着这种内存分配通常只是适用于那些不进行动态内存分配的应用。 heap2.c ：使用最佳匹配算法，它允许释放之前分配的内存块。它不会把相邻的空闲块合成一个更大的块，导致可能无法继续分配连续的内存。 特点 可以用于重复的分配和删除具有相同堆栈空间的任务、队列、信号量、互斥量等等，并且不考虑内存碎片的应用程序。 不能用在分配和释放随机字节堆栈空间的应用程序。 如果一个应用程序动态的创建和删除任务，并且分配给任务的堆栈空间总是 同样大小 ，那么大多数情况下可以使用。 应用程序直接调用 pvPortMalloc() 和 vPortFree() 函数，而不仅是通过FreeRTOS API间接调用。 如果你的应用程序中的队列、任务、信号量、互斥量等等处在一个不可预料的顺序，则可能会导致内存碎片问题，虽然这是小概率事件，但必须牢记。 不具有确定性，但是它比标准库中的malloc函数具有高得多的效率。 heap3.c ：简单的包装了标准库中的 malloc() 和 free() 函数，并且确保线程安全。由于内存由C标准库提供的函数进行分配和释放， configTOTAL_HEAP_SIZE 将不起作用。 特点 需要链接器设置一个堆栈，并且编译器库提供 malloc() 和 free() 函数。 不具有确定性。 可能明显的增大RTOS内核的代码大小。 heap4.c ：使用一个最佳匹配算法，但不像 heap2.c 那样。它会将相邻的空闲内存块合并成一个更大的块（包含一个合并算法）。 特点 可用于重复分配、删除任务、队列、信号量、互斥量等等的应用程序。 可以用于分配和释放随机字节内存的情况，并不像 heap_2.c 那样产生严重碎片。 不具有确定性，但是它比标准库中的 malloc() 函数具有高得多的效率。 也可以通过调用 pvPortMalloc() 和 vPortFree() 函数来分配和释放内存。 heap5.c ：同样实现了 heap_4.c 中的合并算法，并且允许堆栈跨越多个非连续的内存区（如外挂SRAM）。 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:2","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#内存管理"},{"categories":null,"content":"任务管理 任务 定义 void vATaskFunction(void *pvParameters) { for( ;; ) { /****************/ /* 任务主体代码 */ /****************/ } vTaskDelete(NULL); //如果要退出任务都必须要调用该函数，而不能直接返回 } 创建 xTaskCreate() BaseType_t xTaskCreate(TaskFunction_t pvTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t * pvCreatedTask); pvTaskCode ：指向任务函数的入口的指针。任务永远不会返回（位于死循环内）。 pcName ：任务描述。主要用于调试。字符串的最大长度由宏 configMAX_TASK_NAME_LEN 指定。 usStackDepth ：指定任务堆栈大小，能够支持的堆栈变量数量，而不是字节数。 pvParameters ：当任务创建时，传递给任务的参数。 uxPriority ：任务的优先级具 pvCreatedTask ：用于回传一个句柄，用于引用任务。 删除 vTaskDelete() void vTaskDelete(TaskHandle_t xTask); xTask ： 任务句柄 NULL ：删除当前任务。 挂起使任务进入挂起态。要使用挂起功能，必须将宏 INCLUDE_vTaskSuspend 设置为 1 。 vTaskSuspend void vTaskSuspend(TaskHandle_t xTaskToSuspend); xTaskxTaskToSuspend ： 任务句柄 NULL ：挂起当前任务。 恢复使任务从挂起态恢复。 vTaskResume void vTaskResume(TaskHandle_tx TaskToResume); xTaskToResume ：要恢复运行的任务句柄 xTaskResumeFromISR BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume); xTaskToResume ：要恢复运行的任务句柄 切换 不使用 vTaskDelay() 和 vTaskDelayUntil() ：在SysTick中断中切换任务。 使用 vTaskDelay() ：不用等到 SysTick 中断后才切换到下一个任务，更加高效 使用 vTaskDelayUntil() ：和 vTaskDelay() 类似，是绝对的延时可以保证执行的周期。 状态 运行： 如果一个任务正在执行，那么说这个任务处于运行状态。此时它占用处理器。 就绪： 就绪的任务已经具备执行的能力（将要执行，不同于阻塞和挂起），但是因为有一个同优先级或者更高优先级的任务处于运行状态而还没有真正执行。对于空闲任务来说，它一直都处于就绪态，只有当其他优先级比它高的任务，都执行完了，都在阻塞态里，空闲任务才会执行。 阻塞： 如果任务当前正在等待某个时序或外部中断，我们就说这个任务处于阻塞状态。比如一个任务调用 vTaskDelay() 后会阻塞到延时周期到为止。任务也可能阻塞在队列或信号量事件上。进入阻塞状态的任务通常有一个“超时”周期，当事件超时后解除阻塞。 挂起： 处于挂起状态的任务同样对调度器无效。仅当明确的分别调用 vTaskSuspend() 和 xTaskResume() API函数后，任务才会进入或退出挂起状态。不可以指定超时周期事件（不可以通过设定超时事件而退出挂起状态） 任务优先级 同时处于就绪状态的任务被执行的优先级。多个任务也可以有相同的优先级。 获取 uxTaskPriorityGet UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask); xTask ：要设置优先级任务的句柄。 NULL ：表示设置当前运行的任务。 设置 vTaskPrioritySet void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority); xTask ：要设置优先级任务的句柄。 NULL ：表示设置当前运行的任务。 uxNewPriority ：要设置的新优先级。 空闲任务 空闲任务是启动RTOS调度器时由内核自动创建的任务，这样可以确保至少有一个任务在运行。 功能：释放RTOS分配给被删除任务的内存。 空闲优先级 空闲任务具有最低任务优先级，这样如果有其它更高优先级的任务进入就绪态就可以立刻让出CPU。其他任务也可以以该优先级进行创建。 空闲任务钩子 让程序运行在空闲任务上。（注意不能调用任何可能造成阻塞的函数） 步骤 在 FreeRTOSConfig.h 里设置 configUSE_IDLE_HOOK 为 1 。 实现函数与： void vApplicationIdleHook(void); 通常用该函数设置CPU进入低功耗模式。 协程 不常用。 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:3","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#任务管理"},{"categories":null,"content":"任务管理 任务 定义 void vATaskFunction(void *pvParameters) { for( ;; ) { /****************/ /* 任务主体代码 */ /****************/ } vTaskDelete(NULL); //如果要退出任务都必须要调用该函数，而不能直接返回 } 创建 xTaskCreate() BaseType_t xTaskCreate(TaskFunction_t pvTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t * pvCreatedTask); pvTaskCode ：指向任务函数的入口的指针。任务永远不会返回（位于死循环内）。 pcName ：任务描述。主要用于调试。字符串的最大长度由宏 configMAX_TASK_NAME_LEN 指定。 usStackDepth ：指定任务堆栈大小，能够支持的堆栈变量数量，而不是字节数。 pvParameters ：当任务创建时，传递给任务的参数。 uxPriority ：任务的优先级具 pvCreatedTask ：用于回传一个句柄，用于引用任务。 删除 vTaskDelete() void vTaskDelete(TaskHandle_t xTask); xTask ： 任务句柄 NULL ：删除当前任务。 挂起使任务进入挂起态。要使用挂起功能，必须将宏 INCLUDE_vTaskSuspend 设置为 1 。 vTaskSuspend void vTaskSuspend(TaskHandle_t xTaskToSuspend); xTaskxTaskToSuspend ： 任务句柄 NULL ：挂起当前任务。 恢复使任务从挂起态恢复。 vTaskResume void vTaskResume(TaskHandle_tx TaskToResume); xTaskToResume ：要恢复运行的任务句柄 xTaskResumeFromISR BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume); xTaskToResume ：要恢复运行的任务句柄 切换 不使用 vTaskDelay() 和 vTaskDelayUntil() ：在SysTick中断中切换任务。 使用 vTaskDelay() ：不用等到 SysTick 中断后才切换到下一个任务，更加高效 使用 vTaskDelayUntil() ：和 vTaskDelay() 类似，是绝对的延时可以保证执行的周期。 状态 运行： 如果一个任务正在执行，那么说这个任务处于运行状态。此时它占用处理器。 就绪： 就绪的任务已经具备执行的能力（将要执行，不同于阻塞和挂起），但是因为有一个同优先级或者更高优先级的任务处于运行状态而还没有真正执行。对于空闲任务来说，它一直都处于就绪态，只有当其他优先级比它高的任务，都执行完了，都在阻塞态里，空闲任务才会执行。 阻塞： 如果任务当前正在等待某个时序或外部中断，我们就说这个任务处于阻塞状态。比如一个任务调用 vTaskDelay() 后会阻塞到延时周期到为止。任务也可能阻塞在队列或信号量事件上。进入阻塞状态的任务通常有一个“超时”周期，当事件超时后解除阻塞。 挂起： 处于挂起状态的任务同样对调度器无效。仅当明确的分别调用 vTaskSuspend() 和 xTaskResume() API函数后，任务才会进入或退出挂起状态。不可以指定超时周期事件（不可以通过设定超时事件而退出挂起状态） 任务优先级 同时处于就绪状态的任务被执行的优先级。多个任务也可以有相同的优先级。 获取 uxTaskPriorityGet UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask); xTask ：要设置优先级任务的句柄。 NULL ：表示设置当前运行的任务。 设置 vTaskPrioritySet void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority); xTask ：要设置优先级任务的句柄。 NULL ：表示设置当前运行的任务。 uxNewPriority ：要设置的新优先级。 空闲任务 空闲任务是启动RTOS调度器时由内核自动创建的任务，这样可以确保至少有一个任务在运行。 功能：释放RTOS分配给被删除任务的内存。 空闲优先级 空闲任务具有最低任务优先级，这样如果有其它更高优先级的任务进入就绪态就可以立刻让出CPU。其他任务也可以以该优先级进行创建。 空闲任务钩子 让程序运行在空闲任务上。（注意不能调用任何可能造成阻塞的函数） 步骤 在 FreeRTOSConfig.h 里设置 configUSE_IDLE_HOOK 为 1 。 实现函数与： void vApplicationIdleHook(void); 通常用该函数设置CPU进入低功耗模式。 协程 不常用。 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:3","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#任务"},{"categories":null,"content":"任务管理 任务 定义 void vATaskFunction(void *pvParameters) { for( ;; ) { /****************/ /* 任务主体代码 */ /****************/ } vTaskDelete(NULL); //如果要退出任务都必须要调用该函数，而不能直接返回 } 创建 xTaskCreate() BaseType_t xTaskCreate(TaskFunction_t pvTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t * pvCreatedTask); pvTaskCode ：指向任务函数的入口的指针。任务永远不会返回（位于死循环内）。 pcName ：任务描述。主要用于调试。字符串的最大长度由宏 configMAX_TASK_NAME_LEN 指定。 usStackDepth ：指定任务堆栈大小，能够支持的堆栈变量数量，而不是字节数。 pvParameters ：当任务创建时，传递给任务的参数。 uxPriority ：任务的优先级具 pvCreatedTask ：用于回传一个句柄，用于引用任务。 删除 vTaskDelete() void vTaskDelete(TaskHandle_t xTask); xTask ： 任务句柄 NULL ：删除当前任务。 挂起使任务进入挂起态。要使用挂起功能，必须将宏 INCLUDE_vTaskSuspend 设置为 1 。 vTaskSuspend void vTaskSuspend(TaskHandle_t xTaskToSuspend); xTaskxTaskToSuspend ： 任务句柄 NULL ：挂起当前任务。 恢复使任务从挂起态恢复。 vTaskResume void vTaskResume(TaskHandle_tx TaskToResume); xTaskToResume ：要恢复运行的任务句柄 xTaskResumeFromISR BaseType_t xTaskResumeFromISR(TaskHandle_t xTaskToResume); xTaskToResume ：要恢复运行的任务句柄 切换 不使用 vTaskDelay() 和 vTaskDelayUntil() ：在SysTick中断中切换任务。 使用 vTaskDelay() ：不用等到 SysTick 中断后才切换到下一个任务，更加高效 使用 vTaskDelayUntil() ：和 vTaskDelay() 类似，是绝对的延时可以保证执行的周期。 状态 运行： 如果一个任务正在执行，那么说这个任务处于运行状态。此时它占用处理器。 就绪： 就绪的任务已经具备执行的能力（将要执行，不同于阻塞和挂起），但是因为有一个同优先级或者更高优先级的任务处于运行状态而还没有真正执行。对于空闲任务来说，它一直都处于就绪态，只有当其他优先级比它高的任务，都执行完了，都在阻塞态里，空闲任务才会执行。 阻塞： 如果任务当前正在等待某个时序或外部中断，我们就说这个任务处于阻塞状态。比如一个任务调用 vTaskDelay() 后会阻塞到延时周期到为止。任务也可能阻塞在队列或信号量事件上。进入阻塞状态的任务通常有一个“超时”周期，当事件超时后解除阻塞。 挂起： 处于挂起状态的任务同样对调度器无效。仅当明确的分别调用 vTaskSuspend() 和 xTaskResume() API函数后，任务才会进入或退出挂起状态。不可以指定超时周期事件（不可以通过设定超时事件而退出挂起状态） 任务优先级 同时处于就绪状态的任务被执行的优先级。多个任务也可以有相同的优先级。 获取 uxTaskPriorityGet UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask); xTask ：要设置优先级任务的句柄。 NULL ：表示设置当前运行的任务。 设置 vTaskPrioritySet void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority); xTask ：要设置优先级任务的句柄。 NULL ：表示设置当前运行的任务。 uxNewPriority ：要设置的新优先级。 空闲任务 空闲任务是启动RTOS调度器时由内核自动创建的任务，这样可以确保至少有一个任务在运行。 功能：释放RTOS分配给被删除任务的内存。 空闲优先级 空闲任务具有最低任务优先级，这样如果有其它更高优先级的任务进入就绪态就可以立刻让出CPU。其他任务也可以以该优先级进行创建。 空闲任务钩子 让程序运行在空闲任务上。（注意不能调用任何可能造成阻塞的函数） 步骤 在 FreeRTOSConfig.h 里设置 configUSE_IDLE_HOOK 为 1 。 实现函数与： void vApplicationIdleHook(void); 通常用该函数设置CPU进入低功耗模式。 协程 不常用。 ","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:3","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#协程"},{"categories":null,"content":"通信管理 任务通知 不用事先声明，以任务为单位地进行消息传递。性能高，节省内存。 发送通知：发送通知API函数可以用于任务和中断服务函数。 xTaskNotify() Basetype_t xTaskNotify(TaskHandle_txTaskToNotify, uint32_t ulValue, eNotifyAction eAction) xTaskToNotify ：被通知的任务句柄 ulValue ：通知更新值 eAction ：枚举类型，指明更新通知值的方法 eAction 为 eSetValueWithoutOverwrite 返回值： pdFALSE ：本次通知值未能更新（上一个通知还未被取走） pdPASS ：通知值已更新 xTaskNotifyGive() 等待通知：等待通知API函数只能用在任务中。 ulTaskNotifyTake() ：为代替二进制信号量和计数信号量而专门设计，和发送通知API函数 xTaskNotifyGive() 、 vTaskNotifyGiveFromISR() 配合使用。 uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait) xClearCountOnExit pdFALSE ：用来实现二进制信号量，函数退出时将通知值清零 pdTRUE ：用来实现计数信号量，函数退出时，将通知值减一 xTaskNotifyWait() BaseType_t xTaskNotifyWait(uint32_tulBitsToClearOnEntry, uint32_tulBitsToClearOnExit, uint32_t*pulNotificationValue, TickType_txTicksToWait) ulBitsToClearOnEntry ：在使用通知之前，先将任务的通知值与参数 ulBitsToClearOnEntry 的按位取反值按位与操作。设置参数 ulBitsToClearOnEntry 为 0xFFFFFFFF(ULONG_MAX) ，表示清零任务通知值。 ulBitsToClearOnExit ：在函数 xTaskNotifyWait() 退出前，将任务的通知值与参数 ulBitsToClearOnExit 的按位取反值按位与操作。设置参数 ulBitsToClearOnExit 为 0xFFFFFFFF(ULONG_MAX) ，表示清零任务通知值。 pulNotificationValue ：用于向外回传任务的通知值。这个通知值在参数 ulBitsToClearOnExit 起作用前将通知值拷贝到 *pulNotificationValue 中。如果不需要返回任务的通知值，这里设置成 NULL 。 xTicksToWait ：因等待通知而进入阻塞状态的最大时间。时间单位为系统节拍周期。宏 pdMS_TO_TICKS 用于将指定的毫秒时间转化为相应的系统节拍数。 队列 创建 xQueueGenericCreate() QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) uxQueueLength ：队列项数目 uxItemSize ：每个队列项的大小 pucQueueStorage ：使用静态分配队列时才使用，指向定义队列存储空间，如果使用动态分配队列空间（默认），向这个参数传递 NULL 。 pxStaticQueue ：使用静态分配队列时才使用，指向队列控制结构体，如果使用动态分配队列空间（默认），向这个参数传递 NULL 。 ucQueueType ：类型。可能的值为： queueQUEUE_TYPE_BASE ：表示队列 queueQUEUE_TYPE_SET ：表示队列集合 queueQUEUE_TYPE_MUTEX ：表示互斥量 queueQUEUE_TYPE_COUNTING_SEMAPHORE ：表示计数信号量 queueQUEUE_TYPE_BINARY_SEMAPHORE ：表示二进制信号量 queueQUEUE_TYPE_RECURSIVE_MUTEX ：表示递归互斥量 入队发送到队列的消息是通过拷贝实现的，这意味着队列存储的数据是原数据，而不是原数据的引用。 xQueueGenericSendFromISR() BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition) xQueue ：队列句柄 pvItemToQueue ：指针，指向要入队的项目 pxHigherPriorityTaskWoken~：称为一个可选参数，并可以设置为 ~NULL 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将 *pxHigherPriorityTaskWoken 设置成 pdTRUE 如果 xQueueSendFromISR() 设置这个值为pdTRUE，则中断退出前需要一次上下文切换 xCopyPosition ：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队 队首入队 xQueueSendToFront() 队尾入队 xQueueGenericSend() BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition) xQueue ：队列句柄 pvItemToQueue ：指针，指向要入队的项目 xTicksToWait ：如果队列满，等待队列空闲的最大时间，如果队列满并且 xTicksToWait 被设置成0，函数立刻返回时间单位为系统节拍时钟周期，宏 portTICK_PERIOD_MS 可以用来辅助计算真实延时值如果 INCLUDE_vTaskSuspend 设置成1，并且指定延时为 portMAX_DELAY 将引起任务无限阻塞（没有超时） xCopyPosition ：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队 xQueueOverWrite() 覆盖式入队，即队列满后自动覆盖最旧的队列项。 出队 xQueueReceive BaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer,TickType_t xTicksToWait); pxQueue ：队列句柄。 pvBuffer ：指向一个缓冲区，用于拷贝接收到的列表项。 xTicksToWait ：要接收的项目队列为空时，允许任务最大阻塞时间。 0 ：表示即队列为空也立即返回。 portMAX_DELAY ：如果 INCLUDE_vTaskSuspend 设置为 1 将会引起任务无限阻塞（不会有超时）。 信号量 用于将任务与系统中的其他事件 同步 。在FreeRTOS中，信号量是基于队列机制实现的。 同步：当一个任务必须具有信号量才可执行时，在没有信号量的情况下只能等待其他任务（不论优先级）释放信号量后才可执行。 释放 xSemaphoreGive() #define xSemaphoreGive( xSemaphore ) \\ xQueueGenericSend( \\ ( QueueHandle_t ) ( xSemaphore ), \\ NULL, \\ semGIVE_BLOCK_TIME, \\ queueSEND_TO_BACK ) 实际上是一次并且阻塞时间为0的入队操作（宏 semGIVE_BLOCK_TIME 定义为0） 计数信号量 实现了对事件发生的次数或者对资源数量的计数。当计数为0时，要获取该信号量只能阻塞。 创建 #define xSemaphoreCreateCounting(uxMaxCount, uxInitialCount) \\ xQueueCreateCountingSemaphore(( uxMaxCount ), \\ ( uxInitialCount ), (NULL)) uxMaxCount ：最大计数值，当信号到达这个值后，就不再增长了 uxInitialCount ：创建信号量时的初始值 结构 二进制信号量（Binary Semaphore） 相当于 uxMaxCount 为1的计数信号量。 创建 #define xSemaphoreCreateBinary() \\ xQueueGenericCreate( \\ ( UBaseType_t ) 1, \\ semSEMAPHORE_QUEUE_ITEM_LENGTH, \\ NULL, \\ NULL, \\ queueQUEUE_TYPE_BINARY_SEMAPHORE \\ ) 实际上是创建了一个队列，队列项有","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:4","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#通信管理"},{"categories":null,"content":"通信管理 任务通知 不用事先声明，以任务为单位地进行消息传递。性能高，节省内存。 发送通知：发送通知API函数可以用于任务和中断服务函数。 xTaskNotify() Basetype_t xTaskNotify(TaskHandle_txTaskToNotify, uint32_t ulValue, eNotifyAction eAction) xTaskToNotify ：被通知的任务句柄 ulValue ：通知更新值 eAction ：枚举类型，指明更新通知值的方法 eAction 为 eSetValueWithoutOverwrite 返回值： pdFALSE ：本次通知值未能更新（上一个通知还未被取走） pdPASS ：通知值已更新 xTaskNotifyGive() 等待通知：等待通知API函数只能用在任务中。 ulTaskNotifyTake() ：为代替二进制信号量和计数信号量而专门设计，和发送通知API函数 xTaskNotifyGive() 、 vTaskNotifyGiveFromISR() 配合使用。 uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait) xClearCountOnExit pdFALSE ：用来实现二进制信号量，函数退出时将通知值清零 pdTRUE ：用来实现计数信号量，函数退出时，将通知值减一 xTaskNotifyWait() BaseType_t xTaskNotifyWait(uint32_tulBitsToClearOnEntry, uint32_tulBitsToClearOnExit, uint32_t*pulNotificationValue, TickType_txTicksToWait) ulBitsToClearOnEntry ：在使用通知之前，先将任务的通知值与参数 ulBitsToClearOnEntry 的按位取反值按位与操作。设置参数 ulBitsToClearOnEntry 为 0xFFFFFFFF(ULONG_MAX) ，表示清零任务通知值。 ulBitsToClearOnExit ：在函数 xTaskNotifyWait() 退出前，将任务的通知值与参数 ulBitsToClearOnExit 的按位取反值按位与操作。设置参数 ulBitsToClearOnExit 为 0xFFFFFFFF(ULONG_MAX) ，表示清零任务通知值。 pulNotificationValue ：用于向外回传任务的通知值。这个通知值在参数 ulBitsToClearOnExit 起作用前将通知值拷贝到 *pulNotificationValue 中。如果不需要返回任务的通知值，这里设置成 NULL 。 xTicksToWait ：因等待通知而进入阻塞状态的最大时间。时间单位为系统节拍周期。宏 pdMS_TO_TICKS 用于将指定的毫秒时间转化为相应的系统节拍数。 队列 创建 xQueueGenericCreate() QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) uxQueueLength ：队列项数目 uxItemSize ：每个队列项的大小 pucQueueStorage ：使用静态分配队列时才使用，指向定义队列存储空间，如果使用动态分配队列空间（默认），向这个参数传递 NULL 。 pxStaticQueue ：使用静态分配队列时才使用，指向队列控制结构体，如果使用动态分配队列空间（默认），向这个参数传递 NULL 。 ucQueueType ：类型。可能的值为： queueQUEUE_TYPE_BASE ：表示队列 queueQUEUE_TYPE_SET ：表示队列集合 queueQUEUE_TYPE_MUTEX ：表示互斥量 queueQUEUE_TYPE_COUNTING_SEMAPHORE ：表示计数信号量 queueQUEUE_TYPE_BINARY_SEMAPHORE ：表示二进制信号量 queueQUEUE_TYPE_RECURSIVE_MUTEX ：表示递归互斥量 入队发送到队列的消息是通过拷贝实现的，这意味着队列存储的数据是原数据，而不是原数据的引用。 xQueueGenericSendFromISR() BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition) xQueue ：队列句柄 pvItemToQueue ：指针，指向要入队的项目 pxHigherPriorityTaskWoken~：称为一个可选参数，并可以设置为 ~NULL 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将 *pxHigherPriorityTaskWoken 设置成 pdTRUE 如果 xQueueSendFromISR() 设置这个值为pdTRUE，则中断退出前需要一次上下文切换 xCopyPosition ：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队 队首入队 xQueueSendToFront() 队尾入队 xQueueGenericSend() BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition) xQueue ：队列句柄 pvItemToQueue ：指针，指向要入队的项目 xTicksToWait ：如果队列满，等待队列空闲的最大时间，如果队列满并且 xTicksToWait 被设置成0，函数立刻返回时间单位为系统节拍时钟周期，宏 portTICK_PERIOD_MS 可以用来辅助计算真实延时值如果 INCLUDE_vTaskSuspend 设置成1，并且指定延时为 portMAX_DELAY 将引起任务无限阻塞（没有超时） xCopyPosition ：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队 xQueueOverWrite() 覆盖式入队，即队列满后自动覆盖最旧的队列项。 出队 xQueueReceive BaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer,TickType_t xTicksToWait); pxQueue ：队列句柄。 pvBuffer ：指向一个缓冲区，用于拷贝接收到的列表项。 xTicksToWait ：要接收的项目队列为空时，允许任务最大阻塞时间。 0 ：表示即队列为空也立即返回。 portMAX_DELAY ：如果 INCLUDE_vTaskSuspend 设置为 1 将会引起任务无限阻塞（不会有超时）。 信号量 用于将任务与系统中的其他事件 同步 。在FreeRTOS中，信号量是基于队列机制实现的。 同步：当一个任务必须具有信号量才可执行时，在没有信号量的情况下只能等待其他任务（不论优先级）释放信号量后才可执行。 释放 xSemaphoreGive() #define xSemaphoreGive( xSemaphore ) \\ xQueueGenericSend( \\ ( QueueHandle_t ) ( xSemaphore ), \\ NULL, \\ semGIVE_BLOCK_TIME, \\ queueSEND_TO_BACK ) 实际上是一次并且阻塞时间为0的入队操作（宏 semGIVE_BLOCK_TIME 定义为0） 计数信号量 实现了对事件发生的次数或者对资源数量的计数。当计数为0时，要获取该信号量只能阻塞。 创建 #define xSemaphoreCreateCounting(uxMaxCount, uxInitialCount) \\ xQueueCreateCountingSemaphore(( uxMaxCount ), \\ ( uxInitialCount ), (NULL)) uxMaxCount ：最大计数值，当信号到达这个值后，就不再增长了 uxInitialCount ：创建信号量时的初始值 结构 二进制信号量（Binary Semaphore） 相当于 uxMaxCount 为1的计数信号量。 创建 #define xSemaphoreCreateBinary() \\ xQueueGenericCreate( \\ ( UBaseType_t ) 1, \\ semSEMAPHORE_QUEUE_ITEM_LENGTH, \\ NULL, \\ NULL, \\ queueQUEUE_TYPE_BINARY_SEMAPHORE \\ ) 实际上是创建了一个队列，队列项有","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:4","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#任务通知"},{"categories":null,"content":"通信管理 任务通知 不用事先声明，以任务为单位地进行消息传递。性能高，节省内存。 发送通知：发送通知API函数可以用于任务和中断服务函数。 xTaskNotify() Basetype_t xTaskNotify(TaskHandle_txTaskToNotify, uint32_t ulValue, eNotifyAction eAction) xTaskToNotify ：被通知的任务句柄 ulValue ：通知更新值 eAction ：枚举类型，指明更新通知值的方法 eAction 为 eSetValueWithoutOverwrite 返回值： pdFALSE ：本次通知值未能更新（上一个通知还未被取走） pdPASS ：通知值已更新 xTaskNotifyGive() 等待通知：等待通知API函数只能用在任务中。 ulTaskNotifyTake() ：为代替二进制信号量和计数信号量而专门设计，和发送通知API函数 xTaskNotifyGive() 、 vTaskNotifyGiveFromISR() 配合使用。 uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait) xClearCountOnExit pdFALSE ：用来实现二进制信号量，函数退出时将通知值清零 pdTRUE ：用来实现计数信号量，函数退出时，将通知值减一 xTaskNotifyWait() BaseType_t xTaskNotifyWait(uint32_tulBitsToClearOnEntry, uint32_tulBitsToClearOnExit, uint32_t*pulNotificationValue, TickType_txTicksToWait) ulBitsToClearOnEntry ：在使用通知之前，先将任务的通知值与参数 ulBitsToClearOnEntry 的按位取反值按位与操作。设置参数 ulBitsToClearOnEntry 为 0xFFFFFFFF(ULONG_MAX) ，表示清零任务通知值。 ulBitsToClearOnExit ：在函数 xTaskNotifyWait() 退出前，将任务的通知值与参数 ulBitsToClearOnExit 的按位取反值按位与操作。设置参数 ulBitsToClearOnExit 为 0xFFFFFFFF(ULONG_MAX) ，表示清零任务通知值。 pulNotificationValue ：用于向外回传任务的通知值。这个通知值在参数 ulBitsToClearOnExit 起作用前将通知值拷贝到 *pulNotificationValue 中。如果不需要返回任务的通知值，这里设置成 NULL 。 xTicksToWait ：因等待通知而进入阻塞状态的最大时间。时间单位为系统节拍周期。宏 pdMS_TO_TICKS 用于将指定的毫秒时间转化为相应的系统节拍数。 队列 创建 xQueueGenericCreate() QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) uxQueueLength ：队列项数目 uxItemSize ：每个队列项的大小 pucQueueStorage ：使用静态分配队列时才使用，指向定义队列存储空间，如果使用动态分配队列空间（默认），向这个参数传递 NULL 。 pxStaticQueue ：使用静态分配队列时才使用，指向队列控制结构体，如果使用动态分配队列空间（默认），向这个参数传递 NULL 。 ucQueueType ：类型。可能的值为： queueQUEUE_TYPE_BASE ：表示队列 queueQUEUE_TYPE_SET ：表示队列集合 queueQUEUE_TYPE_MUTEX ：表示互斥量 queueQUEUE_TYPE_COUNTING_SEMAPHORE ：表示计数信号量 queueQUEUE_TYPE_BINARY_SEMAPHORE ：表示二进制信号量 queueQUEUE_TYPE_RECURSIVE_MUTEX ：表示递归互斥量 入队发送到队列的消息是通过拷贝实现的，这意味着队列存储的数据是原数据，而不是原数据的引用。 xQueueGenericSendFromISR() BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition) xQueue ：队列句柄 pvItemToQueue ：指针，指向要入队的项目 pxHigherPriorityTaskWoken~：称为一个可选参数，并可以设置为 ~NULL 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将 *pxHigherPriorityTaskWoken 设置成 pdTRUE 如果 xQueueSendFromISR() 设置这个值为pdTRUE，则中断退出前需要一次上下文切换 xCopyPosition ：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队 队首入队 xQueueSendToFront() 队尾入队 xQueueGenericSend() BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition) xQueue ：队列句柄 pvItemToQueue ：指针，指向要入队的项目 xTicksToWait ：如果队列满，等待队列空闲的最大时间，如果队列满并且 xTicksToWait 被设置成0，函数立刻返回时间单位为系统节拍时钟周期，宏 portTICK_PERIOD_MS 可以用来辅助计算真实延时值如果 INCLUDE_vTaskSuspend 设置成1，并且指定延时为 portMAX_DELAY 将引起任务无限阻塞（没有超时） xCopyPosition ：入队位置，可以选择从队列尾入队、从队列首入队和覆盖式入队 xQueueOverWrite() 覆盖式入队，即队列满后自动覆盖最旧的队列项。 出队 xQueueReceive BaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer,TickType_t xTicksToWait); pxQueue ：队列句柄。 pvBuffer ：指向一个缓冲区，用于拷贝接收到的列表项。 xTicksToWait ：要接收的项目队列为空时，允许任务最大阻塞时间。 0 ：表示即队列为空也立即返回。 portMAX_DELAY ：如果 INCLUDE_vTaskSuspend 设置为 1 将会引起任务无限阻塞（不会有超时）。 信号量 用于将任务与系统中的其他事件 同步 。在FreeRTOS中，信号量是基于队列机制实现的。 同步：当一个任务必须具有信号量才可执行时，在没有信号量的情况下只能等待其他任务（不论优先级）释放信号量后才可执行。 释放 xSemaphoreGive() #define xSemaphoreGive( xSemaphore ) \\ xQueueGenericSend( \\ ( QueueHandle_t ) ( xSemaphore ), \\ NULL, \\ semGIVE_BLOCK_TIME, \\ queueSEND_TO_BACK ) 实际上是一次并且阻塞时间为0的入队操作（宏 semGIVE_BLOCK_TIME 定义为0） 计数信号量 实现了对事件发生的次数或者对资源数量的计数。当计数为0时，要获取该信号量只能阻塞。 创建 #define xSemaphoreCreateCounting(uxMaxCount, uxInitialCount) \\ xQueueCreateCountingSemaphore(( uxMaxCount ), \\ ( uxInitialCount ), (NULL)) uxMaxCount ：最大计数值，当信号到达这个值后，就不再增长了 uxInitialCount ：创建信号量时的初始值 结构 二进制信号量（Binary Semaphore） 相当于 uxMaxCount 为1的计数信号量。 创建 #define xSemaphoreCreateBinary() \\ xQueueGenericCreate( \\ ( UBaseType_t ) 1, \\ semSEMAPHORE_QUEUE_ITEM_LENGTH, \\ NULL, \\ NULL, \\ queueQUEUE_TYPE_BINARY_SEMAPHORE \\ ) 实际上是创建了一个队列，队列项有","date":"2022-03-02","objectID":"/posts/notes/freertos/:2:4","series":null,"tags":["嵌入式"],"title":"FreeRTOS","uri":"/posts/notes/freertos/#队列"},{"categories":null,"content":"基本语法 % 注释。 ... connect 续行。 ; 抑制输出。 ","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:0","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#基本语法"},{"categories":null,"content":"命令 clc 清除命令窗口。 clear 清除会话变量。 clf 清除所有图表。 close 关闭所有图表。 doc fun 打开 fun 的文档。 format 设置输出格式。 help fun 打开 fun 的行内帮助。 load filename {vars} 从 .mat 文件中读取 vars 变量。 save {-append} file {vars} 将变量 var 保存至 file 。 addpath path 包含路径 path 。 iskeyword arg 判断 arg 是否为关键字。 scriptname 运行脚本文件 scriptname.m tic 开始计时器。 toc 停止计时器。 ver 列举已安装的包。 ","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:1","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#命令"},{"categories":null,"content":"变量 特殊变量 取值 ans 最后一个未取名的变量 pi 圆周率 eps 计算机的最小的单位数（无穷小量） flops 浮点运算数 inf 或 Inf 无穷大 NaN 不定量（Not An Number） i 或 j 虚部 nargin 函数输入变量的数目 nargout 函数输出变量的数目 realmin 最小可用正实数 realmax 最大可用正实数 数字 实数 创建 a = 5 a = 5 复数 创建 a = 3i + 4 a = 4 + 3i 向量 创建 声明 x = [1 2 3] x = 1 2 3 范围 1:3:10 ans = 1 4 7 10 分割 线性间隔 linspace(1, 10, 4) ans = 1 4 7 10 对数间隔 logspace(1, 10, 4) ans = 1.0000e+01 1.0000e+04 1.0000e+07 1.0000e+10 矩阵 创建 声明 ; 用于行分割（可选）， , 用于列分割（可选）。 A = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] B = [13, 14, 15, 16; 17, 18, 19, 20; 21, 22, 23, 24; 25, 26, 27, 28;] \u003e \u003e A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e \u003e \u003e B = 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 零矩阵 zeros(3, 3) ans = 0 0 0 0 0 0 0 0 0 一矩阵 ones(3, 3) ans = 1 1 1 1 1 1 1 1 1 单位矩阵 eye(3, 3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 随机矩阵 randi(100, 3, 3) ans = 94 28 77 74 3 19 32 75 99 对角矩阵 diag([1 2 3]) ans = Diagonal Matrix 1 0 0 0 2 0 0 0 3 访问 单个元素 A(1, 2) ans = 2 多个元素 A([1 3], [1 3]) ans = 1 3 9 11 切片 A(1:3, 1:2:end) ans = 1 3 5 7 9 11 行向量 A(2, :) ans = 5 6 7 8 列向量 A(:, 1) ans = 1 5 9 13 对角元素 diag(A) ans = 1 6 11 16 形状 size(A) ans = 4 4 维度 ndims(A) ans = 2 最长维度的长度 length(A) ans = 4 移除长度为 \\(1\\) 的维度 squeeze(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 翻转 左右翻转 fliplr(A) ans = 4 3 2 1 8 7 6 5 12 11 10 9 16 15 14 13 上下翻转 flip(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 flipud(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 改变大小 reshape(A, [1 16]) ans = 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 排序 sort(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 排序列 sortrows(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 拼接 列 [A, B] ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 horzcat(A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 cat(2, A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 行 [A; B] ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vertcat(A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cat(1, A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 逆矩阵 inv(diag([1 2 3])) ans = Diagonal Matrix 1.0000 0 0 0 0.5000 0 0 0 0.3333 行列式 det(A) ans = 4.7332e-30 特征向量 eig(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 eigs(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 点积 区别于点乘，将矩阵看作是列向量的合集，对对应列求向量点积。 dot(A, B) ans = 612 720 836 960 范数 norm(A) ans = 38.623 解线性方程组 对 \\(Ax=B\\) 解 \\(x\\) linsolve(A, B) warning: matrix singular to machine precision, rcond = 1.38778e-18 warning: called from linsolve at line 113 column 7 ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 mldivide(A, B) ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 对 \\(xA=B\\) 解 \\(x\\) mrdivide(B, A) ans = -2.0000e-01 1.0000e-01 4.0000e-01 7.0000e-01 -5.0000e-01 1.3323e-15 5.0000e-01 1.0000e+00 -8.0000e-01 -1.0000e-01 6.0000e-01 1.3000e+00 -1.1000e+00 -2.0000e-01 7.0000e-01 1.6000e+00 求解线性方程组的矩阵分解 decomposition(A) error: 'decomposition' undefined near line 1, column 1 The 'decomposition' function is not yet implemented in Octave. Please read \u003chttps://www.octave.org/missing.html\u003e to learn how you can contribute missing functionality. 最小范数最小二乘解 lsqminnorm(A, B) error: 'lsqminnorm' undefined near line 1, column 1 The 'lsqminnorm' function is not yet implemented in Octave. Please read \u003chttps://www.octave.org/missing.html\u003e to learn how you can contribute missing functionality. 秩 rank(A) ans = 2 对角元素和 trace(A) ans = 34 向量场的旋度和角速度 curl(A, B) ans = -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 向量场的散度 divergence(A, B) ans = 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 正交基 orth(A) ans = 0.134722 0.825742 0.340758 0.428817 0.54","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:2","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#变量"},{"categories":null,"content":"变量 特殊变量 取值 ans 最后一个未取名的变量 pi 圆周率 eps 计算机的最小的单位数（无穷小量） flops 浮点运算数 inf 或 Inf 无穷大 NaN 不定量（Not An Number） i 或 j 虚部 nargin 函数输入变量的数目 nargout 函数输出变量的数目 realmin 最小可用正实数 realmax 最大可用正实数 数字 实数 创建 a = 5 a = 5 复数 创建 a = 3i + 4 a = 4 + 3i 向量 创建 声明 x = [1 2 3] x = 1 2 3 范围 1:3:10 ans = 1 4 7 10 分割 线性间隔 linspace(1, 10, 4) ans = 1 4 7 10 对数间隔 logspace(1, 10, 4) ans = 1.0000e+01 1.0000e+04 1.0000e+07 1.0000e+10 矩阵 创建 声明 ; 用于行分割（可选）， , 用于列分割（可选）。 A = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] B = [13, 14, 15, 16; 17, 18, 19, 20; 21, 22, 23, 24; 25, 26, 27, 28;] \u003e \u003e A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e \u003e \u003e B = 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 零矩阵 zeros(3, 3) ans = 0 0 0 0 0 0 0 0 0 一矩阵 ones(3, 3) ans = 1 1 1 1 1 1 1 1 1 单位矩阵 eye(3, 3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 随机矩阵 randi(100, 3, 3) ans = 94 28 77 74 3 19 32 75 99 对角矩阵 diag([1 2 3]) ans = Diagonal Matrix 1 0 0 0 2 0 0 0 3 访问 单个元素 A(1, 2) ans = 2 多个元素 A([1 3], [1 3]) ans = 1 3 9 11 切片 A(1:3, 1:2:end) ans = 1 3 5 7 9 11 行向量 A(2, :) ans = 5 6 7 8 列向量 A(:, 1) ans = 1 5 9 13 对角元素 diag(A) ans = 1 6 11 16 形状 size(A) ans = 4 4 维度 ndims(A) ans = 2 最长维度的长度 length(A) ans = 4 移除长度为 \\(1\\) 的维度 squeeze(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 翻转 左右翻转 fliplr(A) ans = 4 3 2 1 8 7 6 5 12 11 10 9 16 15 14 13 上下翻转 flip(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 flipud(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 改变大小 reshape(A, [1 16]) ans = 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 排序 sort(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 排序列 sortrows(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 拼接 列 [A, B] ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 horzcat(A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 cat(2, A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 行 [A; B] ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vertcat(A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cat(1, A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 逆矩阵 inv(diag([1 2 3])) ans = Diagonal Matrix 1.0000 0 0 0 0.5000 0 0 0 0.3333 行列式 det(A) ans = 4.7332e-30 特征向量 eig(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 eigs(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 点积 区别于点乘，将矩阵看作是列向量的合集，对对应列求向量点积。 dot(A, B) ans = 612 720 836 960 范数 norm(A) ans = 38.623 解线性方程组 对 \\(Ax=B\\) 解 \\(x\\) linsolve(A, B) warning: matrix singular to machine precision, rcond = 1.38778e-18 warning: called from linsolve at line 113 column 7 ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 mldivide(A, B) ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 对 \\(xA=B\\) 解 \\(x\\) mrdivide(B, A) ans = -2.0000e-01 1.0000e-01 4.0000e-01 7.0000e-01 -5.0000e-01 1.3323e-15 5.0000e-01 1.0000e+00 -8.0000e-01 -1.0000e-01 6.0000e-01 1.3000e+00 -1.1000e+00 -2.0000e-01 7.0000e-01 1.6000e+00 求解线性方程组的矩阵分解 decomposition(A) error: 'decomposition' undefined near line 1, column 1 The 'decomposition' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 最小范数最小二乘解 lsqminnorm(A, B) error: 'lsqminnorm' undefined near line 1, column 1 The 'lsqminnorm' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 秩 rank(A) ans = 2 对角元素和 trace(A) ans = 34 向量场的旋度和角速度 curl(A, B) ans = -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 向量场的散度 divergence(A, B) ans = 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 正交基 orth(A) ans = 0.134722 0.825742 0.340758 0.428817 0.54","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:2","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#数字"},{"categories":null,"content":"变量 特殊变量 取值 ans 最后一个未取名的变量 pi 圆周率 eps 计算机的最小的单位数（无穷小量） flops 浮点运算数 inf 或 Inf 无穷大 NaN 不定量（Not An Number） i 或 j 虚部 nargin 函数输入变量的数目 nargout 函数输出变量的数目 realmin 最小可用正实数 realmax 最大可用正实数 数字 实数 创建 a = 5 a = 5 复数 创建 a = 3i + 4 a = 4 + 3i 向量 创建 声明 x = [1 2 3] x = 1 2 3 范围 1:3:10 ans = 1 4 7 10 分割 线性间隔 linspace(1, 10, 4) ans = 1 4 7 10 对数间隔 logspace(1, 10, 4) ans = 1.0000e+01 1.0000e+04 1.0000e+07 1.0000e+10 矩阵 创建 声明 ; 用于行分割（可选）， , 用于列分割（可选）。 A = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] B = [13, 14, 15, 16; 17, 18, 19, 20; 21, 22, 23, 24; 25, 26, 27, 28;] \u003e \u003e A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e \u003e \u003e B = 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 零矩阵 zeros(3, 3) ans = 0 0 0 0 0 0 0 0 0 一矩阵 ones(3, 3) ans = 1 1 1 1 1 1 1 1 1 单位矩阵 eye(3, 3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 随机矩阵 randi(100, 3, 3) ans = 94 28 77 74 3 19 32 75 99 对角矩阵 diag([1 2 3]) ans = Diagonal Matrix 1 0 0 0 2 0 0 0 3 访问 单个元素 A(1, 2) ans = 2 多个元素 A([1 3], [1 3]) ans = 1 3 9 11 切片 A(1:3, 1:2:end) ans = 1 3 5 7 9 11 行向量 A(2, :) ans = 5 6 7 8 列向量 A(:, 1) ans = 1 5 9 13 对角元素 diag(A) ans = 1 6 11 16 形状 size(A) ans = 4 4 维度 ndims(A) ans = 2 最长维度的长度 length(A) ans = 4 移除长度为 \\(1\\) 的维度 squeeze(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 翻转 左右翻转 fliplr(A) ans = 4 3 2 1 8 7 6 5 12 11 10 9 16 15 14 13 上下翻转 flip(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 flipud(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 改变大小 reshape(A, [1 16]) ans = 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 排序 sort(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 排序列 sortrows(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 拼接 列 [A, B] ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 horzcat(A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 cat(2, A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 行 [A; B] ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vertcat(A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cat(1, A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 逆矩阵 inv(diag([1 2 3])) ans = Diagonal Matrix 1.0000 0 0 0 0.5000 0 0 0 0.3333 行列式 det(A) ans = 4.7332e-30 特征向量 eig(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 eigs(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 点积 区别于点乘，将矩阵看作是列向量的合集，对对应列求向量点积。 dot(A, B) ans = 612 720 836 960 范数 norm(A) ans = 38.623 解线性方程组 对 \\(Ax=B\\) 解 \\(x\\) linsolve(A, B) warning: matrix singular to machine precision, rcond = 1.38778e-18 warning: called from linsolve at line 113 column 7 ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 mldivide(A, B) ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 对 \\(xA=B\\) 解 \\(x\\) mrdivide(B, A) ans = -2.0000e-01 1.0000e-01 4.0000e-01 7.0000e-01 -5.0000e-01 1.3323e-15 5.0000e-01 1.0000e+00 -8.0000e-01 -1.0000e-01 6.0000e-01 1.3000e+00 -1.1000e+00 -2.0000e-01 7.0000e-01 1.6000e+00 求解线性方程组的矩阵分解 decomposition(A) error: 'decomposition' undefined near line 1, column 1 The 'decomposition' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 最小范数最小二乘解 lsqminnorm(A, B) error: 'lsqminnorm' undefined near line 1, column 1 The 'lsqminnorm' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 秩 rank(A) ans = 2 对角元素和 trace(A) ans = 34 向量场的旋度和角速度 curl(A, B) ans = -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 向量场的散度 divergence(A, B) ans = 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 正交基 orth(A) ans = 0.134722 0.825742 0.340758 0.428817 0.54","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:2","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#向量"},{"categories":null,"content":"变量 特殊变量 取值 ans 最后一个未取名的变量 pi 圆周率 eps 计算机的最小的单位数（无穷小量） flops 浮点运算数 inf 或 Inf 无穷大 NaN 不定量（Not An Number） i 或 j 虚部 nargin 函数输入变量的数目 nargout 函数输出变量的数目 realmin 最小可用正实数 realmax 最大可用正实数 数字 实数 创建 a = 5 a = 5 复数 创建 a = 3i + 4 a = 4 + 3i 向量 创建 声明 x = [1 2 3] x = 1 2 3 范围 1:3:10 ans = 1 4 7 10 分割 线性间隔 linspace(1, 10, 4) ans = 1 4 7 10 对数间隔 logspace(1, 10, 4) ans = 1.0000e+01 1.0000e+04 1.0000e+07 1.0000e+10 矩阵 创建 声明 ; 用于行分割（可选）， , 用于列分割（可选）。 A = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] B = [13, 14, 15, 16; 17, 18, 19, 20; 21, 22, 23, 24; 25, 26, 27, 28;] \u003e \u003e A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e \u003e \u003e B = 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 零矩阵 zeros(3, 3) ans = 0 0 0 0 0 0 0 0 0 一矩阵 ones(3, 3) ans = 1 1 1 1 1 1 1 1 1 单位矩阵 eye(3, 3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 随机矩阵 randi(100, 3, 3) ans = 94 28 77 74 3 19 32 75 99 对角矩阵 diag([1 2 3]) ans = Diagonal Matrix 1 0 0 0 2 0 0 0 3 访问 单个元素 A(1, 2) ans = 2 多个元素 A([1 3], [1 3]) ans = 1 3 9 11 切片 A(1:3, 1:2:end) ans = 1 3 5 7 9 11 行向量 A(2, :) ans = 5 6 7 8 列向量 A(:, 1) ans = 1 5 9 13 对角元素 diag(A) ans = 1 6 11 16 形状 size(A) ans = 4 4 维度 ndims(A) ans = 2 最长维度的长度 length(A) ans = 4 移除长度为 \\(1\\) 的维度 squeeze(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 翻转 左右翻转 fliplr(A) ans = 4 3 2 1 8 7 6 5 12 11 10 9 16 15 14 13 上下翻转 flip(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 flipud(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 改变大小 reshape(A, [1 16]) ans = 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 排序 sort(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 排序列 sortrows(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 拼接 列 [A, B] ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 horzcat(A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 cat(2, A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 行 [A; B] ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vertcat(A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cat(1, A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 逆矩阵 inv(diag([1 2 3])) ans = Diagonal Matrix 1.0000 0 0 0 0.5000 0 0 0 0.3333 行列式 det(A) ans = 4.7332e-30 特征向量 eig(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 eigs(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 点积 区别于点乘，将矩阵看作是列向量的合集，对对应列求向量点积。 dot(A, B) ans = 612 720 836 960 范数 norm(A) ans = 38.623 解线性方程组 对 \\(Ax=B\\) 解 \\(x\\) linsolve(A, B) warning: matrix singular to machine precision, rcond = 1.38778e-18 warning: called from linsolve at line 113 column 7 ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 mldivide(A, B) ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 对 \\(xA=B\\) 解 \\(x\\) mrdivide(B, A) ans = -2.0000e-01 1.0000e-01 4.0000e-01 7.0000e-01 -5.0000e-01 1.3323e-15 5.0000e-01 1.0000e+00 -8.0000e-01 -1.0000e-01 6.0000e-01 1.3000e+00 -1.1000e+00 -2.0000e-01 7.0000e-01 1.6000e+00 求解线性方程组的矩阵分解 decomposition(A) error: 'decomposition' undefined near line 1, column 1 The 'decomposition' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 最小范数最小二乘解 lsqminnorm(A, B) error: 'lsqminnorm' undefined near line 1, column 1 The 'lsqminnorm' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 秩 rank(A) ans = 2 对角元素和 trace(A) ans = 34 向量场的旋度和角速度 curl(A, B) ans = -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 向量场的散度 divergence(A, B) ans = 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 正交基 orth(A) ans = 0.134722 0.825742 0.340758 0.428817 0.54","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:2","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#矩阵"},{"categories":null,"content":"变量 特殊变量 取值 ans 最后一个未取名的变量 pi 圆周率 eps 计算机的最小的单位数（无穷小量） flops 浮点运算数 inf 或 Inf 无穷大 NaN 不定量（Not An Number） i 或 j 虚部 nargin 函数输入变量的数目 nargout 函数输出变量的数目 realmin 最小可用正实数 realmax 最大可用正实数 数字 实数 创建 a = 5 a = 5 复数 创建 a = 3i + 4 a = 4 + 3i 向量 创建 声明 x = [1 2 3] x = 1 2 3 范围 1:3:10 ans = 1 4 7 10 分割 线性间隔 linspace(1, 10, 4) ans = 1 4 7 10 对数间隔 logspace(1, 10, 4) ans = 1.0000e+01 1.0000e+04 1.0000e+07 1.0000e+10 矩阵 创建 声明 ; 用于行分割（可选）， , 用于列分割（可选）。 A = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] B = [13, 14, 15, 16; 17, 18, 19, 20; 21, 22, 23, 24; 25, 26, 27, 28;] \u003e \u003e A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e \u003e \u003e B = 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 零矩阵 zeros(3, 3) ans = 0 0 0 0 0 0 0 0 0 一矩阵 ones(3, 3) ans = 1 1 1 1 1 1 1 1 1 单位矩阵 eye(3, 3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 随机矩阵 randi(100, 3, 3) ans = 94 28 77 74 3 19 32 75 99 对角矩阵 diag([1 2 3]) ans = Diagonal Matrix 1 0 0 0 2 0 0 0 3 访问 单个元素 A(1, 2) ans = 2 多个元素 A([1 3], [1 3]) ans = 1 3 9 11 切片 A(1:3, 1:2:end) ans = 1 3 5 7 9 11 行向量 A(2, :) ans = 5 6 7 8 列向量 A(:, 1) ans = 1 5 9 13 对角元素 diag(A) ans = 1 6 11 16 形状 size(A) ans = 4 4 维度 ndims(A) ans = 2 最长维度的长度 length(A) ans = 4 移除长度为 \\(1\\) 的维度 squeeze(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 翻转 左右翻转 fliplr(A) ans = 4 3 2 1 8 7 6 5 12 11 10 9 16 15 14 13 上下翻转 flip(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 flipud(A) ans = 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4 改变大小 reshape(A, [1 16]) ans = 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 排序 sort(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 排序列 sortrows(A) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 拼接 列 [A, B] ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 horzcat(A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 cat(2, A, B) ans = 1 2 3 4 13 14 15 16 5 6 7 8 17 18 19 20 9 10 11 12 21 22 23 24 13 14 15 16 25 26 27 28 行 [A; B] ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 vertcat(A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cat(1, A, B) ans = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 逆矩阵 inv(diag([1 2 3])) ans = Diagonal Matrix 1.0000 0 0 0 0.5000 0 0 0 0.3333 行列式 det(A) ans = 4.7332e-30 特征向量 eig(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 eigs(A) ans = 3.6209e+01 -2.2094e+00 -3.1886e-15 -1.3484e-16 点积 区别于点乘，将矩阵看作是列向量的合集，对对应列求向量点积。 dot(A, B) ans = 612 720 836 960 范数 norm(A) ans = 38.623 解线性方程组 对 \\(Ax=B\\) 解 \\(x\\) linsolve(A, B) warning: matrix singular to machine precision, rcond = 1.38778e-18 warning: called from linsolve at line 113 column 7 ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 mldivide(A, B) ans = -2.9000 -3.2000 -3.5000 -3.8000 -0.8000 -0.9000 -1.0000 -1.1000 1.3000 1.4000 1.5000 1.6000 3.4000 3.7000 4.0000 4.3000 对 \\(xA=B\\) 解 \\(x\\) mrdivide(B, A) ans = -2.0000e-01 1.0000e-01 4.0000e-01 7.0000e-01 -5.0000e-01 1.3323e-15 5.0000e-01 1.0000e+00 -8.0000e-01 -1.0000e-01 6.0000e-01 1.3000e+00 -1.1000e+00 -2.0000e-01 7.0000e-01 1.6000e+00 求解线性方程组的矩阵分解 decomposition(A) error: 'decomposition' undefined near line 1, column 1 The 'decomposition' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 最小范数最小二乘解 lsqminnorm(A, B) error: 'lsqminnorm' undefined near line 1, column 1 The 'lsqminnorm' function is not yet implemented in Octave. Please read to learn how you can contribute missing functionality. 秩 rank(A) ans = 2 对角元素和 trace(A) ans = 34 向量场的旋度和角速度 curl(A, B) ans = -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 -1.5000 向量场的散度 divergence(A, B) ans = 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 正交基 orth(A) ans = 0.134722 0.825742 0.340758 0.428817 0.54","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:2","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#布尔值"},{"categories":null,"content":"函数 function f = fun(x) 匿名函数 匿名函数不支持多行定义（因此 if 语句无法使用），如果是分段函数可以通过逻辑表达式（真为 1 ，假为 0 ）乘上各段对应的函数得到： f = @(x) (x + 1) * (x \u003c 1) + (1 + 1 / x) * (x \u003e= 1); 逻辑运算符 数学运算符 符号 意义 A + B \\(A+B\\) A - B \\(A-B\\) A * B \\(A B\\) A .* B \\(\\text{Ans}_{i,j}=A_{i,j}\\times B_{i,j}\\) A / B \\(\\frac A B\\) A ./ B \\(\\text{Ans}_{i,j}=\\frac{A_{i,j}}{B_{i,j}}\\) A ^ n \\(A^n\\) A .^ n \\(\\text{Ans}_{i,j}=A_{i,j}^n\\) A \\ B \\(\\frac{B}{A}\\) A .\\ B \\(\\text{Ans}_{i,j}=\\frac{B_{i,j}}{A_{i,j}}\\) sum(A) \\(\\sum_{i=1}^n\\sum_{j=1}^m A_{i,j}\\) prod(A) \\(\\prod_{i=1}^n\\prod_{j=1}^m A_{i,j}\\) 若一条命令后为 , 或没有符号，则显示命令结果；若一条命令后为 ; ，则禁止显示命令结果。 % 注释。 ... 续行。 内置函数 disp(’text’) 打印 text 。 函数 意义 sin asin cos acos tan atan abs min max sqrt exp log log10 sign 符号函数 fix 取整 绘图 figure 手动创建一个图表。 title 指定图表标题。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172105.png\"; x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); plot(x, y); title('sin(x)'); print(figurefile, \"-dpng\"); disp(figurefile); figure(2, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172106.png\"; plot(x, z); title('cos(x)'); print(figurefile, \"-dpng\"); disp(figurefile) /tmp/2022-03-05-21-01-30_593019043467172105.png /tmp/2022-03-05-21-01-30_593019043467172106.png axis 指定坐标轴的范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1240088008176880943.png\"; x = linspace(0.0001, 0.01, 1000); y = sin(1 ./ x); plot(x, y); axis([0.005 0.01 -1 1]); print(figurefile, \"-dpng\"); ans = figurefile; grid grid on 开启网格。 grid off 关闭网格。 hold hold on 不清空当前画布，继续在当前画布上绘制。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_2084804487745472843.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold on; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; hold off 清空当前画布。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_503965652086705578.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold off; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; subplot 分割图表区域。第一、二个参数传入分割的行、列，第三个参数传入当前打印的区域编号。 figure(1, \"visible\", \"off\"); x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); a = sin(x) .* cos(x); b = sin(x) ./ (cos(x) + eps); subplot(2, 2, 1); plot(x, y); title('sin(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287082.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 2); plot(x, z); title('cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287083.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 3); plot(x, a); title('sin(x)cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287084.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 4); plot(x, b); title('sin(x)/cos(x)') figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287085.png\"; print(figurefile, \"-dpng\"); disp(figurefile); /tmp/2022-03-05-21-01-30_1475214018307287082.png /tmp/2022-03-05-21-01-30_1475214018307287083.png /tmp/2022-03-05-21-01-30_1475214018307287084.png /tmp/2022-03-05-21-01-30_1475214018307287085.png zoom zoom on 打开缩放模式。 zoom off 关闭缩放模式。 二维绘图 plot 散点绘图。参数以 3 个为一组，每组的： 第一个参数传入向量，作为横坐标 第二个参数传入向量，作为纵坐标 第三个参数指定绘图格式 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1353678310868302203.png\" x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, y, 'r', x, z, 'bo'); print(figurefile, \"-dpng\"); ans = figurefile ezplot 符号函数绘图。 显函数 第一个参数传入符号函数，第二个传入自变量范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1111849061060396539.png\"; ezplot('sin(x)',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 参数方程 第一、二个参数传入参数方程，第三个参数传入参数范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1988435374878063066.png\"; ezplot('cos(t)^3', 'sin(t)^3',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 隐函数 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1938790695925422842.png\"; ezplot('exp(x)+sin(x*y)',[-2,0.5,0,2]); print(figurefile, \"-dpng\"); ans = figurefile; fplot 第一个参数可传入多个： 符","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:3","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#函数"},{"categories":null,"content":"函数 function f = fun(x) 匿名函数 匿名函数不支持多行定义（因此 if 语句无法使用），如果是分段函数可以通过逻辑表达式（真为 1 ，假为 0 ）乘上各段对应的函数得到： f = @(x) (x + 1) * (x \u003c 1) + (1 + 1 / x) * (x \u003e= 1); 逻辑运算符 数学运算符 符号 意义 A + B \\(A+B\\) A - B \\(A-B\\) A * B \\(A B\\) A .* B \\(\\text{Ans}_{i,j}=A_{i,j}\\times B_{i,j}\\) A / B \\(\\frac A B\\) A ./ B \\(\\text{Ans}_{i,j}=\\frac{A_{i,j}}{B_{i,j}}\\) A ^ n \\(A^n\\) A .^ n \\(\\text{Ans}_{i,j}=A_{i,j}^n\\) A \\ B \\(\\frac{B}{A}\\) A .\\ B \\(\\text{Ans}_{i,j}=\\frac{B_{i,j}}{A_{i,j}}\\) sum(A) \\(\\sum_{i=1}^n\\sum_{j=1}^m A_{i,j}\\) prod(A) \\(\\prod_{i=1}^n\\prod_{j=1}^m A_{i,j}\\) 若一条命令后为 , 或没有符号，则显示命令结果；若一条命令后为 ; ，则禁止显示命令结果。 % 注释。 ... 续行。 内置函数 disp(’text’) 打印 text 。 函数 意义 sin asin cos acos tan atan abs min max sqrt exp log log10 sign 符号函数 fix 取整 绘图 figure 手动创建一个图表。 title 指定图表标题。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172105.png\"; x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); plot(x, y); title('sin(x)'); print(figurefile, \"-dpng\"); disp(figurefile); figure(2, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172106.png\"; plot(x, z); title('cos(x)'); print(figurefile, \"-dpng\"); disp(figurefile) /tmp/2022-03-05-21-01-30_593019043467172105.png /tmp/2022-03-05-21-01-30_593019043467172106.png axis 指定坐标轴的范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1240088008176880943.png\"; x = linspace(0.0001, 0.01, 1000); y = sin(1 ./ x); plot(x, y); axis([0.005 0.01 -1 1]); print(figurefile, \"-dpng\"); ans = figurefile; grid grid on 开启网格。 grid off 关闭网格。 hold hold on 不清空当前画布，继续在当前画布上绘制。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_2084804487745472843.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold on; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; hold off 清空当前画布。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_503965652086705578.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold off; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; subplot 分割图表区域。第一、二个参数传入分割的行、列，第三个参数传入当前打印的区域编号。 figure(1, \"visible\", \"off\"); x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); a = sin(x) .* cos(x); b = sin(x) ./ (cos(x) + eps); subplot(2, 2, 1); plot(x, y); title('sin(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287082.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 2); plot(x, z); title('cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287083.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 3); plot(x, a); title('sin(x)cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287084.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 4); plot(x, b); title('sin(x)/cos(x)') figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287085.png\"; print(figurefile, \"-dpng\"); disp(figurefile); /tmp/2022-03-05-21-01-30_1475214018307287082.png /tmp/2022-03-05-21-01-30_1475214018307287083.png /tmp/2022-03-05-21-01-30_1475214018307287084.png /tmp/2022-03-05-21-01-30_1475214018307287085.png zoom zoom on 打开缩放模式。 zoom off 关闭缩放模式。 二维绘图 plot 散点绘图。参数以 3 个为一组，每组的： 第一个参数传入向量，作为横坐标 第二个参数传入向量，作为纵坐标 第三个参数指定绘图格式 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1353678310868302203.png\" x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, y, 'r', x, z, 'bo'); print(figurefile, \"-dpng\"); ans = figurefile ezplot 符号函数绘图。 显函数 第一个参数传入符号函数，第二个传入自变量范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1111849061060396539.png\"; ezplot('sin(x)',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 参数方程 第一、二个参数传入参数方程，第三个参数传入参数范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1988435374878063066.png\"; ezplot('cos(t)^3', 'sin(t)^3',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 隐函数 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1938790695925422842.png\"; ezplot('exp(x)+sin(x*y)',[-2,0.5,0,2]); print(figurefile, \"-dpng\"); ans = figurefile; fplot 第一个参数可传入多个： 符","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:3","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#匿名函数"},{"categories":null,"content":"函数 function f = fun(x) 匿名函数 匿名函数不支持多行定义（因此 if 语句无法使用），如果是分段函数可以通过逻辑表达式（真为 1 ，假为 0 ）乘上各段对应的函数得到： f = @(x) (x + 1) * (x \u003c 1) + (1 + 1 / x) * (x \u003e= 1); 逻辑运算符 数学运算符 符号 意义 A + B \\(A+B\\) A - B \\(A-B\\) A * B \\(A B\\) A .* B \\(\\text{Ans}_{i,j}=A_{i,j}\\times B_{i,j}\\) A / B \\(\\frac A B\\) A ./ B \\(\\text{Ans}_{i,j}=\\frac{A_{i,j}}{B_{i,j}}\\) A ^ n \\(A^n\\) A .^ n \\(\\text{Ans}_{i,j}=A_{i,j}^n\\) A \\ B \\(\\frac{B}{A}\\) A .\\ B \\(\\text{Ans}_{i,j}=\\frac{B_{i,j}}{A_{i,j}}\\) sum(A) \\(\\sum_{i=1}^n\\sum_{j=1}^m A_{i,j}\\) prod(A) \\(\\prod_{i=1}^n\\prod_{j=1}^m A_{i,j}\\) 若一条命令后为 , 或没有符号，则显示命令结果；若一条命令后为 ; ，则禁止显示命令结果。 % 注释。 ... 续行。 内置函数 disp(’text’) 打印 text 。 函数 意义 sin asin cos acos tan atan abs min max sqrt exp log log10 sign 符号函数 fix 取整 绘图 figure 手动创建一个图表。 title 指定图表标题。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172105.png\"; x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); plot(x, y); title('sin(x)'); print(figurefile, \"-dpng\"); disp(figurefile); figure(2, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172106.png\"; plot(x, z); title('cos(x)'); print(figurefile, \"-dpng\"); disp(figurefile) /tmp/2022-03-05-21-01-30_593019043467172105.png /tmp/2022-03-05-21-01-30_593019043467172106.png axis 指定坐标轴的范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1240088008176880943.png\"; x = linspace(0.0001, 0.01, 1000); y = sin(1 ./ x); plot(x, y); axis([0.005 0.01 -1 1]); print(figurefile, \"-dpng\"); ans = figurefile; grid grid on 开启网格。 grid off 关闭网格。 hold hold on 不清空当前画布，继续在当前画布上绘制。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_2084804487745472843.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold on; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; hold off 清空当前画布。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_503965652086705578.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold off; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; subplot 分割图表区域。第一、二个参数传入分割的行、列，第三个参数传入当前打印的区域编号。 figure(1, \"visible\", \"off\"); x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); a = sin(x) .* cos(x); b = sin(x) ./ (cos(x) + eps); subplot(2, 2, 1); plot(x, y); title('sin(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287082.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 2); plot(x, z); title('cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287083.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 3); plot(x, a); title('sin(x)cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287084.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 4); plot(x, b); title('sin(x)/cos(x)') figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287085.png\"; print(figurefile, \"-dpng\"); disp(figurefile); /tmp/2022-03-05-21-01-30_1475214018307287082.png /tmp/2022-03-05-21-01-30_1475214018307287083.png /tmp/2022-03-05-21-01-30_1475214018307287084.png /tmp/2022-03-05-21-01-30_1475214018307287085.png zoom zoom on 打开缩放模式。 zoom off 关闭缩放模式。 二维绘图 plot 散点绘图。参数以 3 个为一组，每组的： 第一个参数传入向量，作为横坐标 第二个参数传入向量，作为纵坐标 第三个参数指定绘图格式 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1353678310868302203.png\" x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, y, 'r', x, z, 'bo'); print(figurefile, \"-dpng\"); ans = figurefile ezplot 符号函数绘图。 显函数 第一个参数传入符号函数，第二个传入自变量范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1111849061060396539.png\"; ezplot('sin(x)',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 参数方程 第一、二个参数传入参数方程，第三个参数传入参数范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1988435374878063066.png\"; ezplot('cos(t)^3', 'sin(t)^3',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 隐函数 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1938790695925422842.png\"; ezplot('exp(x)+sin(x*y)',[-2,0.5,0,2]); print(figurefile, \"-dpng\"); ans = figurefile; fplot 第一个参数可传入多个： 符","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:3","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#逻辑运算符"},{"categories":null,"content":"函数 function f = fun(x) 匿名函数 匿名函数不支持多行定义（因此 if 语句无法使用），如果是分段函数可以通过逻辑表达式（真为 1 ，假为 0 ）乘上各段对应的函数得到： f = @(x) (x + 1) * (x \u003c 1) + (1 + 1 / x) * (x \u003e= 1); 逻辑运算符 数学运算符 符号 意义 A + B \\(A+B\\) A - B \\(A-B\\) A * B \\(A B\\) A .* B \\(\\text{Ans}_{i,j}=A_{i,j}\\times B_{i,j}\\) A / B \\(\\frac A B\\) A ./ B \\(\\text{Ans}_{i,j}=\\frac{A_{i,j}}{B_{i,j}}\\) A ^ n \\(A^n\\) A .^ n \\(\\text{Ans}_{i,j}=A_{i,j}^n\\) A \\ B \\(\\frac{B}{A}\\) A .\\ B \\(\\text{Ans}_{i,j}=\\frac{B_{i,j}}{A_{i,j}}\\) sum(A) \\(\\sum_{i=1}^n\\sum_{j=1}^m A_{i,j}\\) prod(A) \\(\\prod_{i=1}^n\\prod_{j=1}^m A_{i,j}\\) 若一条命令后为 , 或没有符号，则显示命令结果；若一条命令后为 ; ，则禁止显示命令结果。 % 注释。 ... 续行。 内置函数 disp(’text’) 打印 text 。 函数 意义 sin asin cos acos tan atan abs min max sqrt exp log log10 sign 符号函数 fix 取整 绘图 figure 手动创建一个图表。 title 指定图表标题。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172105.png\"; x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); plot(x, y); title('sin(x)'); print(figurefile, \"-dpng\"); disp(figurefile); figure(2, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172106.png\"; plot(x, z); title('cos(x)'); print(figurefile, \"-dpng\"); disp(figurefile) /tmp/2022-03-05-21-01-30_593019043467172105.png /tmp/2022-03-05-21-01-30_593019043467172106.png axis 指定坐标轴的范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1240088008176880943.png\"; x = linspace(0.0001, 0.01, 1000); y = sin(1 ./ x); plot(x, y); axis([0.005 0.01 -1 1]); print(figurefile, \"-dpng\"); ans = figurefile; grid grid on 开启网格。 grid off 关闭网格。 hold hold on 不清空当前画布，继续在当前画布上绘制。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_2084804487745472843.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold on; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; hold off 清空当前画布。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_503965652086705578.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold off; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; subplot 分割图表区域。第一、二个参数传入分割的行、列，第三个参数传入当前打印的区域编号。 figure(1, \"visible\", \"off\"); x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); a = sin(x) .* cos(x); b = sin(x) ./ (cos(x) + eps); subplot(2, 2, 1); plot(x, y); title('sin(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287082.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 2); plot(x, z); title('cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287083.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 3); plot(x, a); title('sin(x)cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287084.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 4); plot(x, b); title('sin(x)/cos(x)') figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287085.png\"; print(figurefile, \"-dpng\"); disp(figurefile); /tmp/2022-03-05-21-01-30_1475214018307287082.png /tmp/2022-03-05-21-01-30_1475214018307287083.png /tmp/2022-03-05-21-01-30_1475214018307287084.png /tmp/2022-03-05-21-01-30_1475214018307287085.png zoom zoom on 打开缩放模式。 zoom off 关闭缩放模式。 二维绘图 plot 散点绘图。参数以 3 个为一组，每组的： 第一个参数传入向量，作为横坐标 第二个参数传入向量，作为纵坐标 第三个参数指定绘图格式 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1353678310868302203.png\" x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, y, 'r', x, z, 'bo'); print(figurefile, \"-dpng\"); ans = figurefile ezplot 符号函数绘图。 显函数 第一个参数传入符号函数，第二个传入自变量范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1111849061060396539.png\"; ezplot('sin(x)',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 参数方程 第一、二个参数传入参数方程，第三个参数传入参数范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1988435374878063066.png\"; ezplot('cos(t)^3', 'sin(t)^3',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 隐函数 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1938790695925422842.png\"; ezplot('exp(x)+sin(x*y)',[-2,0.5,0,2]); print(figurefile, \"-dpng\"); ans = figurefile; fplot 第一个参数可传入多个： 符","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:3","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#数学运算符"},{"categories":null,"content":"函数 function f = fun(x) 匿名函数 匿名函数不支持多行定义（因此 if 语句无法使用），如果是分段函数可以通过逻辑表达式（真为 1 ，假为 0 ）乘上各段对应的函数得到： f = @(x) (x + 1) * (x \u003c 1) + (1 + 1 / x) * (x \u003e= 1); 逻辑运算符 数学运算符 符号 意义 A + B \\(A+B\\) A - B \\(A-B\\) A * B \\(A B\\) A .* B \\(\\text{Ans}_{i,j}=A_{i,j}\\times B_{i,j}\\) A / B \\(\\frac A B\\) A ./ B \\(\\text{Ans}_{i,j}=\\frac{A_{i,j}}{B_{i,j}}\\) A ^ n \\(A^n\\) A .^ n \\(\\text{Ans}_{i,j}=A_{i,j}^n\\) A \\ B \\(\\frac{B}{A}\\) A .\\ B \\(\\text{Ans}_{i,j}=\\frac{B_{i,j}}{A_{i,j}}\\) sum(A) \\(\\sum_{i=1}^n\\sum_{j=1}^m A_{i,j}\\) prod(A) \\(\\prod_{i=1}^n\\prod_{j=1}^m A_{i,j}\\) 若一条命令后为 , 或没有符号，则显示命令结果；若一条命令后为 ; ，则禁止显示命令结果。 % 注释。 ... 续行。 内置函数 disp(’text’) 打印 text 。 函数 意义 sin asin cos acos tan atan abs min max sqrt exp log log10 sign 符号函数 fix 取整 绘图 figure 手动创建一个图表。 title 指定图表标题。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172105.png\"; x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); plot(x, y); title('sin(x)'); print(figurefile, \"-dpng\"); disp(figurefile); figure(2, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172106.png\"; plot(x, z); title('cos(x)'); print(figurefile, \"-dpng\"); disp(figurefile) /tmp/2022-03-05-21-01-30_593019043467172105.png /tmp/2022-03-05-21-01-30_593019043467172106.png axis 指定坐标轴的范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1240088008176880943.png\"; x = linspace(0.0001, 0.01, 1000); y = sin(1 ./ x); plot(x, y); axis([0.005 0.01 -1 1]); print(figurefile, \"-dpng\"); ans = figurefile; grid grid on 开启网格。 grid off 关闭网格。 hold hold on 不清空当前画布，继续在当前画布上绘制。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_2084804487745472843.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold on; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; hold off 清空当前画布。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_503965652086705578.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold off; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; subplot 分割图表区域。第一、二个参数传入分割的行、列，第三个参数传入当前打印的区域编号。 figure(1, \"visible\", \"off\"); x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); a = sin(x) .* cos(x); b = sin(x) ./ (cos(x) + eps); subplot(2, 2, 1); plot(x, y); title('sin(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287082.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 2); plot(x, z); title('cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287083.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 3); plot(x, a); title('sin(x)cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287084.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 4); plot(x, b); title('sin(x)/cos(x)') figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287085.png\"; print(figurefile, \"-dpng\"); disp(figurefile); /tmp/2022-03-05-21-01-30_1475214018307287082.png /tmp/2022-03-05-21-01-30_1475214018307287083.png /tmp/2022-03-05-21-01-30_1475214018307287084.png /tmp/2022-03-05-21-01-30_1475214018307287085.png zoom zoom on 打开缩放模式。 zoom off 关闭缩放模式。 二维绘图 plot 散点绘图。参数以 3 个为一组，每组的： 第一个参数传入向量，作为横坐标 第二个参数传入向量，作为纵坐标 第三个参数指定绘图格式 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1353678310868302203.png\" x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, y, 'r', x, z, 'bo'); print(figurefile, \"-dpng\"); ans = figurefile ezplot 符号函数绘图。 显函数 第一个参数传入符号函数，第二个传入自变量范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1111849061060396539.png\"; ezplot('sin(x)',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 参数方程 第一、二个参数传入参数方程，第三个参数传入参数范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1988435374878063066.png\"; ezplot('cos(t)^3', 'sin(t)^3',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 隐函数 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1938790695925422842.png\"; ezplot('exp(x)+sin(x*y)',[-2,0.5,0,2]); print(figurefile, \"-dpng\"); ans = figurefile; fplot 第一个参数可传入多个： 符","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:3","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#内置函数"},{"categories":null,"content":"函数 function f = fun(x) 匿名函数 匿名函数不支持多行定义（因此 if 语句无法使用），如果是分段函数可以通过逻辑表达式（真为 1 ，假为 0 ）乘上各段对应的函数得到： f = @(x) (x + 1) * (x \u003c 1) + (1 + 1 / x) * (x \u003e= 1); 逻辑运算符 数学运算符 符号 意义 A + B \\(A+B\\) A - B \\(A-B\\) A * B \\(A B\\) A .* B \\(\\text{Ans}_{i,j}=A_{i,j}\\times B_{i,j}\\) A / B \\(\\frac A B\\) A ./ B \\(\\text{Ans}_{i,j}=\\frac{A_{i,j}}{B_{i,j}}\\) A ^ n \\(A^n\\) A .^ n \\(\\text{Ans}_{i,j}=A_{i,j}^n\\) A \\ B \\(\\frac{B}{A}\\) A .\\ B \\(\\text{Ans}_{i,j}=\\frac{B_{i,j}}{A_{i,j}}\\) sum(A) \\(\\sum_{i=1}^n\\sum_{j=1}^m A_{i,j}\\) prod(A) \\(\\prod_{i=1}^n\\prod_{j=1}^m A_{i,j}\\) 若一条命令后为 , 或没有符号，则显示命令结果；若一条命令后为 ; ，则禁止显示命令结果。 % 注释。 ... 续行。 内置函数 disp(’text’) 打印 text 。 函数 意义 sin asin cos acos tan atan abs min max sqrt exp log log10 sign 符号函数 fix 取整 绘图 figure 手动创建一个图表。 title 指定图表标题。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172105.png\"; x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); plot(x, y); title('sin(x)'); print(figurefile, \"-dpng\"); disp(figurefile); figure(2, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_593019043467172106.png\"; plot(x, z); title('cos(x)'); print(figurefile, \"-dpng\"); disp(figurefile) /tmp/2022-03-05-21-01-30_593019043467172105.png /tmp/2022-03-05-21-01-30_593019043467172106.png axis 指定坐标轴的范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1240088008176880943.png\"; x = linspace(0.0001, 0.01, 1000); y = sin(1 ./ x); plot(x, y); axis([0.005 0.01 -1 1]); print(figurefile, \"-dpng\"); ans = figurefile; grid grid on 开启网格。 grid off 关闭网格。 hold hold on 不清空当前画布，继续在当前画布上绘制。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_2084804487745472843.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold on; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; hold off 清空当前画布。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_503965652086705578.png\"; x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, z, ':'); hold off; plot(x, y); print(figurefile, \"-dpng\"); ans = figurefile; subplot 分割图表区域。第一、二个参数传入分割的行、列，第三个参数传入当前打印的区域编号。 figure(1, \"visible\", \"off\"); x = linspace(0, 2 * pi, 100); y = sin(x); z = cos(x); a = sin(x) .* cos(x); b = sin(x) ./ (cos(x) + eps); subplot(2, 2, 1); plot(x, y); title('sin(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287082.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 2); plot(x, z); title('cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287083.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 3); plot(x, a); title('sin(x)cos(x)'); figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287084.png\"; print(figurefile, \"-dpng\"); disp(figurefile); subplot(2, 2, 4); plot(x, b); title('sin(x)/cos(x)') figurefile = \"/tmp/2022-03-05-21-01-30_1475214018307287085.png\"; print(figurefile, \"-dpng\"); disp(figurefile); /tmp/2022-03-05-21-01-30_1475214018307287082.png /tmp/2022-03-05-21-01-30_1475214018307287083.png /tmp/2022-03-05-21-01-30_1475214018307287084.png /tmp/2022-03-05-21-01-30_1475214018307287085.png zoom zoom on 打开缩放模式。 zoom off 关闭缩放模式。 二维绘图 plot 散点绘图。参数以 3 个为一组，每组的： 第一个参数传入向量，作为横坐标 第二个参数传入向量，作为纵坐标 第三个参数指定绘图格式 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1353678310868302203.png\" x = linspace(0, 2*pi, 30); y = sin(x); z = cos(x); plot(x, y, 'r', x, z, 'bo'); print(figurefile, \"-dpng\"); ans = figurefile ezplot 符号函数绘图。 显函数 第一个参数传入符号函数，第二个传入自变量范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1111849061060396539.png\"; ezplot('sin(x)',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 参数方程 第一、二个参数传入参数方程，第三个参数传入参数范围。 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1988435374878063066.png\"; ezplot('cos(t)^3', 'sin(t)^3',[0,2*pi]) print(figurefile, \"-dpng\"); ans = figurefile; 隐函数 figure(1, \"visible\", \"off\"); figurefile = \"/tmp/2022-03-05-21-01-30_1938790695925422842.png\"; ezplot('exp(x)+sin(x*y)',[-2,0.5,0,2]); print(figurefile, \"-dpng\"); ans = figurefile; fplot 第一个参数可传入多个： 符","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:3","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#绘图"},{"categories":null,"content":"控制流 条件 if 语句 n = 10 if n \u003c 10 disp('n smaller 10') elseif n \u003c 20 disp('n between 10 and 20') else disp('n larger than 20') end n = 10 n between 10 and 20 switch 语句 n = 1 switch n case -1 disp('negative one') case 0 disp('zero') case {1,2,3} disp('positive one') otherwise disp('other value') end n = 1 positive one 循环 for 循环 for i = 1:3 disp('cool'); end cool cool cool while 循环 n = 1; nFactorial = 1; while nFactorial \u003c 1000 n = n + 1; nFactorial = nFactorial * n; end n n = 7 信息 未完待续 …… ","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:4","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#控制流"},{"categories":null,"content":"控制流 条件 if 语句 n = 10 if n \u003c 10 disp('n smaller 10') elseif n \u003c 20 disp('n between 10 and 20') else disp('n larger than 20') end n = 10 n between 10 and 20 switch 语句 n = 1 switch n case -1 disp('negative one') case 0 disp('zero') case {1,2,3} disp('positive one') otherwise disp('other value') end n = 1 positive one 循环 for 循环 for i = 1:3 disp('cool'); end cool cool cool while 循环 n = 1; nFactorial = 1; while nFactorial \u003c 1000 n = n + 1; nFactorial = nFactorial * n; end n n = 7 信息 未完待续 …… ","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:4","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#条件"},{"categories":null,"content":"控制流 条件 if 语句 n = 10 if n \u003c 10 disp('n smaller 10') elseif n \u003c 20 disp('n between 10 and 20') else disp('n larger than 20') end n = 10 n between 10 and 20 switch 语句 n = 1 switch n case -1 disp('negative one') case 0 disp('zero') case {1,2,3} disp('positive one') otherwise disp('other value') end n = 1 positive one 循环 for 循环 for i = 1:3 disp('cool'); end cool cool cool while 循环 n = 1; nFactorial = 1; while nFactorial \u003c 1000 n = n + 1; nFactorial = nFactorial * n; end n n = 7 信息 未完待续 …… ","date":"2022-03-02","objectID":"/posts/notes/matlab/:1:4","series":null,"tags":["编程语言","数学建模","数学"],"title":"Matlab","uri":"/posts/notes/matlab/#循环"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:0:0","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#"},{"categories":null,"content":"numpy ","date":"2022-03-02","objectID":"/posts/notes/numpy/:1:0","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#numpy"},{"categories":null,"content":"函数 numpy.dtype ","date":"2022-03-02","objectID":"/posts/notes/numpy/:1:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#函数"},{"categories":null,"content":"dtype 类型名称 描述 bool_ 布尔型数据类型（True 或者 False） int_ 默认的整数类型（类似于 C 语言中的 long ， int32 或 int64 ） intc 与 C 的 int 类型一样，一般是 int32 或 int64 intp 用于索引的整数类型（类似于 C 的 ssize_t ，一般情况下仍然是 int32 或 int64 ） int8 字节（-128 to 127） int16 整数（-32768 to 32767） int32 整数（-2147483648 to 2147483647） int64 整数（-9223372036854775808 to 9223372036854775807） uint8 无符号整数（0 to 255） uint16 无符号整数（0 to 65535） uint32 无符号整数（0 to 4294967295） uint64 无符号整数（0 to 18446744073709551615） float_ float64 类型的简写 float16 半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位 float32 单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位 float64 双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位 complex_ complex128 类型的简写，即 128 位复数 complex64 复数，表示双 32 位浮点数（实数部分和虚数部分） complex128 复数，表示双 64 位浮点数（实数部分和虚数部分） ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:0","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#dtype"},{"categories":null,"content":"方法 reshape 在不改变元素的情况下改变数组的形状。必须确保更改前后元素的个数一致。 用法： reshape(a, newshape, order) ： a ：输入的数组 newshape ：新的形状，用元组来表示 order ：索引顺序（只影响索引，不更改内存结构） 'C' ：使用C语言的索引方式 'F' ：使用Fortran语言的索引方式 示例： import numpy as np arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) return 'C: \\n{}\\nF: \\n{}'.format(np.reshape(arr, (-1, 2), 'C'), np.reshape(arr, (-1, 2), 'F')) C可以看作遍历的外层是高维，内层是低维，然后由低维向高维进行填充。 F则是相反，外层是低维，内层是高维，然后由高维向低维填充。 Numpy不管是 arr[z, y, x] 或者是 arr[z][y][x] 的方式来访问数组，都是先高维后低维，因此用于指定大小的元组也是如此，需要注意。 mgrid ：用于创建n维的散点 用法： mgrid[[start1:end1:step1],[start2:end2:step2], ...] start ：开始 end ：结束 step 实数：代表间隔，左闭右开 复数：代表点的个数，左闭右闭 返回值：由numpy组成的元组，表示点对应的坐标在图中的分布情况 示例： import numpy as np x, y = np.mgrid[-5:5:5j, -10:10:4] return 'x: \\n{}\\ny: \\n{}'.format(x, y) x 和 y 代表所有点的x坐标和y坐标在这个二维图上的分布情况。 astype ：转换数组的类型，相当于强制类型转换。 flatten 把数组展开成一维数组。 ravel 类似于 flatten ，但返回的是原来数组的视图，更加节省内存，但修改的同时会修改原数组，造成潜在的错误。 astype 进行类型转换。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#方法"},{"categories":null,"content":"方法 reshape 在不改变元素的情况下改变数组的形状。必须确保更改前后元素的个数一致。 用法： reshape(a, newshape, order) ： a ：输入的数组 newshape ：新的形状，用元组来表示 order ：索引顺序（只影响索引，不更改内存结构） 'C' ：使用C语言的索引方式 'F' ：使用Fortran语言的索引方式 示例： import numpy as np arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) return 'C: \\n{}\\nF: \\n{}'.format(np.reshape(arr, (-1, 2), 'C'), np.reshape(arr, (-1, 2), 'F')) C可以看作遍历的外层是高维，内层是低维，然后由低维向高维进行填充。 F则是相反，外层是低维，内层是高维，然后由高维向低维填充。 Numpy不管是 arr[z, y, x] 或者是 arr[z][y][x] 的方式来访问数组，都是先高维后低维，因此用于指定大小的元组也是如此，需要注意。 mgrid ：用于创建n维的散点 用法： mgrid[[start1:end1:step1],[start2:end2:step2], ...] start ：开始 end ：结束 step 实数：代表间隔，左闭右开 复数：代表点的个数，左闭右闭 返回值：由numpy组成的元组，表示点对应的坐标在图中的分布情况 示例： import numpy as np x, y = np.mgrid[-5:5:5j, -10:10:4] return 'x: \\n{}\\ny: \\n{}'.format(x, y) x 和 y 代表所有点的x坐标和y坐标在这个二维图上的分布情况。 astype ：转换数组的类型，相当于强制类型转换。 flatten 把数组展开成一维数组。 ravel 类似于 flatten ，但返回的是原来数组的视图，更加节省内存，但修改的同时会修改原数组，造成潜在的错误。 astype 进行类型转换。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#reshape"},{"categories":null,"content":"方法 reshape 在不改变元素的情况下改变数组的形状。必须确保更改前后元素的个数一致。 用法： reshape(a, newshape, order) ： a ：输入的数组 newshape ：新的形状，用元组来表示 order ：索引顺序（只影响索引，不更改内存结构） 'C' ：使用C语言的索引方式 'F' ：使用Fortran语言的索引方式 示例： import numpy as np arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) return 'C: \\n{}\\nF: \\n{}'.format(np.reshape(arr, (-1, 2), 'C'), np.reshape(arr, (-1, 2), 'F')) C可以看作遍历的外层是高维，内层是低维，然后由低维向高维进行填充。 F则是相反，外层是低维，内层是高维，然后由高维向低维填充。 Numpy不管是 arr[z, y, x] 或者是 arr[z][y][x] 的方式来访问数组，都是先高维后低维，因此用于指定大小的元组也是如此，需要注意。 mgrid ：用于创建n维的散点 用法： mgrid[[start1:end1:step1],[start2:end2:step2], ...] start ：开始 end ：结束 step 实数：代表间隔，左闭右开 复数：代表点的个数，左闭右闭 返回值：由numpy组成的元组，表示点对应的坐标在图中的分布情况 示例： import numpy as np x, y = np.mgrid[-5:5:5j, -10:10:4] return 'x: \\n{}\\ny: \\n{}'.format(x, y) x 和 y 代表所有点的x坐标和y坐标在这个二维图上的分布情况。 astype ：转换数组的类型，相当于强制类型转换。 flatten 把数组展开成一维数组。 ravel 类似于 flatten ，但返回的是原来数组的视图，更加节省内存，但修改的同时会修改原数组，造成潜在的错误。 astype 进行类型转换。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#flatten"},{"categories":null,"content":"方法 reshape 在不改变元素的情况下改变数组的形状。必须确保更改前后元素的个数一致。 用法： reshape(a, newshape, order) ： a ：输入的数组 newshape ：新的形状，用元组来表示 order ：索引顺序（只影响索引，不更改内存结构） 'C' ：使用C语言的索引方式 'F' ：使用Fortran语言的索引方式 示例： import numpy as np arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) return 'C: \\n{}\\nF: \\n{}'.format(np.reshape(arr, (-1, 2), 'C'), np.reshape(arr, (-1, 2), 'F')) C可以看作遍历的外层是高维，内层是低维，然后由低维向高维进行填充。 F则是相反，外层是低维，内层是高维，然后由高维向低维填充。 Numpy不管是 arr[z, y, x] 或者是 arr[z][y][x] 的方式来访问数组，都是先高维后低维，因此用于指定大小的元组也是如此，需要注意。 mgrid ：用于创建n维的散点 用法： mgrid[[start1:end1:step1],[start2:end2:step2], ...] start ：开始 end ：结束 step 实数：代表间隔，左闭右开 复数：代表点的个数，左闭右闭 返回值：由numpy组成的元组，表示点对应的坐标在图中的分布情况 示例： import numpy as np x, y = np.mgrid[-5:5:5j, -10:10:4] return 'x: \\n{}\\ny: \\n{}'.format(x, y) x 和 y 代表所有点的x坐标和y坐标在这个二维图上的分布情况。 astype ：转换数组的类型，相当于强制类型转换。 flatten 把数组展开成一维数组。 ravel 类似于 flatten ，但返回的是原来数组的视图，更加节省内存，但修改的同时会修改原数组，造成潜在的错误。 astype 进行类型转换。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#ravel"},{"categories":null,"content":"方法 reshape 在不改变元素的情况下改变数组的形状。必须确保更改前后元素的个数一致。 用法： reshape(a, newshape, order) ： a ：输入的数组 newshape ：新的形状，用元组来表示 order ：索引顺序（只影响索引，不更改内存结构） 'C' ：使用C语言的索引方式 'F' ：使用Fortran语言的索引方式 示例： import numpy as np arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) return 'C: \\n{}\\nF: \\n{}'.format(np.reshape(arr, (-1, 2), 'C'), np.reshape(arr, (-1, 2), 'F')) C可以看作遍历的外层是高维，内层是低维，然后由低维向高维进行填充。 F则是相反，外层是低维，内层是高维，然后由高维向低维填充。 Numpy不管是 arr[z, y, x] 或者是 arr[z][y][x] 的方式来访问数组，都是先高维后低维，因此用于指定大小的元组也是如此，需要注意。 mgrid ：用于创建n维的散点 用法： mgrid[[start1:end1:step1],[start2:end2:step2], ...] start ：开始 end ：结束 step 实数：代表间隔，左闭右开 复数：代表点的个数，左闭右闭 返回值：由numpy组成的元组，表示点对应的坐标在图中的分布情况 示例： import numpy as np x, y = np.mgrid[-5:5:5j, -10:10:4] return 'x: \\n{}\\ny: \\n{}'.format(x, y) x 和 y 代表所有点的x坐标和y坐标在这个二维图上的分布情况。 astype ：转换数组的类型，相当于强制类型转换。 flatten 把数组展开成一维数组。 ravel 类似于 flatten ，但返回的是原来数组的视图，更加节省内存，但修改的同时会修改原数组，造成潜在的错误。 astype 进行类型转换。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#astype"},{"categories":null,"content":"属性 dtype ：数据类型（Data Type） ndim ：维度 size ：元素的个数 shape ：形状（为维度个数的元组） T ：转置 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:2","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#属性"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#创建"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#zeroes"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#one"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#empty"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#arange"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#zero-like"},{"categories":null,"content":"创建 zeroes one empty 创建未初始化的数组（如果后面会手动对所有元素初始化，这种方法更高效）。经过实验，创建的 ndarray 会直接复用还未被垃圾回收的 ndarray 。 arange 相当于指定步长初始化了一个等差数列。 用法： arange(start, end, step) ： end ：不包括在内 示例： import numpy as np arr = np.arange(1, 17).reshape((4, 4)) return arr zero_like ： 产生和一个数组形状相同的全0数组。 用法： zeros_like(a, dtype=None, order='K', subok=True, shape=None) linspace ： 相当于指定项数初始化了一个等差数列。 用法： linspace(start, end, n) end ：包括在内 示例： import numpy as np arr = np.linspace(1, 31, 16).reshape((4, 4)) return arr ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:3","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#linspace"},{"categories":null,"content":"访问 ... 用于在该位置上 尽可能多 地表示 : 。如 arr[:, 0] 等价于 arr[:, 0, :] ，而 arr[..., 0] 等价于 arr[:, :, 0] 。区别是一个y平面，一个是x平面。 where 作为判断表达式的数组版本： 作为过滤器： 筛选出值为真的元素的下标（如果是多维的，返回的输出也是多维的） 示例： import numpy as np arr = np.arange(8) bool_arr = arr \u003e 3 indices = np.where(bool_arr) return '{}\\n{}'.format(indices, bool_arr) 所有的假值下标被过滤掉了。 n维数组套用n个任意维度的索引数组 从已有的数组中通过索引构建任意维度的数组。输出数组的维度取决于 , 间数组的维度。 示例： 一维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[3, 2, 1, 0], [0, 1, 2, 3]]) 就是取了原数组的[3,0]、[2,1]、[1,2]、[0,3] 多维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\nouput:\\n{}'.format( arr, arr[[[0, 0], [2, 2]], [[0, 2], [0, 2]]]) n维数组套用布尔值数组 示例： 一维数组过滤元素这种方式会比用作过滤的 where 方便得多。 import numpy as np arr = np.arange(6) return 'input: {}\\noutput: {}'.format( arr, arr[[True, False, True, False, True, False]] ) 二维数组过滤元素 import numpy as np arr = np.arange(9).reshape(3, 3) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[True, False, True], [False, True, True]] ) 可以看作对两个轴的索引分别进行过滤，然后 依次 索引整个数组： y方向上，过滤的结果为[0, 2]； x方向上，过滤的结果为[1, 2]。 结果就为 arr[[0, 2], [1, 2]] 。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:4","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#访问"},{"categories":null,"content":"访问 ... 用于在该位置上 尽可能多 地表示 : 。如 arr[:, 0] 等价于 arr[:, 0, :] ，而 arr[..., 0] 等价于 arr[:, :, 0] 。区别是一个y平面，一个是x平面。 where 作为判断表达式的数组版本： 作为过滤器： 筛选出值为真的元素的下标（如果是多维的，返回的输出也是多维的） 示例： import numpy as np arr = np.arange(8) bool_arr = arr \u003e 3 indices = np.where(bool_arr) return '{}\\n{}'.format(indices, bool_arr) 所有的假值下标被过滤掉了。 n维数组套用n个任意维度的索引数组 从已有的数组中通过索引构建任意维度的数组。输出数组的维度取决于 , 间数组的维度。 示例： 一维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[3, 2, 1, 0], [0, 1, 2, 3]]) 就是取了原数组的[3,0]、[2,1]、[1,2]、[0,3] 多维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\nouput:\\n{}'.format( arr, arr[[[0, 0], [2, 2]], [[0, 2], [0, 2]]]) n维数组套用布尔值数组 示例： 一维数组过滤元素这种方式会比用作过滤的 where 方便得多。 import numpy as np arr = np.arange(6) return 'input: {}\\noutput: {}'.format( arr, arr[[True, False, True, False, True, False]] ) 二维数组过滤元素 import numpy as np arr = np.arange(9).reshape(3, 3) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[True, False, True], [False, True, True]] ) 可以看作对两个轴的索引分别进行过滤，然后 依次 索引整个数组： y方向上，过滤的结果为[0, 2]； x方向上，过滤的结果为[1, 2]。 结果就为 arr[[0, 2], [1, 2]] 。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:4","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#dot-dot-dot"},{"categories":null,"content":"访问 ... 用于在该位置上 尽可能多 地表示 : 。如 arr[:, 0] 等价于 arr[:, 0, :] ，而 arr[..., 0] 等价于 arr[:, :, 0] 。区别是一个y平面，一个是x平面。 where 作为判断表达式的数组版本： 作为过滤器： 筛选出值为真的元素的下标（如果是多维的，返回的输出也是多维的） 示例： import numpy as np arr = np.arange(8) bool_arr = arr \u003e 3 indices = np.where(bool_arr) return '{}\\n{}'.format(indices, bool_arr) 所有的假值下标被过滤掉了。 n维数组套用n个任意维度的索引数组 从已有的数组中通过索引构建任意维度的数组。输出数组的维度取决于 , 间数组的维度。 示例： 一维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[3, 2, 1, 0], [0, 1, 2, 3]]) 就是取了原数组的[3,0]、[2,1]、[1,2]、[0,3] 多维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\nouput:\\n{}'.format( arr, arr[[[0, 0], [2, 2]], [[0, 2], [0, 2]]]) n维数组套用布尔值数组 示例： 一维数组过滤元素这种方式会比用作过滤的 where 方便得多。 import numpy as np arr = np.arange(6) return 'input: {}\\noutput: {}'.format( arr, arr[[True, False, True, False, True, False]] ) 二维数组过滤元素 import numpy as np arr = np.arange(9).reshape(3, 3) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[True, False, True], [False, True, True]] ) 可以看作对两个轴的索引分别进行过滤，然后 依次 索引整个数组： y方向上，过滤的结果为[0, 2]； x方向上，过滤的结果为[1, 2]。 结果就为 arr[[0, 2], [1, 2]] 。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:4","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#where"},{"categories":null,"content":"访问 ... 用于在该位置上 尽可能多 地表示 : 。如 arr[:, 0] 等价于 arr[:, 0, :] ，而 arr[..., 0] 等价于 arr[:, :, 0] 。区别是一个y平面，一个是x平面。 where 作为判断表达式的数组版本： 作为过滤器： 筛选出值为真的元素的下标（如果是多维的，返回的输出也是多维的） 示例： import numpy as np arr = np.arange(8) bool_arr = arr \u003e 3 indices = np.where(bool_arr) return '{}\\n{}'.format(indices, bool_arr) 所有的假值下标被过滤掉了。 n维数组套用n个任意维度的索引数组 从已有的数组中通过索引构建任意维度的数组。输出数组的维度取决于 , 间数组的维度。 示例： 一维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[3, 2, 1, 0], [0, 1, 2, 3]]) 就是取了原数组的[3,0]、[2,1]、[1,2]、[0,3] 多维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\nouput:\\n{}'.format( arr, arr[[[0, 0], [2, 2]], [[0, 2], [0, 2]]]) n维数组套用布尔值数组 示例： 一维数组过滤元素这种方式会比用作过滤的 where 方便得多。 import numpy as np arr = np.arange(6) return 'input: {}\\noutput: {}'.format( arr, arr[[True, False, True, False, True, False]] ) 二维数组过滤元素 import numpy as np arr = np.arange(9).reshape(3, 3) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[True, False, True], [False, True, True]] ) 可以看作对两个轴的索引分别进行过滤，然后 依次 索引整个数组： y方向上，过滤的结果为[0, 2]； x方向上，过滤的结果为[1, 2]。 结果就为 arr[[0, 2], [1, 2]] 。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:4","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#n维数组套用n个任意维度的索引数组"},{"categories":null,"content":"访问 ... 用于在该位置上 尽可能多 地表示 : 。如 arr[:, 0] 等价于 arr[:, 0, :] ，而 arr[..., 0] 等价于 arr[:, :, 0] 。区别是一个y平面，一个是x平面。 where 作为判断表达式的数组版本： 作为过滤器： 筛选出值为真的元素的下标（如果是多维的，返回的输出也是多维的） 示例： import numpy as np arr = np.arange(8) bool_arr = arr \u003e 3 indices = np.where(bool_arr) return '{}\\n{}'.format(indices, bool_arr) 所有的假值下标被过滤掉了。 n维数组套用n个任意维度的索引数组 从已有的数组中通过索引构建任意维度的数组。输出数组的维度取决于 , 间数组的维度。 示例： 一维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[3, 2, 1, 0], [0, 1, 2, 3]]) 就是取了原数组的[3,0]、[2,1]、[1,2]、[0,3] 多维 import numpy as np arr = np.arange(16).reshape(4, 4) return 'input:\\n{}\\nouput:\\n{}'.format( arr, arr[[[0, 0], [2, 2]], [[0, 2], [0, 2]]]) n维数组套用布尔值数组 示例： 一维数组过滤元素这种方式会比用作过滤的 where 方便得多。 import numpy as np arr = np.arange(6) return 'input: {}\\noutput: {}'.format( arr, arr[[True, False, True, False, True, False]] ) 二维数组过滤元素 import numpy as np arr = np.arange(9).reshape(3, 3) return 'input:\\n{}\\noutput:\\n{}'.format( arr, arr[[True, False, True], [False, True, True]] ) 可以看作对两个轴的索引分别进行过滤，然后 依次 索引整个数组： y方向上，过滤的结果为[0, 2]； x方向上，过滤的结果为[1, 2]。 结果就为 arr[[0, 2], [1, 2]] 。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:4","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#n维数组套用布尔值数组"},{"categories":null,"content":"打印 np.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None, sign=None, floatmode=None) precision ：打印精度（小数点后的位数）。 threshold ：超过多少个元素将中间的元素用省略号代替。 edgeitems ：超过 threshold 后，不使用省略号代替的边界元素个数。 linewidth ：设置每行字数的上限。 nanstr ：当矩阵元素为NAN（Not A Number）要显示的字符串。 infstr ：当矩阵元素无穷时显示的字符串。 sign ： '+' ：正数和负数都会加上符号。 '-' ：负数加上符号。 formatter ：传入一个字典，为指定数据类型的数据指定函数来格式化元素。 'all' 'float_kind' 'int_kind' ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:5","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#打印"},{"categories":null,"content":"打印 np.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None, sign=None, floatmode=None) precision ：打印精度（小数点后的位数）。 threshold ：超过多少个元素将中间的元素用省略号代替。 edgeitems ：超过 threshold 后，不使用省略号代替的边界元素个数。 linewidth ：设置每行字数的上限。 nanstr ：当矩阵元素为NAN（Not A Number）要显示的字符串。 infstr ：当矩阵元素无穷时显示的字符串。 sign ： '+' ：正数和负数都会加上符号。 '-' ：负数加上符号。 formatter ：传入一个字典，为指定数据类型的数据指定函数来格式化元素。 'all' 'float_kind' 'int_kind' ","date":"2022-03-02","objectID":"/posts/notes/numpy/:2:5","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#np-dot-set-printoptions--precision-none-threshold-none-edgeitems-none-linewidth-none-suppress-none-nanstr-none-infstr-none-formatter-none-sign-none-floatmode-none"},{"categories":null,"content":"扩展 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:3:0","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#扩展"},{"categories":null,"content":"FFT （快速傅里叶变换） 函数 fftshift 原来傅里叶变换后的低频都集中在左上角，这个函数把它们移动至中央。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:3:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#fft-快速傅里叶变换"},{"categories":null,"content":"FFT （快速傅里叶变换） 函数 fftshift 原来傅里叶变换后的低频都集中在左上角，这个函数把它们移动至中央。 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:3:1","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#函数"},{"categories":null,"content":"random randint 生成随机的任意维度数组。 参数： low ：最小值 high ：最大值 size ：生成数组的维度和大小 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:3:2","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#random"},{"categories":null,"content":"random randint 生成随机的任意维度数组。 参数： low ：最小值 high ：最大值 size ：生成数组的维度和大小 ","date":"2022-03-02","objectID":"/posts/notes/numpy/:3:2","series":null,"tags":["Python","OpenCV"],"title":"Numpy","uri":"/posts/notes/numpy/#randint"},{"categories":null,"content":"数据类型 ","date":"2022-03-02","objectID":"/posts/notes/python/:1:0","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#数据类型"},{"categories":null,"content":"基本数据类型 数字 整数 a = 1 print(a) print(type(a)) 浮点数 a = 1.0 print(a) print(type(a)) 比较运算符 运算符 意义 == 相等 != 不相等 \u003c 小于 \u003e 大于 \u003c= 小于等于 \u003e= 大于等于 return 42 == 42 return 40 == 42 return 'hello' == 'hello' return 'hello' == 'Hello' return 'dog' != 'cat' return 42 == 42.0 return 42 == '42' 此外，比较运算符可以连续使用，即 a \u003c x \u003c b 是允许的。 return 70 \u003c x \u003c 90 算术运算符 优先级从高到低如下： 运算符 意义 示例 ** 指数 2 ** 3 = 8 % 求余 22 % 8 = 6 // 整除 22 // 8 = 2 / 除法 22 / 8 = 2.75 * 乘法 3 * 3 = 9 - 减法 5 - 2 = 3 + 加法 2 + 2 = 4 return 2 // 3 return (2 + 3) * 6 return 2 ** 8 return 23 // 7 return 23 % 7 return (5 - 1) * ((7 + 1) / (3 - 1)) 增量赋值运算符 运算符 等价表达式 spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 字符串 a = 'Hello Python' print(a) print(type(a)) 常用操作 拼接 return 'Alice' 'Bob' 重复 return 'Alice' * 5 访问 元素 spam = 'Hello world!' print(spam[0]) print(spam[4]) print(spam[-1]) 切片 spam = 'Hello world!' print(spam[0:5]) print(spam[0:5:2]) print(spam[:5]) print(spam[6:]) print(spam[6:-1]) print(spam[:-1]) print(spam[::-1]) 包含 return 'Hello' in 'Hello World' return 'Hello' in 'Hello' return 'HELLO' in 'Hello World' return '' in 'spam' return 'cats' not in 'cats and dogs' 方法 strip 移除字符串两边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.strip() lstrip 移除字符串左边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.lstrip() rstrip 移除字符串右边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.rstrip() upper 将字符串中的所有英文字符替换为大写字母。 spam = 'Hello world!' spam = spam.upper() return spam isupper 判断字符串是否全为大写字母。 return 'HELLO'.isupper() return '12345'.isupper() lower 将字符串中的所有英文字符替换为小写字母。 return 'Hello'.lower() islower 判断字符串是否全为小写字母。 return 'hello'.islower() return '12345'.islower() isalpha 判断字符串是否以大写字母开头。 isalnum 判断字符串是否只有数字和字母并且不为空。 isdecimal 判断字符串是否只有数字。 isspace 判断字符串是否只有空格、制表符、换行符。 istitle 判断字符串中的每一个单词是否均以大写字母开头。 startswith 判断字符串是否以另一个字符串开头。 return 'Hello world!'.startswith('Hello') return 'abc123'.startswith('abcdef') return 'Hello world!'.startswith('Hello world!') endswith 判断字符串是否以另一个字符串结束。 return 'Hello world!'.endswith('world!') return 'abc123'.endswith('12') return 'Hello world!'.endswith('Hello world!') split 将一个字符串以某个字符串作为分隔符，分成一个字符串列表。 return 'My name is Simon'.split() return 'MyABCnameABCisABCSimon'.split('ABC') return 'My name is Simon'.split('m') join 将一个字符串列表使用这个字符串作为分隔符进行拼接。 return ', '.join(['cats', 'rats', 'bats']) return ' '.join(['My', 'name', 'is', 'Simon']) return 'ABC'.join(['My', 'name', 'is', 'Simon']) ljust 将一个字符串使用空格扩展为指定长度，并向左对齐。 return 'Hello'.ljust(10) return 'Hello'.ljust(20, '-') center 将一个字符串使用空格扩展为指定长度，并居中对齐。 return 'Hello'.center(20) return 'Hello'.center(20, '=') rjust 将一个字符串使用空格扩展为指定长度，并向右对齐。 return 'Hello'.rjust(10) return 'Hello'.rjust(20) return 'Hello World'.rjust(20) return 'Hello'.rjust(20, '*') 字符串格式化 % 运算符 使用 C 语言风格的格式化。 name = 'Pete' return 'Hello %s' % name 格式控制字符与 C 语言中的相同： num = 5 return 'I have %x apples' % num format 方法 Python 面向对象的语言一个函数是在类内部，那么我们称它为方法。 name = 'John' age = 20 print('Hello I\\'m {}, my age is {}'.format(name, age)) print(\"Hello I'm {0}, my age is {1}\".format(name, age)) 格式字符串 string.Template from string import Template name = 'Elizabeth' t = Template('Hey $name!') return t.substitute(name=name) 格式字符串 name = 'Elizabeth' return f'Hello {name}!' a = 5 b = 10 return f'Five plus ten is {a + b} and not {2 * (a + b)}.' 原始字符串 在原始字符串中，不会对 \\ 及之后的字符进行转义，通常用于正则表达式的定义中。 print(r'That is Carol\\'s cat.') 字符串转义字符 转义字符 意义 \\' 单引号 \\\" 双引号 \\t 制表符 \\n 换行符 \\\\ 反斜杠 多行字符串 使用 ''' 包裹，允许在字符串中直接进行换行。 print('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''') 布尔值 a = True # False print(a) print(type(a)) 逻辑比较运算符 不要使用 == 或 != ，而是使用 is 或 is not 用于布尔值的比较。 错误的示例： return True == True return True != False 正确的示例： return True is True return True is not False 逻辑运算符 与 表达式 结果 True and True True True and False False False and True False False and False False 或 表达式 结果 True or True True True or False True False or True True False or False False 非 表达式 结果 not True False ","date":"2022-03-02","objectID":"/posts/notes/python/:1:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#基本数据类型"},{"categories":null,"content":"基本数据类型 数字 整数 a = 1 print(a) print(type(a)) 浮点数 a = 1.0 print(a) print(type(a)) 比较运算符 运算符 意义 == 相等 != 不相等 \u003c 小于 \u003e 大于 \u003c= 小于等于 \u003e= 大于等于 return 42 == 42 return 40 == 42 return 'hello' == 'hello' return 'hello' == 'Hello' return 'dog' != 'cat' return 42 == 42.0 return 42 == '42' 此外，比较运算符可以连续使用，即 a \u003c x \u003c b 是允许的。 return 70 \u003c x \u003c 90 算术运算符 优先级从高到低如下： 运算符 意义 示例 ** 指数 2 ** 3 = 8 % 求余 22 % 8 = 6 // 整除 22 // 8 = 2 / 除法 22 / 8 = 2.75 * 乘法 3 * 3 = 9 - 减法 5 - 2 = 3 + 加法 2 + 2 = 4 return 2 // 3 return (2 + 3) * 6 return 2 ** 8 return 23 // 7 return 23 % 7 return (5 - 1) * ((7 + 1) / (3 - 1)) 增量赋值运算符 运算符 等价表达式 spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 字符串 a = 'Hello Python' print(a) print(type(a)) 常用操作 拼接 return 'Alice' 'Bob' 重复 return 'Alice' * 5 访问 元素 spam = 'Hello world!' print(spam[0]) print(spam[4]) print(spam[-1]) 切片 spam = 'Hello world!' print(spam[0:5]) print(spam[0:5:2]) print(spam[:5]) print(spam[6:]) print(spam[6:-1]) print(spam[:-1]) print(spam[::-1]) 包含 return 'Hello' in 'Hello World' return 'Hello' in 'Hello' return 'HELLO' in 'Hello World' return '' in 'spam' return 'cats' not in 'cats and dogs' 方法 strip 移除字符串两边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.strip() lstrip 移除字符串左边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.lstrip() rstrip 移除字符串右边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.rstrip() upper 将字符串中的所有英文字符替换为大写字母。 spam = 'Hello world!' spam = spam.upper() return spam isupper 判断字符串是否全为大写字母。 return 'HELLO'.isupper() return '12345'.isupper() lower 将字符串中的所有英文字符替换为小写字母。 return 'Hello'.lower() islower 判断字符串是否全为小写字母。 return 'hello'.islower() return '12345'.islower() isalpha 判断字符串是否以大写字母开头。 isalnum 判断字符串是否只有数字和字母并且不为空。 isdecimal 判断字符串是否只有数字。 isspace 判断字符串是否只有空格、制表符、换行符。 istitle 判断字符串中的每一个单词是否均以大写字母开头。 startswith 判断字符串是否以另一个字符串开头。 return 'Hello world!'.startswith('Hello') return 'abc123'.startswith('abcdef') return 'Hello world!'.startswith('Hello world!') endswith 判断字符串是否以另一个字符串结束。 return 'Hello world!'.endswith('world!') return 'abc123'.endswith('12') return 'Hello world!'.endswith('Hello world!') split 将一个字符串以某个字符串作为分隔符，分成一个字符串列表。 return 'My name is Simon'.split() return 'MyABCnameABCisABCSimon'.split('ABC') return 'My name is Simon'.split('m') join 将一个字符串列表使用这个字符串作为分隔符进行拼接。 return ', '.join(['cats', 'rats', 'bats']) return ' '.join(['My', 'name', 'is', 'Simon']) return 'ABC'.join(['My', 'name', 'is', 'Simon']) ljust 将一个字符串使用空格扩展为指定长度，并向左对齐。 return 'Hello'.ljust(10) return 'Hello'.ljust(20, '-') center 将一个字符串使用空格扩展为指定长度，并居中对齐。 return 'Hello'.center(20) return 'Hello'.center(20, '=') rjust 将一个字符串使用空格扩展为指定长度，并向右对齐。 return 'Hello'.rjust(10) return 'Hello'.rjust(20) return 'Hello World'.rjust(20) return 'Hello'.rjust(20, '*') 字符串格式化 % 运算符 使用 C 语言风格的格式化。 name = 'Pete' return 'Hello %s' % name 格式控制字符与 C 语言中的相同： num = 5 return 'I have %x apples' % num format 方法 Python 面向对象的语言一个函数是在类内部，那么我们称它为方法。 name = 'John' age = 20 print('Hello I\\'m {}, my age is {}'.format(name, age)) print(\"Hello I'm {0}, my age is {1}\".format(name, age)) 格式字符串 string.Template from string import Template name = 'Elizabeth' t = Template('Hey $name!') return t.substitute(name=name) 格式字符串 name = 'Elizabeth' return f'Hello {name}!' a = 5 b = 10 return f'Five plus ten is {a + b} and not {2 * (a + b)}.' 原始字符串 在原始字符串中，不会对 \\ 及之后的字符进行转义，通常用于正则表达式的定义中。 print(r'That is Carol\\'s cat.') 字符串转义字符 转义字符 意义 \\' 单引号 \\\" 双引号 \\t 制表符 \\n 换行符 \\\\ 反斜杠 多行字符串 使用 ''' 包裹，允许在字符串中直接进行换行。 print('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''') 布尔值 a = True # False print(a) print(type(a)) 逻辑比较运算符 不要使用 == 或 != ，而是使用 is 或 is not 用于布尔值的比较。 错误的示例： return True == True return True != False 正确的示例： return True is True return True is not False 逻辑运算符 与 表达式 结果 True and True True True and False False False and True False False and False False 或 表达式 结果 True or True True True or False True False or True True False or False False 非 表达式 结果 not True False ","date":"2022-03-02","objectID":"/posts/notes/python/:1:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#数字"},{"categories":null,"content":"基本数据类型 数字 整数 a = 1 print(a) print(type(a)) 浮点数 a = 1.0 print(a) print(type(a)) 比较运算符 运算符 意义 == 相等 != 不相等 \u003c 小于 \u003e 大于 \u003c= 小于等于 \u003e= 大于等于 return 42 == 42 return 40 == 42 return 'hello' == 'hello' return 'hello' == 'Hello' return 'dog' != 'cat' return 42 == 42.0 return 42 == '42' 此外，比较运算符可以连续使用，即 a \u003c x \u003c b 是允许的。 return 70 \u003c x \u003c 90 算术运算符 优先级从高到低如下： 运算符 意义 示例 ** 指数 2 ** 3 = 8 % 求余 22 % 8 = 6 // 整除 22 // 8 = 2 / 除法 22 / 8 = 2.75 * 乘法 3 * 3 = 9 - 减法 5 - 2 = 3 + 加法 2 + 2 = 4 return 2 // 3 return (2 + 3) * 6 return 2 ** 8 return 23 // 7 return 23 % 7 return (5 - 1) * ((7 + 1) / (3 - 1)) 增量赋值运算符 运算符 等价表达式 spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 字符串 a = 'Hello Python' print(a) print(type(a)) 常用操作 拼接 return 'Alice' 'Bob' 重复 return 'Alice' * 5 访问 元素 spam = 'Hello world!' print(spam[0]) print(spam[4]) print(spam[-1]) 切片 spam = 'Hello world!' print(spam[0:5]) print(spam[0:5:2]) print(spam[:5]) print(spam[6:]) print(spam[6:-1]) print(spam[:-1]) print(spam[::-1]) 包含 return 'Hello' in 'Hello World' return 'Hello' in 'Hello' return 'HELLO' in 'Hello World' return '' in 'spam' return 'cats' not in 'cats and dogs' 方法 strip 移除字符串两边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.strip() lstrip 移除字符串左边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.lstrip() rstrip 移除字符串右边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.rstrip() upper 将字符串中的所有英文字符替换为大写字母。 spam = 'Hello world!' spam = spam.upper() return spam isupper 判断字符串是否全为大写字母。 return 'HELLO'.isupper() return '12345'.isupper() lower 将字符串中的所有英文字符替换为小写字母。 return 'Hello'.lower() islower 判断字符串是否全为小写字母。 return 'hello'.islower() return '12345'.islower() isalpha 判断字符串是否以大写字母开头。 isalnum 判断字符串是否只有数字和字母并且不为空。 isdecimal 判断字符串是否只有数字。 isspace 判断字符串是否只有空格、制表符、换行符。 istitle 判断字符串中的每一个单词是否均以大写字母开头。 startswith 判断字符串是否以另一个字符串开头。 return 'Hello world!'.startswith('Hello') return 'abc123'.startswith('abcdef') return 'Hello world!'.startswith('Hello world!') endswith 判断字符串是否以另一个字符串结束。 return 'Hello world!'.endswith('world!') return 'abc123'.endswith('12') return 'Hello world!'.endswith('Hello world!') split 将一个字符串以某个字符串作为分隔符，分成一个字符串列表。 return 'My name is Simon'.split() return 'MyABCnameABCisABCSimon'.split('ABC') return 'My name is Simon'.split('m') join 将一个字符串列表使用这个字符串作为分隔符进行拼接。 return ', '.join(['cats', 'rats', 'bats']) return ' '.join(['My', 'name', 'is', 'Simon']) return 'ABC'.join(['My', 'name', 'is', 'Simon']) ljust 将一个字符串使用空格扩展为指定长度，并向左对齐。 return 'Hello'.ljust(10) return 'Hello'.ljust(20, '-') center 将一个字符串使用空格扩展为指定长度，并居中对齐。 return 'Hello'.center(20) return 'Hello'.center(20, '=') rjust 将一个字符串使用空格扩展为指定长度，并向右对齐。 return 'Hello'.rjust(10) return 'Hello'.rjust(20) return 'Hello World'.rjust(20) return 'Hello'.rjust(20, '*') 字符串格式化 % 运算符 使用 C 语言风格的格式化。 name = 'Pete' return 'Hello %s' % name 格式控制字符与 C 语言中的相同： num = 5 return 'I have %x apples' % num format 方法 Python 面向对象的语言一个函数是在类内部，那么我们称它为方法。 name = 'John' age = 20 print('Hello I\\'m {}, my age is {}'.format(name, age)) print(\"Hello I'm {0}, my age is {1}\".format(name, age)) 格式字符串 string.Template from string import Template name = 'Elizabeth' t = Template('Hey $name!') return t.substitute(name=name) 格式字符串 name = 'Elizabeth' return f'Hello {name}!' a = 5 b = 10 return f'Five plus ten is {a + b} and not {2 * (a + b)}.' 原始字符串 在原始字符串中，不会对 \\ 及之后的字符进行转义，通常用于正则表达式的定义中。 print(r'That is Carol\\'s cat.') 字符串转义字符 转义字符 意义 \\' 单引号 \\\" 双引号 \\t 制表符 \\n 换行符 \\\\ 反斜杠 多行字符串 使用 ''' 包裹，允许在字符串中直接进行换行。 print('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''') 布尔值 a = True # False print(a) print(type(a)) 逻辑比较运算符 不要使用 == 或 != ，而是使用 is 或 is not 用于布尔值的比较。 错误的示例： return True == True return True != False 正确的示例： return True is True return True is not False 逻辑运算符 与 表达式 结果 True and True True True and False False False and True False False and False False 或 表达式 结果 True or True True True or False True False or True True False or False False 非 表达式 结果 not True False ","date":"2022-03-02","objectID":"/posts/notes/python/:1:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#字符串"},{"categories":null,"content":"基本数据类型 数字 整数 a = 1 print(a) print(type(a)) 浮点数 a = 1.0 print(a) print(type(a)) 比较运算符 运算符 意义 == 相等 != 不相等 \u003c 小于 \u003e 大于 \u003c= 小于等于 \u003e= 大于等于 return 42 == 42 return 40 == 42 return 'hello' == 'hello' return 'hello' == 'Hello' return 'dog' != 'cat' return 42 == 42.0 return 42 == '42' 此外，比较运算符可以连续使用，即 a \u003c x \u003c b 是允许的。 return 70 \u003c x \u003c 90 算术运算符 优先级从高到低如下： 运算符 意义 示例 ** 指数 2 ** 3 = 8 % 求余 22 % 8 = 6 // 整除 22 // 8 = 2 / 除法 22 / 8 = 2.75 * 乘法 3 * 3 = 9 - 减法 5 - 2 = 3 + 加法 2 + 2 = 4 return 2 // 3 return (2 + 3) * 6 return 2 ** 8 return 23 // 7 return 23 % 7 return (5 - 1) * ((7 + 1) / (3 - 1)) 增量赋值运算符 运算符 等价表达式 spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 字符串 a = 'Hello Python' print(a) print(type(a)) 常用操作 拼接 return 'Alice' 'Bob' 重复 return 'Alice' * 5 访问 元素 spam = 'Hello world!' print(spam[0]) print(spam[4]) print(spam[-1]) 切片 spam = 'Hello world!' print(spam[0:5]) print(spam[0:5:2]) print(spam[:5]) print(spam[6:]) print(spam[6:-1]) print(spam[:-1]) print(spam[::-1]) 包含 return 'Hello' in 'Hello World' return 'Hello' in 'Hello' return 'HELLO' in 'Hello World' return '' in 'spam' return 'cats' not in 'cats and dogs' 方法 strip 移除字符串两边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.strip() lstrip 移除字符串左边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.lstrip() rstrip 移除字符串右边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.rstrip() upper 将字符串中的所有英文字符替换为大写字母。 spam = 'Hello world!' spam = spam.upper() return spam isupper 判断字符串是否全为大写字母。 return 'HELLO'.isupper() return '12345'.isupper() lower 将字符串中的所有英文字符替换为小写字母。 return 'Hello'.lower() islower 判断字符串是否全为小写字母。 return 'hello'.islower() return '12345'.islower() isalpha 判断字符串是否以大写字母开头。 isalnum 判断字符串是否只有数字和字母并且不为空。 isdecimal 判断字符串是否只有数字。 isspace 判断字符串是否只有空格、制表符、换行符。 istitle 判断字符串中的每一个单词是否均以大写字母开头。 startswith 判断字符串是否以另一个字符串开头。 return 'Hello world!'.startswith('Hello') return 'abc123'.startswith('abcdef') return 'Hello world!'.startswith('Hello world!') endswith 判断字符串是否以另一个字符串结束。 return 'Hello world!'.endswith('world!') return 'abc123'.endswith('12') return 'Hello world!'.endswith('Hello world!') split 将一个字符串以某个字符串作为分隔符，分成一个字符串列表。 return 'My name is Simon'.split() return 'MyABCnameABCisABCSimon'.split('ABC') return 'My name is Simon'.split('m') join 将一个字符串列表使用这个字符串作为分隔符进行拼接。 return ', '.join(['cats', 'rats', 'bats']) return ' '.join(['My', 'name', 'is', 'Simon']) return 'ABC'.join(['My', 'name', 'is', 'Simon']) ljust 将一个字符串使用空格扩展为指定长度，并向左对齐。 return 'Hello'.ljust(10) return 'Hello'.ljust(20, '-') center 将一个字符串使用空格扩展为指定长度，并居中对齐。 return 'Hello'.center(20) return 'Hello'.center(20, '=') rjust 将一个字符串使用空格扩展为指定长度，并向右对齐。 return 'Hello'.rjust(10) return 'Hello'.rjust(20) return 'Hello World'.rjust(20) return 'Hello'.rjust(20, '*') 字符串格式化 % 运算符 使用 C 语言风格的格式化。 name = 'Pete' return 'Hello %s' % name 格式控制字符与 C 语言中的相同： num = 5 return 'I have %x apples' % num format 方法 Python 面向对象的语言一个函数是在类内部，那么我们称它为方法。 name = 'John' age = 20 print('Hello I\\'m {}, my age is {}'.format(name, age)) print(\"Hello I'm {0}, my age is {1}\".format(name, age)) 格式字符串 string.Template from string import Template name = 'Elizabeth' t = Template('Hey $name!') return t.substitute(name=name) 格式字符串 name = 'Elizabeth' return f'Hello {name}!' a = 5 b = 10 return f'Five plus ten is {a + b} and not {2 * (a + b)}.' 原始字符串 在原始字符串中，不会对 \\ 及之后的字符进行转义，通常用于正则表达式的定义中。 print(r'That is Carol\\'s cat.') 字符串转义字符 转义字符 意义 \\' 单引号 \\\" 双引号 \\t 制表符 \\n 换行符 \\\\ 反斜杠 多行字符串 使用 ''' 包裹，允许在字符串中直接进行换行。 print('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''') 布尔值 a = True # False print(a) print(type(a)) 逻辑比较运算符 不要使用 == 或 != ，而是使用 is 或 is not 用于布尔值的比较。 错误的示例： return True == True return True != False 正确的示例： return True is True return True is not False 逻辑运算符 与 表达式 结果 True and True True True and False False False and True False False and False False 或 表达式 结果 True or True True True or False True False or True True False or False False 非 表达式 结果 not True False ","date":"2022-03-02","objectID":"/posts/notes/python/:1:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#布尔值"},{"categories":null,"content":"基本数据类型 数字 整数 a = 1 print(a) print(type(a)) 浮点数 a = 1.0 print(a) print(type(a)) 比较运算符 运算符 意义 == 相等 != 不相等 \u003c 小于 \u003e 大于 \u003c= 小于等于 \u003e= 大于等于 return 42 == 42 return 40 == 42 return 'hello' == 'hello' return 'hello' == 'Hello' return 'dog' != 'cat' return 42 == 42.0 return 42 == '42' 此外，比较运算符可以连续使用，即 a \u003c x \u003c b 是允许的。 return 70 \u003c x \u003c 90 算术运算符 优先级从高到低如下： 运算符 意义 示例 ** 指数 2 ** 3 = 8 % 求余 22 % 8 = 6 // 整除 22 // 8 = 2 / 除法 22 / 8 = 2.75 * 乘法 3 * 3 = 9 - 减法 5 - 2 = 3 + 加法 2 + 2 = 4 return 2 // 3 return (2 + 3) * 6 return 2 ** 8 return 23 // 7 return 23 % 7 return (5 - 1) * ((7 + 1) / (3 - 1)) 增量赋值运算符 运算符 等价表达式 spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 字符串 a = 'Hello Python' print(a) print(type(a)) 常用操作 拼接 return 'Alice' 'Bob' 重复 return 'Alice' * 5 访问 元素 spam = 'Hello world!' print(spam[0]) print(spam[4]) print(spam[-1]) 切片 spam = 'Hello world!' print(spam[0:5]) print(spam[0:5:2]) print(spam[:5]) print(spam[6:]) print(spam[6:-1]) print(spam[:-1]) print(spam[::-1]) 包含 return 'Hello' in 'Hello World' return 'Hello' in 'Hello' return 'HELLO' in 'Hello World' return '' in 'spam' return 'cats' not in 'cats and dogs' 方法 strip 移除字符串两边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.strip() lstrip 移除字符串左边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.lstrip() rstrip 移除字符串右边的指定字符（默认为空白字符）。 spam = ' Hello World ' return spam.rstrip() upper 将字符串中的所有英文字符替换为大写字母。 spam = 'Hello world!' spam = spam.upper() return spam isupper 判断字符串是否全为大写字母。 return 'HELLO'.isupper() return '12345'.isupper() lower 将字符串中的所有英文字符替换为小写字母。 return 'Hello'.lower() islower 判断字符串是否全为小写字母。 return 'hello'.islower() return '12345'.islower() isalpha 判断字符串是否以大写字母开头。 isalnum 判断字符串是否只有数字和字母并且不为空。 isdecimal 判断字符串是否只有数字。 isspace 判断字符串是否只有空格、制表符、换行符。 istitle 判断字符串中的每一个单词是否均以大写字母开头。 startswith 判断字符串是否以另一个字符串开头。 return 'Hello world!'.startswith('Hello') return 'abc123'.startswith('abcdef') return 'Hello world!'.startswith('Hello world!') endswith 判断字符串是否以另一个字符串结束。 return 'Hello world!'.endswith('world!') return 'abc123'.endswith('12') return 'Hello world!'.endswith('Hello world!') split 将一个字符串以某个字符串作为分隔符，分成一个字符串列表。 return 'My name is Simon'.split() return 'MyABCnameABCisABCSimon'.split('ABC') return 'My name is Simon'.split('m') join 将一个字符串列表使用这个字符串作为分隔符进行拼接。 return ', '.join(['cats', 'rats', 'bats']) return ' '.join(['My', 'name', 'is', 'Simon']) return 'ABC'.join(['My', 'name', 'is', 'Simon']) ljust 将一个字符串使用空格扩展为指定长度，并向左对齐。 return 'Hello'.ljust(10) return 'Hello'.ljust(20, '-') center 将一个字符串使用空格扩展为指定长度，并居中对齐。 return 'Hello'.center(20) return 'Hello'.center(20, '=') rjust 将一个字符串使用空格扩展为指定长度，并向右对齐。 return 'Hello'.rjust(10) return 'Hello'.rjust(20) return 'Hello World'.rjust(20) return 'Hello'.rjust(20, '*') 字符串格式化 % 运算符 使用 C 语言风格的格式化。 name = 'Pete' return 'Hello %s' % name 格式控制字符与 C 语言中的相同： num = 5 return 'I have %x apples' % num format 方法 Python 面向对象的语言一个函数是在类内部，那么我们称它为方法。 name = 'John' age = 20 print('Hello I\\'m {}, my age is {}'.format(name, age)) print(\"Hello I'm {0}, my age is {1}\".format(name, age)) 格式字符串 string.Template from string import Template name = 'Elizabeth' t = Template('Hey $name!') return t.substitute(name=name) 格式字符串 name = 'Elizabeth' return f'Hello {name}!' a = 5 b = 10 return f'Five plus ten is {a + b} and not {2 * (a + b)}.' 原始字符串 在原始字符串中，不会对 \\ 及之后的字符进行转义，通常用于正则表达式的定义中。 print(r'That is Carol\\'s cat.') 字符串转义字符 转义字符 意义 \\' 单引号 \\\" 双引号 \\t 制表符 \\n 换行符 \\\\ 反斜杠 多行字符串 使用 ''' 包裹，允许在字符串中直接进行换行。 print('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''') 布尔值 a = True # False print(a) print(type(a)) 逻辑比较运算符 不要使用 == 或 != ，而是使用 is 或 is not 用于布尔值的比较。 错误的示例： return True == True return True != False 正确的示例： return True is True return True is not False 逻辑运算符 与 表达式 结果 True and True True True and False False False and True False False and False False 或 表达式 结果 True or True True True or False True False or True True False or False False 非 表达式 结果 not True False ","date":"2022-03-02","objectID":"/posts/notes/python/:1:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#空值"},{"categories":null,"content":"容器 列表 a = [1, \"2\", True] print(a) print(type(a)) 常用操作 获取长度 spam = ['cat', 'dog', 'moose'] return len(spam) 访问 元素 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0]) print(spam[1]) print(spam[2]) print(spam[3]) print(spam[-1]) 切片 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1]) spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[:2]) print(spam[1:]) print(spam[:]) 移除元素 spam = ['cat', 'bat', 'rat', 'elephant'] del spam[2] print(spam) 修改元素 spam = ['cat', 'bat', 'rat', 'elephant'] spam[1] = 'aardvark' print(spam) spam[2] = spam[1] print(spam) spam[-1] = 12345 print(spam) 拼接 sum 函数 a = [1,2] b = [3,4] c = [5,6] return sum((a,b,c), []) + 其实调用的是 list 对象的 __add__ 方法 list01 = [1,2,3] list02 = [4,5,6] return list01 + list02 * 解包 list01 = [1,2,3] list02 = [4,5,6] return [*list01, *list02] extend 方法 在原有内容的基础上扩展，在后面拼接一个可迭代的对象，没有返回值，会改变调用列表的内容。 列表推导式 list1 = [1, 2, 3] list2 = [4, 5, 6] return [x for l in (list1, list2) for x in l] 把最开始的 i 单独拿出来，后面看作一个嵌套的 for 语句就好了。相当于于下面的 Scala 代码： val list1 = 1 :: 2 :: 3 :: Nil val list2 = 4 :: 5 :: 6 :: Nil for { l \u003c- list1 :: list2 :: Nil x \u003c- l } yield x 遍历 仅遍历元素 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for supply in supplies: print('Current supply is: {}'.format(supply)) 与下标一起遍历 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for i, supply in enumerate(supplies): print('Index {} in supplies is: {}'.format(str(i), supply)) 拉链 name = ['Pete', 'John', 'Elizabeth'] age = [6, 23, 44] for n, a in zip(name, age): print('{} is {} years old'.format(n, a)) 包含元素 return 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] spam = ['hello', 'hi', 'howdy', 'heyas'] print('howdy' not in spam) print('cat' not in spam) 解构 通常我们可以这样给多个变量赋予列表中元素的值： cat = ['fat', 'orange', 'loud'] size = cat[0] color = cat[1] disposition = cat[2] print(size, color, disposition) 同时我们还可以通过解构的形式进行赋值： cat = ['fat', 'orange', 'loud'] size, color, disposition = cat print(size, color, disposition) 排序 使用 sorted 函数无副作用地进行排序，返回一个新的列表： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] return sorted(spam) 重复 return ['X', 'Y', 'Z'] * 3 方法 index 定位一个元素的下标。 spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] return spam.index('Pooka') append 在列表后面添加元素。 spam = ['cat', 'dog', 'bat'] spam.append('moose') return spam insert 在列表中间插入元素。 spam = ['cat', 'dog', 'bat'] spam.insert(1, 'chicken') return spam remove 移除列表中指定元素。 spam = ['cat', 'bat', 'rat', 'elephant'] spam.remove('bat') return spam sort 对数字列表进行排序： spam = [2, 5, 3.14, 1, -7] spam.sort() return spam 对字符串列表进行排序： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] spam.sort() return spam 倒序排序： spam = [2, 5, 3.14, 1, -7] spam.sort(reverse=True) return spam 指定排序使用的函数（排序依据）： spam = ['a', 'z', 'A', 'Z'] spam.sort(key=str.lower) return spam 列表推导式 a = [1, 3, 5, 7, 9, 11] return [i - 1 for i in a] 元组 a = (1, 2.0, \"3\", False) print(a) print(type(a)) 元素的使用方式与列表类似，与列表的区别在于元组是不可变的，效率通常更高。 eggs = ('hello', 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs)) 字典 键（key）:值（value） a = { \"a\": 1, 2: 3.0, False: None } print(a) print(type(a)) 通过键来进行索引。 myCat = { 0 : 'fat', 1: 'gray', 2: 'loud' } print(myCat[0]) 常用操作 解包创建 可以从解包的字典或者命名参数中构造一个字典。注意字典中不能有相同的键，否则会报错。 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return { **dic1, **dic2, **dic3 } 相当于 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return dict(**dic1, **dic2, **dic3) 相当于 return dict(name='A', level=1, age=18) 包含 包含键 spam = {'name': 'Zophie', 'age': 7 } return 'name' in spam.keys() 也可以直接省略 keys 方法： spam = {'name': 'Zophie', 'age': 7} print('color' in spam) print('color' not in spam) 包含值 spam = {'name': 'Zophie', 'age': 7} return 'Zophie' in spam.values() 美观地打印 import pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint(count) 合并 # in Python 3.5+: x = {'a': 1, 'b': 2} y = {'b': 3, 'c': 4}","date":"2022-03-02","objectID":"/posts/notes/python/:1:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#容器"},{"categories":null,"content":"容器 列表 a = [1, \"2\", True] print(a) print(type(a)) 常用操作 获取长度 spam = ['cat', 'dog', 'moose'] return len(spam) 访问 元素 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0]) print(spam[1]) print(spam[2]) print(spam[3]) print(spam[-1]) 切片 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1]) spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[:2]) print(spam[1:]) print(spam[:]) 移除元素 spam = ['cat', 'bat', 'rat', 'elephant'] del spam[2] print(spam) 修改元素 spam = ['cat', 'bat', 'rat', 'elephant'] spam[1] = 'aardvark' print(spam) spam[2] = spam[1] print(spam) spam[-1] = 12345 print(spam) 拼接 sum 函数 a = [1,2] b = [3,4] c = [5,6] return sum((a,b,c), []) + 其实调用的是 list 对象的 __add__ 方法 list01 = [1,2,3] list02 = [4,5,6] return list01 + list02 * 解包 list01 = [1,2,3] list02 = [4,5,6] return [*list01, *list02] extend 方法 在原有内容的基础上扩展，在后面拼接一个可迭代的对象，没有返回值，会改变调用列表的内容。 列表推导式 list1 = [1, 2, 3] list2 = [4, 5, 6] return [x for l in (list1, list2) for x in l] 把最开始的 i 单独拿出来，后面看作一个嵌套的 for 语句就好了。相当于于下面的 Scala 代码： val list1 = 1 :: 2 :: 3 :: Nil val list2 = 4 :: 5 :: 6 :: Nil for { l \u003c- list1 :: list2 :: Nil x \u003c- l } yield x 遍历 仅遍历元素 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for supply in supplies: print('Current supply is: {}'.format(supply)) 与下标一起遍历 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for i, supply in enumerate(supplies): print('Index {} in supplies is: {}'.format(str(i), supply)) 拉链 name = ['Pete', 'John', 'Elizabeth'] age = [6, 23, 44] for n, a in zip(name, age): print('{} is {} years old'.format(n, a)) 包含元素 return 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] spam = ['hello', 'hi', 'howdy', 'heyas'] print('howdy' not in spam) print('cat' not in spam) 解构 通常我们可以这样给多个变量赋予列表中元素的值： cat = ['fat', 'orange', 'loud'] size = cat[0] color = cat[1] disposition = cat[2] print(size, color, disposition) 同时我们还可以通过解构的形式进行赋值： cat = ['fat', 'orange', 'loud'] size, color, disposition = cat print(size, color, disposition) 排序 使用 sorted 函数无副作用地进行排序，返回一个新的列表： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] return sorted(spam) 重复 return ['X', 'Y', 'Z'] * 3 方法 index 定位一个元素的下标。 spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] return spam.index('Pooka') append 在列表后面添加元素。 spam = ['cat', 'dog', 'bat'] spam.append('moose') return spam insert 在列表中间插入元素。 spam = ['cat', 'dog', 'bat'] spam.insert(1, 'chicken') return spam remove 移除列表中指定元素。 spam = ['cat', 'bat', 'rat', 'elephant'] spam.remove('bat') return spam sort 对数字列表进行排序： spam = [2, 5, 3.14, 1, -7] spam.sort() return spam 对字符串列表进行排序： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] spam.sort() return spam 倒序排序： spam = [2, 5, 3.14, 1, -7] spam.sort(reverse=True) return spam 指定排序使用的函数（排序依据）： spam = ['a', 'z', 'A', 'Z'] spam.sort(key=str.lower) return spam 列表推导式 a = [1, 3, 5, 7, 9, 11] return [i - 1 for i in a] 元组 a = (1, 2.0, \"3\", False) print(a) print(type(a)) 元素的使用方式与列表类似，与列表的区别在于元组是不可变的，效率通常更高。 eggs = ('hello', 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs)) 字典 键（key）:值（value） a = { \"a\": 1, 2: 3.0, False: None } print(a) print(type(a)) 通过键来进行索引。 myCat = { 0 : 'fat', 1: 'gray', 2: 'loud' } print(myCat[0]) 常用操作 解包创建 可以从解包的字典或者命名参数中构造一个字典。注意字典中不能有相同的键，否则会报错。 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return { **dic1, **dic2, **dic3 } 相当于 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return dict(**dic1, **dic2, **dic3) 相当于 return dict(name='A', level=1, age=18) 包含 包含键 spam = {'name': 'Zophie', 'age': 7 } return 'name' in spam.keys() 也可以直接省略 keys 方法： spam = {'name': 'Zophie', 'age': 7} print('color' in spam) print('color' not in spam) 包含值 spam = {'name': 'Zophie', 'age': 7} return 'Zophie' in spam.values() 美观地打印 import pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint(count) 合并 # in Python 3.5+: x = {'a': 1, 'b': 2} y = {'b': 3, 'c': 4}","date":"2022-03-02","objectID":"/posts/notes/python/:1:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#列表"},{"categories":null,"content":"容器 列表 a = [1, \"2\", True] print(a) print(type(a)) 常用操作 获取长度 spam = ['cat', 'dog', 'moose'] return len(spam) 访问 元素 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0]) print(spam[1]) print(spam[2]) print(spam[3]) print(spam[-1]) 切片 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1]) spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[:2]) print(spam[1:]) print(spam[:]) 移除元素 spam = ['cat', 'bat', 'rat', 'elephant'] del spam[2] print(spam) 修改元素 spam = ['cat', 'bat', 'rat', 'elephant'] spam[1] = 'aardvark' print(spam) spam[2] = spam[1] print(spam) spam[-1] = 12345 print(spam) 拼接 sum 函数 a = [1,2] b = [3,4] c = [5,6] return sum((a,b,c), []) + 其实调用的是 list 对象的 __add__ 方法 list01 = [1,2,3] list02 = [4,5,6] return list01 + list02 * 解包 list01 = [1,2,3] list02 = [4,5,6] return [*list01, *list02] extend 方法 在原有内容的基础上扩展，在后面拼接一个可迭代的对象，没有返回值，会改变调用列表的内容。 列表推导式 list1 = [1, 2, 3] list2 = [4, 5, 6] return [x for l in (list1, list2) for x in l] 把最开始的 i 单独拿出来，后面看作一个嵌套的 for 语句就好了。相当于于下面的 Scala 代码： val list1 = 1 :: 2 :: 3 :: Nil val list2 = 4 :: 5 :: 6 :: Nil for { l \u003c- list1 :: list2 :: Nil x \u003c- l } yield x 遍历 仅遍历元素 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for supply in supplies: print('Current supply is: {}'.format(supply)) 与下标一起遍历 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for i, supply in enumerate(supplies): print('Index {} in supplies is: {}'.format(str(i), supply)) 拉链 name = ['Pete', 'John', 'Elizabeth'] age = [6, 23, 44] for n, a in zip(name, age): print('{} is {} years old'.format(n, a)) 包含元素 return 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] spam = ['hello', 'hi', 'howdy', 'heyas'] print('howdy' not in spam) print('cat' not in spam) 解构 通常我们可以这样给多个变量赋予列表中元素的值： cat = ['fat', 'orange', 'loud'] size = cat[0] color = cat[1] disposition = cat[2] print(size, color, disposition) 同时我们还可以通过解构的形式进行赋值： cat = ['fat', 'orange', 'loud'] size, color, disposition = cat print(size, color, disposition) 排序 使用 sorted 函数无副作用地进行排序，返回一个新的列表： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] return sorted(spam) 重复 return ['X', 'Y', 'Z'] * 3 方法 index 定位一个元素的下标。 spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] return spam.index('Pooka') append 在列表后面添加元素。 spam = ['cat', 'dog', 'bat'] spam.append('moose') return spam insert 在列表中间插入元素。 spam = ['cat', 'dog', 'bat'] spam.insert(1, 'chicken') return spam remove 移除列表中指定元素。 spam = ['cat', 'bat', 'rat', 'elephant'] spam.remove('bat') return spam sort 对数字列表进行排序： spam = [2, 5, 3.14, 1, -7] spam.sort() return spam 对字符串列表进行排序： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] spam.sort() return spam 倒序排序： spam = [2, 5, 3.14, 1, -7] spam.sort(reverse=True) return spam 指定排序使用的函数（排序依据）： spam = ['a', 'z', 'A', 'Z'] spam.sort(key=str.lower) return spam 列表推导式 a = [1, 3, 5, 7, 9, 11] return [i - 1 for i in a] 元组 a = (1, 2.0, \"3\", False) print(a) print(type(a)) 元素的使用方式与列表类似，与列表的区别在于元组是不可变的，效率通常更高。 eggs = ('hello', 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs)) 字典 键（key）:值（value） a = { \"a\": 1, 2: 3.0, False: None } print(a) print(type(a)) 通过键来进行索引。 myCat = { 0 : 'fat', 1: 'gray', 2: 'loud' } print(myCat[0]) 常用操作 解包创建 可以从解包的字典或者命名参数中构造一个字典。注意字典中不能有相同的键，否则会报错。 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return { **dic1, **dic2, **dic3 } 相当于 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return dict(**dic1, **dic2, **dic3) 相当于 return dict(name='A', level=1, age=18) 包含 包含键 spam = {'name': 'Zophie', 'age': 7 } return 'name' in spam.keys() 也可以直接省略 keys 方法： spam = {'name': 'Zophie', 'age': 7} print('color' in spam) print('color' not in spam) 包含值 spam = {'name': 'Zophie', 'age': 7} return 'Zophie' in spam.values() 美观地打印 import pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint(count) 合并 # in Python 3.5+: x = {'a': 1, 'b': 2} y = {'b': 3, 'c': 4}","date":"2022-03-02","objectID":"/posts/notes/python/:1:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#元组"},{"categories":null,"content":"容器 列表 a = [1, \"2\", True] print(a) print(type(a)) 常用操作 获取长度 spam = ['cat', 'dog', 'moose'] return len(spam) 访问 元素 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0]) print(spam[1]) print(spam[2]) print(spam[3]) print(spam[-1]) 切片 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1]) spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[:2]) print(spam[1:]) print(spam[:]) 移除元素 spam = ['cat', 'bat', 'rat', 'elephant'] del spam[2] print(spam) 修改元素 spam = ['cat', 'bat', 'rat', 'elephant'] spam[1] = 'aardvark' print(spam) spam[2] = spam[1] print(spam) spam[-1] = 12345 print(spam) 拼接 sum 函数 a = [1,2] b = [3,4] c = [5,6] return sum((a,b,c), []) + 其实调用的是 list 对象的 __add__ 方法 list01 = [1,2,3] list02 = [4,5,6] return list01 + list02 * 解包 list01 = [1,2,3] list02 = [4,5,6] return [*list01, *list02] extend 方法 在原有内容的基础上扩展，在后面拼接一个可迭代的对象，没有返回值，会改变调用列表的内容。 列表推导式 list1 = [1, 2, 3] list2 = [4, 5, 6] return [x for l in (list1, list2) for x in l] 把最开始的 i 单独拿出来，后面看作一个嵌套的 for 语句就好了。相当于于下面的 Scala 代码： val list1 = 1 :: 2 :: 3 :: Nil val list2 = 4 :: 5 :: 6 :: Nil for { l \u003c- list1 :: list2 :: Nil x \u003c- l } yield x 遍历 仅遍历元素 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for supply in supplies: print('Current supply is: {}'.format(supply)) 与下标一起遍历 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for i, supply in enumerate(supplies): print('Index {} in supplies is: {}'.format(str(i), supply)) 拉链 name = ['Pete', 'John', 'Elizabeth'] age = [6, 23, 44] for n, a in zip(name, age): print('{} is {} years old'.format(n, a)) 包含元素 return 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] spam = ['hello', 'hi', 'howdy', 'heyas'] print('howdy' not in spam) print('cat' not in spam) 解构 通常我们可以这样给多个变量赋予列表中元素的值： cat = ['fat', 'orange', 'loud'] size = cat[0] color = cat[1] disposition = cat[2] print(size, color, disposition) 同时我们还可以通过解构的形式进行赋值： cat = ['fat', 'orange', 'loud'] size, color, disposition = cat print(size, color, disposition) 排序 使用 sorted 函数无副作用地进行排序，返回一个新的列表： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] return sorted(spam) 重复 return ['X', 'Y', 'Z'] * 3 方法 index 定位一个元素的下标。 spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] return spam.index('Pooka') append 在列表后面添加元素。 spam = ['cat', 'dog', 'bat'] spam.append('moose') return spam insert 在列表中间插入元素。 spam = ['cat', 'dog', 'bat'] spam.insert(1, 'chicken') return spam remove 移除列表中指定元素。 spam = ['cat', 'bat', 'rat', 'elephant'] spam.remove('bat') return spam sort 对数字列表进行排序： spam = [2, 5, 3.14, 1, -7] spam.sort() return spam 对字符串列表进行排序： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] spam.sort() return spam 倒序排序： spam = [2, 5, 3.14, 1, -7] spam.sort(reverse=True) return spam 指定排序使用的函数（排序依据）： spam = ['a', 'z', 'A', 'Z'] spam.sort(key=str.lower) return spam 列表推导式 a = [1, 3, 5, 7, 9, 11] return [i - 1 for i in a] 元组 a = (1, 2.0, \"3\", False) print(a) print(type(a)) 元素的使用方式与列表类似，与列表的区别在于元组是不可变的，效率通常更高。 eggs = ('hello', 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs)) 字典 键（key）:值（value） a = { \"a\": 1, 2: 3.0, False: None } print(a) print(type(a)) 通过键来进行索引。 myCat = { 0 : 'fat', 1: 'gray', 2: 'loud' } print(myCat[0]) 常用操作 解包创建 可以从解包的字典或者命名参数中构造一个字典。注意字典中不能有相同的键，否则会报错。 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return { **dic1, **dic2, **dic3 } 相当于 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return dict(**dic1, **dic2, **dic3) 相当于 return dict(name='A', level=1, age=18) 包含 包含键 spam = {'name': 'Zophie', 'age': 7 } return 'name' in spam.keys() 也可以直接省略 keys 方法： spam = {'name': 'Zophie', 'age': 7} print('color' in spam) print('color' not in spam) 包含值 spam = {'name': 'Zophie', 'age': 7} return 'Zophie' in spam.values() 美观地打印 import pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint(count) 合并 # in Python 3.5+: x = {'a': 1, 'b': 2} y = {'b': 3, 'c': 4}","date":"2022-03-02","objectID":"/posts/notes/python/:1:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#字典"},{"categories":null,"content":"容器 列表 a = [1, \"2\", True] print(a) print(type(a)) 常用操作 获取长度 spam = ['cat', 'dog', 'moose'] return len(spam) 访问 元素 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0]) print(spam[1]) print(spam[2]) print(spam[3]) print(spam[-1]) 切片 spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[0:4]) print(spam[1:3]) print(spam[0:-1]) spam = ['cat', 'bat', 'rat', 'elephant'] print(spam[:2]) print(spam[1:]) print(spam[:]) 移除元素 spam = ['cat', 'bat', 'rat', 'elephant'] del spam[2] print(spam) 修改元素 spam = ['cat', 'bat', 'rat', 'elephant'] spam[1] = 'aardvark' print(spam) spam[2] = spam[1] print(spam) spam[-1] = 12345 print(spam) 拼接 sum 函数 a = [1,2] b = [3,4] c = [5,6] return sum((a,b,c), []) + 其实调用的是 list 对象的 __add__ 方法 list01 = [1,2,3] list02 = [4,5,6] return list01 + list02 * 解包 list01 = [1,2,3] list02 = [4,5,6] return [*list01, *list02] extend 方法 在原有内容的基础上扩展，在后面拼接一个可迭代的对象，没有返回值，会改变调用列表的内容。 列表推导式 list1 = [1, 2, 3] list2 = [4, 5, 6] return [x for l in (list1, list2) for x in l] 把最开始的 i 单独拿出来，后面看作一个嵌套的 for 语句就好了。相当于于下面的 Scala 代码： val list1 = 1 :: 2 :: 3 :: Nil val list2 = 4 :: 5 :: 6 :: Nil for { l \u003c- list1 :: list2 :: Nil x \u003c- l } yield x 遍历 仅遍历元素 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for supply in supplies: print('Current supply is: {}'.format(supply)) 与下标一起遍历 supplies = ['pens', 'staplers', 'flame-throwers', 'binders'] for i, supply in enumerate(supplies): print('Index {} in supplies is: {}'.format(str(i), supply)) 拉链 name = ['Pete', 'John', 'Elizabeth'] age = [6, 23, 44] for n, a in zip(name, age): print('{} is {} years old'.format(n, a)) 包含元素 return 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] spam = ['hello', 'hi', 'howdy', 'heyas'] print('howdy' not in spam) print('cat' not in spam) 解构 通常我们可以这样给多个变量赋予列表中元素的值： cat = ['fat', 'orange', 'loud'] size = cat[0] color = cat[1] disposition = cat[2] print(size, color, disposition) 同时我们还可以通过解构的形式进行赋值： cat = ['fat', 'orange', 'loud'] size, color, disposition = cat print(size, color, disposition) 排序 使用 sorted 函数无副作用地进行排序，返回一个新的列表： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] return sorted(spam) 重复 return ['X', 'Y', 'Z'] * 3 方法 index 定位一个元素的下标。 spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] return spam.index('Pooka') append 在列表后面添加元素。 spam = ['cat', 'dog', 'bat'] spam.append('moose') return spam insert 在列表中间插入元素。 spam = ['cat', 'dog', 'bat'] spam.insert(1, 'chicken') return spam remove 移除列表中指定元素。 spam = ['cat', 'bat', 'rat', 'elephant'] spam.remove('bat') return spam sort 对数字列表进行排序： spam = [2, 5, 3.14, 1, -7] spam.sort() return spam 对字符串列表进行排序： spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] spam.sort() return spam 倒序排序： spam = [2, 5, 3.14, 1, -7] spam.sort(reverse=True) return spam 指定排序使用的函数（排序依据）： spam = ['a', 'z', 'A', 'Z'] spam.sort(key=str.lower) return spam 列表推导式 a = [1, 3, 5, 7, 9, 11] return [i - 1 for i in a] 元组 a = (1, 2.0, \"3\", False) print(a) print(type(a)) 元素的使用方式与列表类似，与列表的区别在于元组是不可变的，效率通常更高。 eggs = ('hello', 42, 0.5) print(eggs[0]) print(eggs[1:3]) print(len(eggs)) 字典 键（key）:值（value） a = { \"a\": 1, 2: 3.0, False: None } print(a) print(type(a)) 通过键来进行索引。 myCat = { 0 : 'fat', 1: 'gray', 2: 'loud' } print(myCat[0]) 常用操作 解包创建 可以从解包的字典或者命名参数中构造一个字典。注意字典中不能有相同的键，否则会报错。 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return { **dic1, **dic2, **dic3 } 相当于 dic1 = { 'name': 'A' } dic2 = { 'level': 1 } dic3 = { 'age': 18 } return dict(**dic1, **dic2, **dic3) 相当于 return dict(name='A', level=1, age=18) 包含 包含键 spam = {'name': 'Zophie', 'age': 7 } return 'name' in spam.keys() 也可以直接省略 keys 方法： spam = {'name': 'Zophie', 'age': 7} print('color' in spam) print('color' not in spam) 包含值 spam = {'name': 'Zophie', 'age': 7} return 'Zophie' in spam.values() 美观地打印 import pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint(count) 合并 # in Python 3.5+: x = {'a': 1, 'b': 2} y = {'b': 3, 'c': 4}","date":"2022-03-02","objectID":"/posts/notes/python/:1:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#集合"},{"categories":null,"content":"类 class MyClass: member2 = 2.0 def __init__(self, i): self.member1 = i def method(self): self.member3 = \"3\" my_class = MyClass(1) print(my_class.member1) print(my_class.member2) my_class.method() print(my_class.member3) 继承 例如： class First(object): def __init__(self): super().__init__() print(\"First\") class Second(First): def __init__(self): super().__init__() print(\"Second\") class Third(First): def __init__(self): super().__init__() print(\"Third\") class Fourth(Second, Third): def __init__(self): super(Fourth, self).__init__() print(\"Fourth\") Fourth() flowchart BT A[First] B[Second] C[Third] D[Fourth] D --\u003e B D --\u003e C B --\u003e A C --\u003e A 由于 First 是 Second 和 Third 的父类，要保证父类的构造器只调用一次因此在 Fourth 的构造器中，按照继承顺序，先调用 Second 再通过 Third 调用 First 的构造器。区别于Mixin： trait Initiatable { def init() = () } trait First extends Initiatable { override def init() = { super.init() println(\"First\") } } trait Second extends First { override def init() = { super.init() println(\"Second\") } } trait Third extends First { override def init() = { super.init() println(\"Third\") } } trait Fourth extends Second, Third { override def init() = { super.init() println(\"Fourth\") } } new Fourth {}.init() ","date":"2022-03-02","objectID":"/posts/notes/python/:1:3","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#类"},{"categories":null,"content":"类 class MyClass: member2 = 2.0 def __init__(self, i): self.member1 = i def method(self): self.member3 = \"3\" my_class = MyClass(1) print(my_class.member1) print(my_class.member2) my_class.method() print(my_class.member3) 继承 例如： class First(object): def __init__(self): super().__init__() print(\"First\") class Second(First): def __init__(self): super().__init__() print(\"Second\") class Third(First): def __init__(self): super().__init__() print(\"Third\") class Fourth(Second, Third): def __init__(self): super(Fourth, self).__init__() print(\"Fourth\") Fourth() flowchart BT A[First] B[Second] C[Third] D[Fourth] D --\u003e B D --\u003e C B --\u003e A C --\u003e A 由于 First 是 Second 和 Third 的父类，要保证父类的构造器只调用一次因此在 Fourth 的构造器中，按照继承顺序，先调用 Second 再通过 Third 调用 First 的构造器。区别于Mixin： trait Initiatable { def init() = () } trait First extends Initiatable { override def init() = { super.init() println(\"First\") } } trait Second extends First { override def init() = { super.init() println(\"Second\") } } trait Third extends First { override def init() = { super.init() println(\"Third\") } } trait Fourth extends Second, Third { override def init() = { super.init() println(\"Fourth\") } } new Fourth {}.init() ","date":"2022-03-02","objectID":"/posts/notes/python/:1:3","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#继承"},{"categories":null,"content":"程序结构 ","date":"2022-03-02","objectID":"/posts/notes/python/:2:0","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#程序结构"},{"categories":null,"content":"缩进 如果要表示没有语句的结构，可以使用： pass 关键字 ... 是一个 ellipsis 类型的单例对象，可以代替 pass 或构造一些语法糖。 可以显式使用 end 结束一个缩进块。 ","date":"2022-03-02","objectID":"/posts/notes/python/:2:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#缩进"},{"categories":null,"content":"变量 spam = 'Hello' print(spam) 作用域 def spam(): global eggs eggs = 'spam' eggs = 'global' spam() print(eggs) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#变量"},{"categories":null,"content":"变量 spam = 'Hello' print(spam) 作用域 def spam(): global eggs eggs = 'spam' eggs = 'global' spam() print(eggs) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:2","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#作用域"},{"categories":null,"content":"注释 单行注释： # This is a comment 多行注释： # This is a # multiline comment 和代码一起的注释： a = 1 # initialization 函数文档： def foo(): \"\"\" This is a function docstring You can also use: ''' Function Docstring ''' \"\"\" ","date":"2022-03-02","objectID":"/posts/notes/python/:2:3","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#注释"},{"categories":null,"content":"控制流 条件语句 if ... if name == 'Alice': print('Hi, Alice.') if ... else ... name = 'Bob' if name == 'Alice': print('Hi, Alice.') else: print('Hello, stranger.') if ... elif ... else ... name = 'Bob' age = 5 if name == 'Alice': print('Hi, Alice.') elif age \u003c 12: print('You are not Alice, kiddo.') name = 'Bob' age = 30 if name == 'Alice': print('Hi, Alice.') elif age \u003c 12: print('You are not Alice, kiddo.') else: print('You are neither Alice nor a little kid.') 三目运算符 age = 15 print('kid' if age \u003e 18 else 'adult') 三目运算符可以串接使用： age = 15 print('kid' if age \u003c 13 else 'teenager' if age \u003c 18 else 'adult') 以上代码等价于： if age \u003c 18: if age \u003c 12: print('kid') else: print('teenager') else: print('adult') assert 用检查条件，防止代码执行意料外的行为。 pod_bay_door_status = 'open' assert pod_bay_door_status == 'open', 'The pod bay doors need to be \"open\".' pod_bay_door_status = 'I\\'m sorry, Dave. I\\'m afraid I can\\'t do that.' assert pod_bay_door_status == 'open', 'The pod bay doors need to be \"open\".' 循环语句 while spam = 0 while spam \u003c 5: print('Hello, world.') spam = spam + 1 break while True: print('Please type your name.') name = input() if name == 'your name': break print('Thank you!') continue while True: print('Who are you?') name = input() if name != 'Joe': continue print('Hello, Joe. What is the password? (It is a fish.)') password = input() if password == 'swordfish': break print('Access granted.') for print('My name is') for i in range(10): print('Jimmy Five Times ({})'.format(str(i))) for ... else ... 只有在 for 循环体全部正常执行时才会执行 else 语句块。 for i in [1, 2, 3, 4, 5]: if i == 3: break else: print(\"only executed when no item of the list is equal to 3\") ","date":"2022-03-02","objectID":"/posts/notes/python/:2:4","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#控制流"},{"categories":null,"content":"控制流 条件语句 if ... if name == 'Alice': print('Hi, Alice.') if ... else ... name = 'Bob' if name == 'Alice': print('Hi, Alice.') else: print('Hello, stranger.') if ... elif ... else ... name = 'Bob' age = 5 if name == 'Alice': print('Hi, Alice.') elif age \u003c 12: print('You are not Alice, kiddo.') name = 'Bob' age = 30 if name == 'Alice': print('Hi, Alice.') elif age \u003c 12: print('You are not Alice, kiddo.') else: print('You are neither Alice nor a little kid.') 三目运算符 age = 15 print('kid' if age \u003e 18 else 'adult') 三目运算符可以串接使用： age = 15 print('kid' if age \u003c 13 else 'teenager' if age \u003c 18 else 'adult') 以上代码等价于： if age \u003c 18: if age \u003c 12: print('kid') else: print('teenager') else: print('adult') assert 用检查条件，防止代码执行意料外的行为。 pod_bay_door_status = 'open' assert pod_bay_door_status == 'open', 'The pod bay doors need to be \"open\".' pod_bay_door_status = 'I\\'m sorry, Dave. I\\'m afraid I can\\'t do that.' assert pod_bay_door_status == 'open', 'The pod bay doors need to be \"open\".' 循环语句 while spam = 0 while spam \u003c 5: print('Hello, world.') spam = spam + 1 break while True: print('Please type your name.') name = input() if name == 'your name': break print('Thank you!') continue while True: print('Who are you?') name = input() if name != 'Joe': continue print('Hello, Joe. What is the password? (It is a fish.)') password = input() if password == 'swordfish': break print('Access granted.') for print('My name is') for i in range(10): print('Jimmy Five Times ({})'.format(str(i))) for ... else ... 只有在 for 循环体全部正常执行时才会执行 else 语句块。 for i in [1, 2, 3, 4, 5]: if i == 3: break else: print(\"only executed when no item of the list is equal to 3\") ","date":"2022-03-02","objectID":"/posts/notes/python/:2:4","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#条件语句"},{"categories":null,"content":"控制流 条件语句 if ... if name == 'Alice': print('Hi, Alice.') if ... else ... name = 'Bob' if name == 'Alice': print('Hi, Alice.') else: print('Hello, stranger.') if ... elif ... else ... name = 'Bob' age = 5 if name == 'Alice': print('Hi, Alice.') elif age \u003c 12: print('You are not Alice, kiddo.') name = 'Bob' age = 30 if name == 'Alice': print('Hi, Alice.') elif age \u003c 12: print('You are not Alice, kiddo.') else: print('You are neither Alice nor a little kid.') 三目运算符 age = 15 print('kid' if age \u003e 18 else 'adult') 三目运算符可以串接使用： age = 15 print('kid' if age \u003c 13 else 'teenager' if age \u003c 18 else 'adult') 以上代码等价于： if age \u003c 18: if age \u003c 12: print('kid') else: print('teenager') else: print('adult') assert 用检查条件，防止代码执行意料外的行为。 pod_bay_door_status = 'open' assert pod_bay_door_status == 'open', 'The pod bay doors need to be \"open\".' pod_bay_door_status = 'I\\'m sorry, Dave. I\\'m afraid I can\\'t do that.' assert pod_bay_door_status == 'open', 'The pod bay doors need to be \"open\".' 循环语句 while spam = 0 while spam \u003c 5: print('Hello, world.') spam = spam + 1 break while True: print('Please type your name.') name = input() if name == 'your name': break print('Thank you!') continue while True: print('Who are you?') name = input() if name != 'Joe': continue print('Hello, Joe. What is the password? (It is a fish.)') password = input() if password == 'swordfish': break print('Access granted.') for print('My name is') for i in range(10): print('Jimmy Five Times ({})'.format(str(i))) for ... else ... 只有在 for 循环体全部正常执行时才会执行 else 语句块。 for i in [1, 2, 3, 4, 5]: if i == 3: break else: print(\"only executed when no item of the list is equal to 3\") ","date":"2022-03-02","objectID":"/posts/notes/python/:2:4","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#循环语句"},{"categories":null,"content":"导入 import random for i in range(5): print(random.randint(1, 10)) import random, sys, os, math from random import * ","date":"2022-03-02","objectID":"/posts/notes/python/:2:5","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#导入"},{"categories":null,"content":"函数 def hello(name): print('Hello {}'.format(name)) hello('World!') 常用函数 print 打印到控制台。 print('Hello world!') a = 1 print('Hello world!', a) 参数 end print('Hello', end='') print('World') sep print('cats', 'dogs', 'mice', sep=',') input 等待用户控制台输入。 print('What is your name?') # ask for their name myName = input() print('It is good to meet you, {}'.format(myName)) len 得到一个（实现了 __len__ 方法的）对象的长度。 字符串的长度： return len('hello') 判断列表、元组、字典等容器是否为空，推荐将它们隐式转换为布尔值，而不是使用 len 函数： a = [1, 2, 3] if a: print(\"the list is not empty!\") enumerate enumerate(arr) 相当于 zip(range(len(arr)), arr) 。使可迭代对象和下标一起迭代。 sort 原地进行排序。 key ：由元素得到可比较对象的函数 类型转换函数 包括 str 、 int 、 float 等。 return str(29) print('I am {} years old.'.format(str(29))) return int('3.123') 可迭代对象之间也可以互相转换： return tuple(['cat', 'dog', 5]) return list(('cat', 'dog', 5)) return list('hello') s = {1, 2, 3} print(s) s = set([1, 2, 3]) print(s) 可选参数 def show(arg1, arg2, *args, kwarg1=None, kwarg2=None, **kwargs): print(arg1) print(arg2) print(args) print(kwarg1) print(kwarg2) print(kwargs) data1 = [1,2,3] data2 = [4,5,6] data3 = {'a':7,'b':8,'c':9} show(*data1,*data2, kwarg1=\"python\",kwarg2=\"cheatsheet\",**data3) print() show(*data1, *data2, **data3) print() show(*data1, *data2, *data3) *arg 可变参数，传参有两种方式： 直接传参：多个实参构成一个列表 列表传参：使用 *arr 来把一个列表当作参数传入 def fruits(*args): for fruit in args: print(fruit) fruits(\"apples\", \"bananas\", \"grapes\") **kwarg 字典如果使用 * 进行解包，将变成字典中所有键构成的列表。 def fruit(**kwargs): for key, value in kwargs.items(): print(\"{0}: {1}\".format(key, value)) fruit(name = \"apple\", color = \"red\") 返回值 import random def get_answer(answerNumber): if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' elif answerNumber == 4: return 'Reply hazy try again' elif answerNumber == 5: return 'Ask again later' elif answerNumber == 6: return 'Concentrate and ask again' elif answerNumber == 7: return 'My reply is no' elif answerNumber == 8: return 'Outlook not so good' elif answerNumber == 9: return 'Very doubtful' r = random.randint(1, 9) fortune = get_answer(r) print(fortune) 匿名函数 匿名函数。 def make_adder(n): return lambda x: x + n plus_3 = make_adder(3) return plus_5(4) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:6","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#函数"},{"categories":null,"content":"函数 def hello(name): print('Hello {}'.format(name)) hello('World!') 常用函数 print 打印到控制台。 print('Hello world!') a = 1 print('Hello world!', a) 参数 end print('Hello', end='') print('World') sep print('cats', 'dogs', 'mice', sep=',') input 等待用户控制台输入。 print('What is your name?') # ask for their name myName = input() print('It is good to meet you, {}'.format(myName)) len 得到一个（实现了 __len__ 方法的）对象的长度。 字符串的长度： return len('hello') 判断列表、元组、字典等容器是否为空，推荐将它们隐式转换为布尔值，而不是使用 len 函数： a = [1, 2, 3] if a: print(\"the list is not empty!\") enumerate enumerate(arr) 相当于 zip(range(len(arr)), arr) 。使可迭代对象和下标一起迭代。 sort 原地进行排序。 key ：由元素得到可比较对象的函数 类型转换函数 包括 str 、 int 、 float 等。 return str(29) print('I am {} years old.'.format(str(29))) return int('3.123') 可迭代对象之间也可以互相转换： return tuple(['cat', 'dog', 5]) return list(('cat', 'dog', 5)) return list('hello') s = {1, 2, 3} print(s) s = set([1, 2, 3]) print(s) 可选参数 def show(arg1, arg2, *args, kwarg1=None, kwarg2=None, **kwargs): print(arg1) print(arg2) print(args) print(kwarg1) print(kwarg2) print(kwargs) data1 = [1,2,3] data2 = [4,5,6] data3 = {'a':7,'b':8,'c':9} show(*data1,*data2, kwarg1=\"python\",kwarg2=\"cheatsheet\",**data3) print() show(*data1, *data2, **data3) print() show(*data1, *data2, *data3) *arg 可变参数，传参有两种方式： 直接传参：多个实参构成一个列表 列表传参：使用 *arr 来把一个列表当作参数传入 def fruits(*args): for fruit in args: print(fruit) fruits(\"apples\", \"bananas\", \"grapes\") **kwarg 字典如果使用 * 进行解包，将变成字典中所有键构成的列表。 def fruit(**kwargs): for key, value in kwargs.items(): print(\"{0}: {1}\".format(key, value)) fruit(name = \"apple\", color = \"red\") 返回值 import random def get_answer(answerNumber): if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' elif answerNumber == 4: return 'Reply hazy try again' elif answerNumber == 5: return 'Ask again later' elif answerNumber == 6: return 'Concentrate and ask again' elif answerNumber == 7: return 'My reply is no' elif answerNumber == 8: return 'Outlook not so good' elif answerNumber == 9: return 'Very doubtful' r = random.randint(1, 9) fortune = get_answer(r) print(fortune) 匿名函数 匿名函数。 def make_adder(n): return lambda x: x + n plus_3 = make_adder(3) return plus_5(4) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:6","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#可选参数"},{"categories":null,"content":"函数 def hello(name): print('Hello {}'.format(name)) hello('World!') 常用函数 print 打印到控制台。 print('Hello world!') a = 1 print('Hello world!', a) 参数 end print('Hello', end='') print('World') sep print('cats', 'dogs', 'mice', sep=',') input 等待用户控制台输入。 print('What is your name?') # ask for their name myName = input() print('It is good to meet you, {}'.format(myName)) len 得到一个（实现了 __len__ 方法的）对象的长度。 字符串的长度： return len('hello') 判断列表、元组、字典等容器是否为空，推荐将它们隐式转换为布尔值，而不是使用 len 函数： a = [1, 2, 3] if a: print(\"the list is not empty!\") enumerate enumerate(arr) 相当于 zip(range(len(arr)), arr) 。使可迭代对象和下标一起迭代。 sort 原地进行排序。 key ：由元素得到可比较对象的函数 类型转换函数 包括 str 、 int 、 float 等。 return str(29) print('I am {} years old.'.format(str(29))) return int('3.123') 可迭代对象之间也可以互相转换： return tuple(['cat', 'dog', 5]) return list(('cat', 'dog', 5)) return list('hello') s = {1, 2, 3} print(s) s = set([1, 2, 3]) print(s) 可选参数 def show(arg1, arg2, *args, kwarg1=None, kwarg2=None, **kwargs): print(arg1) print(arg2) print(args) print(kwarg1) print(kwarg2) print(kwargs) data1 = [1,2,3] data2 = [4,5,6] data3 = {'a':7,'b':8,'c':9} show(*data1,*data2, kwarg1=\"python\",kwarg2=\"cheatsheet\",**data3) print() show(*data1, *data2, **data3) print() show(*data1, *data2, *data3) *arg 可变参数，传参有两种方式： 直接传参：多个实参构成一个列表 列表传参：使用 *arr 来把一个列表当作参数传入 def fruits(*args): for fruit in args: print(fruit) fruits(\"apples\", \"bananas\", \"grapes\") **kwarg 字典如果使用 * 进行解包，将变成字典中所有键构成的列表。 def fruit(**kwargs): for key, value in kwargs.items(): print(\"{0}: {1}\".format(key, value)) fruit(name = \"apple\", color = \"red\") 返回值 import random def get_answer(answerNumber): if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' elif answerNumber == 4: return 'Reply hazy try again' elif answerNumber == 5: return 'Ask again later' elif answerNumber == 6: return 'Concentrate and ask again' elif answerNumber == 7: return 'My reply is no' elif answerNumber == 8: return 'Outlook not so good' elif answerNumber == 9: return 'Very doubtful' r = random.randint(1, 9) fortune = get_answer(r) print(fortune) 匿名函数 匿名函数。 def make_adder(n): return lambda x: x + n plus_3 = make_adder(3) return plus_5(4) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:6","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#返回值"},{"categories":null,"content":"函数 def hello(name): print('Hello {}'.format(name)) hello('World!') 常用函数 print 打印到控制台。 print('Hello world!') a = 1 print('Hello world!', a) 参数 end print('Hello', end='') print('World') sep print('cats', 'dogs', 'mice', sep=',') input 等待用户控制台输入。 print('What is your name?') # ask for their name myName = input() print('It is good to meet you, {}'.format(myName)) len 得到一个（实现了 __len__ 方法的）对象的长度。 字符串的长度： return len('hello') 判断列表、元组、字典等容器是否为空，推荐将它们隐式转换为布尔值，而不是使用 len 函数： a = [1, 2, 3] if a: print(\"the list is not empty!\") enumerate enumerate(arr) 相当于 zip(range(len(arr)), arr) 。使可迭代对象和下标一起迭代。 sort 原地进行排序。 key ：由元素得到可比较对象的函数 类型转换函数 包括 str 、 int 、 float 等。 return str(29) print('I am {} years old.'.format(str(29))) return int('3.123') 可迭代对象之间也可以互相转换： return tuple(['cat', 'dog', 5]) return list(('cat', 'dog', 5)) return list('hello') s = {1, 2, 3} print(s) s = set([1, 2, 3]) print(s) 可选参数 def show(arg1, arg2, *args, kwarg1=None, kwarg2=None, **kwargs): print(arg1) print(arg2) print(args) print(kwarg1) print(kwarg2) print(kwargs) data1 = [1,2,3] data2 = [4,5,6] data3 = {'a':7,'b':8,'c':9} show(*data1,*data2, kwarg1=\"python\",kwarg2=\"cheatsheet\",**data3) print() show(*data1, *data2, **data3) print() show(*data1, *data2, *data3) *arg 可变参数，传参有两种方式： 直接传参：多个实参构成一个列表 列表传参：使用 *arr 来把一个列表当作参数传入 def fruits(*args): for fruit in args: print(fruit) fruits(\"apples\", \"bananas\", \"grapes\") **kwarg 字典如果使用 * 进行解包，将变成字典中所有键构成的列表。 def fruit(**kwargs): for key, value in kwargs.items(): print(\"{0}: {1}\".format(key, value)) fruit(name = \"apple\", color = \"red\") 返回值 import random def get_answer(answerNumber): if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' elif answerNumber == 4: return 'Reply hazy try again' elif answerNumber == 5: return 'Ask again later' elif answerNumber == 6: return 'Concentrate and ask again' elif answerNumber == 7: return 'My reply is no' elif answerNumber == 8: return 'Outlook not so good' elif answerNumber == 9: return 'Very doubtful' r = random.randint(1, 9) fortune = get_answer(r) print(fortune) 匿名函数 匿名函数。 def make_adder(n): return lambda x: x + n plus_3 = make_adder(3) return plus_5(4) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:6","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#匿名函数"},{"categories":null,"content":"异常处理 函数返回优先级 在 try 中的 return 被执行前，会先调用 finally 中的语句。如果 finally 中有 return 语句，则会从 finally 中直接返回，否则会回到 try 中返回。 try ... except ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) try ... except ... finally ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) finally: print(\"-- division finished --\") print(spam(12)) print(spam(0)) raise 抛出一个异常。 def box_print(symbol, width, height): if len(symbol) != 1: raise Exception('Symbol must be a single character string.') if width \u003c= 2: raise Exception('Width must be greater than 2.') if height \u003c= 2: raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) for sym, w, h in (('*', 4, 4), ('O', 20, 5), ('x', 1, 3), ('ZZ', 3, 3)): try: box_print(sym, w, h) except Exception as err: print('An exception happened: ' + str(err)) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:7","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#异常处理"},{"categories":null,"content":"异常处理 函数返回优先级 在 try 中的 return 被执行前，会先调用 finally 中的语句。如果 finally 中有 return 语句，则会从 finally 中直接返回，否则会回到 try 中返回。 try ... except ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) try ... except ... finally ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) finally: print(\"-- division finished --\") print(spam(12)) print(spam(0)) raise 抛出一个异常。 def box_print(symbol, width, height): if len(symbol) != 1: raise Exception('Symbol must be a single character string.') if width \u003c= 2: raise Exception('Width must be greater than 2.') if height \u003c= 2: raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) for sym, w, h in (('*', 4, 4), ('O', 20, 5), ('x', 1, 3), ('ZZ', 3, 3)): try: box_print(sym, w, h) except Exception as err: print('An exception happened: ' + str(err)) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:7","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#try-dot-dot-dot-except-dot-dot-dot"},{"categories":null,"content":"异常处理 函数返回优先级 在 try 中的 return 被执行前，会先调用 finally 中的语句。如果 finally 中有 return 语句，则会从 finally 中直接返回，否则会回到 try 中返回。 try ... except ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) try ... except ... finally ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) finally: print(\"-- division finished --\") print(spam(12)) print(spam(0)) raise 抛出一个异常。 def box_print(symbol, width, height): if len(symbol) != 1: raise Exception('Symbol must be a single character string.') if width \u003c= 2: raise Exception('Width must be greater than 2.') if height \u003c= 2: raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) for sym, w, h in (('*', 4, 4), ('O', 20, 5), ('x', 1, 3), ('ZZ', 3, 3)): try: box_print(sym, w, h) except Exception as err: print('An exception happened: ' + str(err)) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:7","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#try-dot-dot-dot-except-dot-dot-dot-finally-dot-dot-dot"},{"categories":null,"content":"异常处理 函数返回优先级 在 try 中的 return 被执行前，会先调用 finally 中的语句。如果 finally 中有 return 语句，则会从 finally 中直接返回，否则会回到 try 中返回。 try ... except ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) try ... except ... finally ... def spam(divideBy): try: return 42 / divideBy except ZeroDivisionError as e: print('Error: Invalid argument: {}'.format(e)) finally: print(\"-- division finished --\") print(spam(12)) print(spam(0)) raise 抛出一个异常。 def box_print(symbol, width, height): if len(symbol) != 1: raise Exception('Symbol must be a single character string.') if width \u003c= 2: raise Exception('Width must be greater than 2.') if height \u003c= 2: raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) for sym, w, h in (('*', 4, 4), ('O', 20, 5), ('x', 1, 3), ('ZZ', 3, 3)): try: box_print(sym, w, h) except Exception as err: print('An exception happened: ' + str(err)) ","date":"2022-03-02","objectID":"/posts/notes/python/:2:7","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#raise"},{"categories":null,"content":"上下管理器 with 语句可以利用对象的特定的方法来自动进行资源的请求与释放，从而避免使用 try ... catch ... finally 这样的异常处理语句。 方法： __enter__ ：在 with 之后语句执行之后调用，返回值赋给 as 后面的变量。 __exit__ ：保证在 with 块执行完成或异常终止后一定会调用的方法。 exc_type ：异常类型 exc_val ：异常的值 exc_tb 代码中异常抛出的位置 示例： with open(\"path/to/file\") as file: data = file.read() 相当于 try: f = open('path/to/file') except: ... finally: f.close() ","date":"2022-03-02","objectID":"/posts/notes/python/:2:8","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#上下管理器"},{"categories":null,"content":"运行环境 ","date":"2022-03-02","objectID":"/posts/notes/python/:3:0","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#运行环境"},{"categories":null,"content":"解释器 特殊变量 __name__ 当一个文件直接作为脚本执行或一个模块通过 python -m 调用执行时， __name__ 的值为 __main__ 。 def main(): pass if __name__ == '__main__': main() ","date":"2022-03-02","objectID":"/posts/notes/python/:3:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#解释器"},{"categories":null,"content":"解释器 特殊变量 __name__ 当一个文件直接作为脚本执行或一个模块通过 python -m 调用执行时， __name__ 的值为 __main__ 。 def main(): pass if __name__ == '__main__': main() ","date":"2022-03-02","objectID":"/posts/notes/python/:3:1","series":null,"tags":["Python","编程语言"],"title":"Python","uri":"/posts/notes/python/#特殊变量"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 运行流程 STM32在复位后，先从 0X08000004 地址取出复位中断向量的地址，并跳转到复位中断服务程序 在复位中断服务程序执行完之后，会跳转到的 main 函数 在 main 函数执行过程中，如果收到中断请求（发生重中断），此时STM32强制将PC指针指回中断向量表处 根据中断源进入相应的中断服务程序 在执行完中断服务程序以后，程序再次返回main函数执行 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:0:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#"},{"categories":null,"content":"编程 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:1:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#编程"},{"categories":null,"content":"IAP (In Application Programming) ","date":"2022-03-02","objectID":"/posts/notes/stm32/:1:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#iap--in-application-programming"},{"categories":null,"content":"启动 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:2:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#启动"},{"categories":null,"content":"启动文件（*.s） 包含用汇编编写的启动代码 初始化堆栈指针 SP 初始化程序计数器指针 PC 设置堆、栈的大小 设置中断向量表的入口地址 配置外部 SRAM 作为数据存储器（这个由用户配置，一般的开发板可没有外部 SRAM） 调用 SystemInit() 函数配置 STM32 的系统时钟 设置C库的分支入口 __main （最终用来调用 main() 函数） ","date":"2022-03-02","objectID":"/posts/notes/stm32/:2:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#启动文件-dot-s"},{"categories":null,"content":"接口 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:3:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#接口"},{"categories":null,"content":"I2S 基本上与SPI接口共享资源（引脚和寄存器）。 工作模式 两种模式均可进行发送和接收，只是主机负责发送信号触发传输。 主模式 从模式 传输模式 全双工模式 半双工模式 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:3:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#i2s--通信协议-dot-md"},{"categories":null,"content":"I2S 基本上与SPI接口共享资源（引脚和寄存器）。 工作模式 两种模式均可进行发送和接收，只是主机负责发送信号触发传输。 主模式 从模式 传输模式 全双工模式 半双工模式 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:3:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#工作模式"},{"categories":null,"content":"I2S 基本上与SPI接口共享资源（引脚和寄存器）。 工作模式 两种模式均可进行发送和接收，只是主机负责发送信号触发传输。 主模式 从模式 传输模式 全双工模式 半双工模式 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:3:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#传输模式"},{"categories":null,"content":"DMA ","date":"2022-03-02","objectID":"/posts/notes/stm32/:4:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#dma"},{"categories":null,"content":"双缓冲模式 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:4:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#双缓冲模式"},{"categories":null,"content":"定时器 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#定时器"},{"categories":null,"content":"输入捕获模式 捕获的电平发生指定的变化时，CPU会将计数寄存器的值复制到捕获比较寄存器中并开始计数。当再次捕捉到指定的电平变化时，计数寄存器中的值减去刚才复制的值就是这段电平的持续时间。通常用于频率测量。 捕获模式 上升沿捕获 下降沿捕获 上升沿下降沿 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#输入捕获模式"},{"categories":null,"content":"输出比较模式 TIM_OCMode_Timing ：输出比较时间模式（输出引脚冻结无效） TIM_OCMode_Active ：输出比较主动模式（匹配时设置输出引脚为有效电平，当计数值为比较/捕获寄存器值相同时，强制输出为高电平） TIM_OCMode_Inactive ：输出比较非主动模式（匹配时设置输出引脚为无效电平，当计数值为比较/捕获寄存器值相同时，强制输出为低电平） TIM_OCMode_Toggle ：输出比较翻转触发模式（当计数值与比较/捕获寄存器值相同时，翻转输出引脚的电平） TIM_OCMode_PWM1 ：向上计数时，当 TIMx_CNT \u003c TIMx_CCR* 时，输出电平有效，否则为无效；向下计数时，当 TIMx_CNT \u003e TIMx_CCR* 时，输出电平无效，否则为有效 PWM模式 可以看作同步、固定频率的输出比较模式。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:2","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#输出比较模式"},{"categories":null,"content":"输出比较模式 TIM_OCMode_Timing ：输出比较时间模式（输出引脚冻结无效） TIM_OCMode_Active ：输出比较主动模式（匹配时设置输出引脚为有效电平，当计数值为比较/捕获寄存器值相同时，强制输出为高电平） TIM_OCMode_Inactive ：输出比较非主动模式（匹配时设置输出引脚为无效电平，当计数值为比较/捕获寄存器值相同时，强制输出为低电平） TIM_OCMode_Toggle ：输出比较翻转触发模式（当计数值与比较/捕获寄存器值相同时，翻转输出引脚的电平） TIM_OCMode_PWM1 ：向上计数时，当 TIMx_CNT \u003c TIMx_CCR* 时，输出电平有效，否则为无效；向下计数时，当 TIMx_CNT \u003e TIMx_CCR* 时，输出电平无效，否则为有效 PWM模式 可以看作同步、固定频率的输出比较模式。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:2","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#pwm模式"},{"categories":null,"content":"编码器模式 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:3","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#编码器模式"},{"categories":null,"content":"计数器 向上计数 向下计数 中心对齐 到达计数器的最大/小值后自动改变计数器的计数方向，使计数器的值在最大值和最小值之间波动。 模式1 模式2 模式3 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:4","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#计数器"},{"categories":null,"content":"计数器 向上计数 向下计数 中心对齐 到达计数器的最大/小值后自动改变计数器的计数方向，使计数器的值在最大值和最小值之间波动。 模式1 模式2 模式3 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:4","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#向上计数"},{"categories":null,"content":"计数器 向上计数 向下计数 中心对齐 到达计数器的最大/小值后自动改变计数器的计数方向，使计数器的值在最大值和最小值之间波动。 模式1 模式2 模式3 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:4","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#向下计数"},{"categories":null,"content":"计数器 向上计数 向下计数 中心对齐 到达计数器的最大/小值后自动改变计数器的计数方向，使计数器的值在最大值和最小值之间波动。 模式1 模式2 模式3 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:4","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#中心对齐"},{"categories":null,"content":"预分频器（Prescaler） 用于设定计数器增减的快慢。定时器的时钟源Tick一次，预分频器的计数+1。 到达 预分频器的设定值后，分频器的计数 再次 +1导致预分频器的计数溢出清零，同时对定时器的计数器进行增减。 影子寄存器（缓冲功能） 在定时器启动后更改 TIMx_PSC 的值并不会立即影响当前定时器的时钟频率。要等到下一个更新事件（UEV）发生时才会生效。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:5","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#预分频器-prescaler"},{"categories":null,"content":"预分频器（Prescaler） 用于设定计数器增减的快慢。定时器的时钟源Tick一次，预分频器的计数+1。 到达 预分频器的设定值后，分频器的计数 再次 +1导致预分频器的计数溢出清零，同时对定时器的计数器进行增减。 影子寄存器（缓冲功能） 在定时器启动后更改 TIMx_PSC 的值并不会立即影响当前定时器的时钟频率。要等到下一个更新事件（UEV）发生时才会生效。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:5","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#影子寄存器-缓冲功能"},{"categories":null,"content":"周期 \\[\\frac{1+\\text{TIM\\_Prescaler}}{\\text{Clock}}\\times (1+\\text{TIM\\_Period})\\] ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:6","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#周期"},{"categories":null,"content":"种类 基本定时器 通用定时器 高级定时器 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:7","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#种类"},{"categories":null,"content":"种类 基本定时器 通用定时器 高级定时器 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:7","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#基本定时器"},{"categories":null,"content":"种类 基本定时器 通用定时器 高级定时器 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:7","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#通用定时器"},{"categories":null,"content":"种类 基本定时器 通用定时器 高级定时器 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:7","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#高级定时器"},{"categories":null,"content":"中断 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:5:8","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#中断"},{"categories":null,"content":"中断 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:0","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#中断"},{"categories":null,"content":"中断向量 本质上是一个指针，中断程序入口。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:1","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#中断向量"},{"categories":null,"content":"NVIC（嵌套中断向量控制器） 负责除了SYSTICK之外的所有中断的控制。大部分系统中断也走NVIC通道，所以系统中断优先级未必高于外部中断。 抢占优先级（Preemption Priority） 高抢占优先级的中断事件会打断当前的主程序/低抢占优先级的中断程序运行，称抢断式优先响应，俗称中断嵌套。 响应优先级（Subpriority） 抢占优先级相同的情况下，比较响应优先级。 优先级分组 Cortex-M3是用8位来配置优先级的，即给每个中断配发8位的身份证，这8位中用几位来表示抢占级，用几位来表示响应级，就由分组来进行规定。 Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下： NVIC_PriorityGroup_0 ：所有4位用于指定响应优先级 NVIC_PriorityGroup_1 ：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级 NVIC_PriorityGroup_2 ：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级 NVIC_PriorityGroup_3 ：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级 NVIC_PriorityGroup_4 ：所有4位用于指定抢占式优先级 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:2","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#nvic-嵌套-中断向量--orga031c10--控制器"},{"categories":null,"content":"NVIC（嵌套中断向量控制器） 负责除了SYSTICK之外的所有中断的控制。大部分系统中断也走NVIC通道，所以系统中断优先级未必高于外部中断。 抢占优先级（Preemption Priority） 高抢占优先级的中断事件会打断当前的主程序/低抢占优先级的中断程序运行，称抢断式优先响应，俗称中断嵌套。 响应优先级（Subpriority） 抢占优先级相同的情况下，比较响应优先级。 优先级分组 Cortex-M3是用8位来配置优先级的，即给每个中断配发8位的身份证，这8位中用几位来表示抢占级，用几位来表示响应级，就由分组来进行规定。 Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下： NVIC_PriorityGroup_0 ：所有4位用于指定响应优先级 NVIC_PriorityGroup_1 ：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级 NVIC_PriorityGroup_2 ：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级 NVIC_PriorityGroup_3 ：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级 NVIC_PriorityGroup_4 ：所有4位用于指定抢占式优先级 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:2","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#抢占优先级-preemption-priority"},{"categories":null,"content":"NVIC（嵌套中断向量控制器） 负责除了SYSTICK之外的所有中断的控制。大部分系统中断也走NVIC通道，所以系统中断优先级未必高于外部中断。 抢占优先级（Preemption Priority） 高抢占优先级的中断事件会打断当前的主程序/低抢占优先级的中断程序运行，称抢断式优先响应，俗称中断嵌套。 响应优先级（Subpriority） 抢占优先级相同的情况下，比较响应优先级。 优先级分组 Cortex-M3是用8位来配置优先级的，即给每个中断配发8位的身份证，这8位中用几位来表示抢占级，用几位来表示响应级，就由分组来进行规定。 Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下： NVIC_PriorityGroup_0 ：所有4位用于指定响应优先级 NVIC_PriorityGroup_1 ：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级 NVIC_PriorityGroup_2 ：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级 NVIC_PriorityGroup_3 ：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级 NVIC_PriorityGroup_4 ：所有4位用于指定抢占式优先级 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:2","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#响应优先级-subpriority"},{"categories":null,"content":"NVIC（嵌套中断向量控制器） 负责除了SYSTICK之外的所有中断的控制。大部分系统中断也走NVIC通道，所以系统中断优先级未必高于外部中断。 抢占优先级（Preemption Priority） 高抢占优先级的中断事件会打断当前的主程序/低抢占优先级的中断程序运行，称抢断式优先响应，俗称中断嵌套。 响应优先级（Subpriority） 抢占优先级相同的情况下，比较响应优先级。 优先级分组 Cortex-M3是用8位来配置优先级的，即给每个中断配发8位的身份证，这8位中用几位来表示抢占级，用几位来表示响应级，就由分组来进行规定。 Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下： NVIC_PriorityGroup_0 ：所有4位用于指定响应优先级 NVIC_PriorityGroup_1 ：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级 NVIC_PriorityGroup_2 ：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级 NVIC_PriorityGroup_3 ：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级 NVIC_PriorityGroup_4 ：所有4位用于指定抢占式优先级 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:2","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#优先级分组"},{"categories":null,"content":"中断服务函数 一般是作为多个中断的一个公共入口，在处理中断时，应该在中断服务函数里判断是哪一种中断，先清除中断标志，再处理中断。该函数不会被任何一个函数调用，中断条件满足时，NVIC（嵌套中断向量控制器）会将CPU拉入中断函数中。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:3","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#中断服务函数"},{"categories":null,"content":"系统中断 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:4","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#系统中断"},{"categories":null,"content":"外部中断（EXTI） STM32的所有GPIO都引入到了EXTI外部中断线上，也就是说，所有的IO口经过配置后都能够触发中断。 ","date":"2022-03-02","objectID":"/posts/notes/stm32/:6:5","series":null,"tags":["嵌入式","单片机"],"title":"STM32","uri":"/posts/notes/stm32/#外部中断-exti"},{"categories":null,"content":"程序结构 它们是 VHDL 程序的设计单元由5个部分组成： 实体（Entity） 结构（Architecture） 配置（Configuration） 程序包和程序包体（Package） 库（Library）无论是复杂的还是简单的数字模块，用 VHDL 来描述都至少需要包括两个部分，即实体申明（Entity Declaration）和结构体（Architecture）。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:0","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#程序结构"},{"categories":null,"content":"entity ENTITY 实体名 IS [GENERIC(参数表);] [PORT(端口表);] [BEGIN 实体语句部分;] END [ENTITY] [实体名]; 可以将实体理解为电路图设计中的芯片符号（Symbol），符号规定了电路的符号名、接口和数据类型。 例： entity entity_name is generic (PARAMETER1 : in integer := 3; PARAMETER2 : in integer); port ( IN1, IN2 : in bit; OUT1, OUT2 : out bit); end entity_name; generic GENERIC ([CONSTANT]属性名称 : [IN]子类型标识 [:=静态表达式], ...); generic 里只能定义常量并且只能为整型，因此 constant 关键字是可选的。提高实体的复用能力，可以用于规定端口的大小、实体中子元件的数目、实体的延时特性等。 port PORT([SIGNAL] 端口名称 : [方向] 类型标识[BUS] [:=静态表达式], ...); port 中只能是信号，因此 signal 关键字是可选的。 类型 总线类型 std_logic_vector 方向 关键字 含义 in 信号输入 out 信号输出 inout 信号输入/输出 buffer ？？？ linkage ？？？ ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#entity"},{"categories":null,"content":"entity ENTITY 实体名 IS [GENERIC(参数表);] [PORT(端口表);] [BEGIN 实体语句部分;] END [ENTITY] [实体名]; 可以将实体理解为电路图设计中的芯片符号（Symbol），符号规定了电路的符号名、接口和数据类型。 例： entity entity_name is generic (PARAMETER1 : in integer := 3; PARAMETER2 : in integer); port ( IN1, IN2 : in bit; OUT1, OUT2 : out bit); end entity_name; generic GENERIC ([CONSTANT]属性名称 : [IN]子类型标识 [:=静态表达式], ...); generic 里只能定义常量并且只能为整型，因此 constant 关键字是可选的。提高实体的复用能力，可以用于规定端口的大小、实体中子元件的数目、实体的延时特性等。 port PORT([SIGNAL] 端口名称 : [方向] 类型标识[BUS] [:=静态表达式], ...); port 中只能是信号，因此 signal 关键字是可选的。 类型 总线类型 std_logic_vector 方向 关键字 含义 in 信号输入 out 信号输出 inout 信号输入/输出 buffer ？？？ linkage ？？？ ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#generic"},{"categories":null,"content":"entity ENTITY 实体名 IS [GENERIC(参数表);] [PORT(端口表);] [BEGIN 实体语句部分;] END [ENTITY] [实体名]; 可以将实体理解为电路图设计中的芯片符号（Symbol），符号规定了电路的符号名、接口和数据类型。 例： entity entity_name is generic (PARAMETER1 : in integer := 3; PARAMETER2 : in integer); port ( IN1, IN2 : in bit; OUT1, OUT2 : out bit); end entity_name; generic GENERIC ([CONSTANT]属性名称 : [IN]子类型标识 [:=静态表达式], ...); generic 里只能定义常量并且只能为整型，因此 constant 关键字是可选的。提高实体的复用能力，可以用于规定端口的大小、实体中子元件的数目、实体的延时特性等。 port PORT([SIGNAL] 端口名称 : [方向] 类型标识[BUS] [:=静态表达式], ...); port 中只能是信号，因此 signal 关键字是可选的。 类型 总线类型 std_logic_vector 方向 关键字 含义 in 信号输入 out 信号输出 inout 信号输入/输出 buffer ？？？ linkage ？？？ ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#port"},{"categories":null,"content":"architecture ARCHITECTURE 结构体名 OF 实体名 IS [定义语句] BEGIN [并行处理语句] END 结构体名; 例： architecture architecture_name of entity_name is signal TEMP1 : std_logic_vector(5 downto 0); component another_entity_name port(IN1, IN2 : in std_logic; OUT1 : in std_logic); end component; begin TEMP1 \u003c= IN1 \u0026 IN2; process(IN1) variable TEMP2 : std_logic_vector(5 downto 0); begin -- ... end process; block_name : block(IN1 = '1') begin TEMP2 \u003c= IN1 \u0026 IN2; end block block_name; end architecture_name; 用于描述实体的功能，并且一个实体可以有多个结构体，每个结构体可以有多个进程同时运行。结构体对实体有3种描述方式： 行为描述（基本设计单元的数学模型描述） 寄存器传输描述（数据流描述） 结构描述（逻辑元件连接描述） component 语法与实体一致。用于定义已经写好实体和结构的接口，以便在结构体中使用。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#architecture"},{"categories":null,"content":"architecture ARCHITECTURE 结构体名 OF 实体名 IS [定义语句] BEGIN [并行处理语句] END 结构体名; 例： architecture architecture_name of entity_name is signal TEMP1 : std_logic_vector(5 downto 0); component another_entity_name port(IN1, IN2 : in std_logic; OUT1 : in std_logic); end component; begin TEMP1 \u003c= IN1 \u0026 IN2; process(IN1) variable TEMP2 : std_logic_vector(5 downto 0); begin -- ... end process; block_name : block(IN1 = '1') begin TEMP2 \u003c= IN1 \u0026 IN2; end block block_name; end architecture_name; 用于描述实体的功能，并且一个实体可以有多个结构体，每个结构体可以有多个进程同时运行。结构体对实体有3种描述方式： 行为描述（基本设计单元的数学模型描述） 寄存器传输描述（数据流描述） 结构描述（逻辑元件连接描述） component 语法与实体一致。用于定义已经写好实体和结构的接口，以便在结构体中使用。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#component"},{"categories":null,"content":"procedure PROCEDURE 过程名(参数名 : 方向 类型; ...) IS 定义语句; BEGIN 顺序语句组; END 过程名; 方向 IN OUT INOUT ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:3","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#procedure"},{"categories":null,"content":"function FUNCTION 函数名(参数名 : 类型; ...) RETURN 数据类型 IS 定义语句; BEGIN 顺序语句组; RETURN [返回变量名]; END 函数名; 与过程不同，具有返回值，并且参数均为输入，因此不用写方向，但要标明返回值。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:4","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#function"},{"categories":null,"content":"package 定义 library IEEE; use IEEE.STD_LOGIC_1164.all; -- 程序包申明 package package_name is -- 函数申明 function function_name(a, b : in bit) return bit; end package_name; -- 程序包体 package body package_name is -- 函数实现 function function_name(a, b : in bit) return bit is variable ret : bit; begin ret = not(a and b); return ret; end function_name; end body; 使用 use WORK.自定义程序包名称.all; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:5","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#package"},{"categories":null,"content":"configuration 一个实体可以包含多个结构体，而配置可用于描述层与层之间的连接关系以及实体与结构之间的连接关系。可以用这种配置来选择不同的结构体，使其与要设计的实体相对应，或者在仿真中选择性能最好的结构体。 CONFIGURATION 配置名 OF 实体名 IS [语句说明] END 配置名; 如果一个实体仅仅具有一个结构体，也需要定义其配置，但是可以写成一种最为简洁的格式： CONFIGURATION 配置名 OF 实体名 IS FOR 结构体名 END FOR; END 配置名; 如果一个模块比较复杂，含有多个子模块，可以为每个子模块选择其结构体。 CONFIGURATION 配置名 OF 实体名 IS FOR 结构体名 FOR 标号 : 元件名 USE CONFIGURATION WORK.配置体名; END FOR; ... END FOR; END 配置名; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:6","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#configuration"},{"categories":null,"content":"library 经编译后的数据的集合，它存放包集合申明、实体申明、构造体申明和配置定义，使设计者可以共享已经编译过的设计结果。可以存在多个不同的库，但库和库之间不能互相嵌套。 LIBRARY 库名; 种类 IEEE 库 IEEE 正式认可的标准包集合。现在有些公司提供的包集合没有得到认证，但也包含在其中。 STD 库 STD 库是 VHDL 的标准库。 ASIC 矢量库 ASIC 的逻辑门库，存放着与逻辑门对应的实体。 用户自定义库 WORK 库 现行作业库，设计者所描述的语句都将存放在该库中，并且在使用该库时无需进行任何说明。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:1:7","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#library"},{"categories":null,"content":"数据 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:0","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#数据"},{"categories":null,"content":"数据对象 signal SIGNAL 信号名 : 信号类型 [:= 初始值]; 实体间动态数据交换的手段，相当于连接元件的导线，在实体说明部分、结构体说明和程序包说明中都能声明。 variable VARIABLE 变量名1, 变量名2, ... : 变量类型[:= 初始值]; 用于存储进程和子程序中的局部数据，与信号相比具有以下优点： 赋值是立即执行的，容易实现同步 用更少的存储器 constant CONSTANT 常量名1, 常量名2 ... : 常量类型 [:= 值]; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#数据对象"},{"categories":null,"content":"数据对象 signal SIGNAL 信号名 : 信号类型 [:= 初始值]; 实体间动态数据交换的手段，相当于连接元件的导线，在实体说明部分、结构体说明和程序包说明中都能声明。 variable VARIABLE 变量名1, 变量名2, ... : 变量类型[:= 初始值]; 用于存储进程和子程序中的局部数据，与信号相比具有以下优点： 赋值是立即执行的，容易实现同步 用更少的存储器 constant CONSTANT 常量名1, 常量名2 ... : 常量类型 [:= 值]; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#signal"},{"categories":null,"content":"数据对象 signal SIGNAL 信号名 : 信号类型 [:= 初始值]; 实体间动态数据交换的手段，相当于连接元件的导线，在实体说明部分、结构体说明和程序包说明中都能声明。 variable VARIABLE 变量名1, 变量名2, ... : 变量类型[:= 初始值]; 用于存储进程和子程序中的局部数据，与信号相比具有以下优点： 赋值是立即执行的，容易实现同步 用更少的存储器 constant CONSTANT 常量名1, 常量名2 ... : 常量类型 [:= 值]; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#variable"},{"categories":null,"content":"数据对象 signal SIGNAL 信号名 : 信号类型 [:= 初始值]; 实体间动态数据交换的手段，相当于连接元件的导线，在实体说明部分、结构体说明和程序包说明中都能声明。 variable VARIABLE 变量名1, 变量名2, ... : 变量类型[:= 初始值]; 用于存储进程和子程序中的局部数据，与信号相比具有以下优点： 赋值是立即执行的，容易实现同步 用更少的存储器 constant CONSTANT 常量名1, 常量名2 ... : 常量类型 [:= 值]; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#constant"},{"categories":null,"content":"数据类型 很多类型后面可以加上约束区间： integer range 100 downto 1; bit_vector(3 downto 1) real range 2.0 to 30.0; 标准数据类型 类型变换函数表： 包 函数 功能 STD_LOGIC_1164 to_stdlogicvector 将 bit_vector 转换为 std_logic_vector to_bitvector 将 std_logic_vector 转换为 bit_vector to_stdlogic 将 bit 转换为 std_logic to_bit 将 std_logic 转换为 bit STD_LOGIC_ARITH conv_std_logic_vector 将 integer 、unsigned 或 signed 转换为 std_logic_vector conv_integer 将 unsigned 或 signed 转换为 integer STD_LOGIC_UNSIGNED conv_integer 将 std_logic_vector 转换为 integer 逻辑类型 std_logic 标准逻辑。 '0' '1' 'Z' std_logic_vector 标准逻辑向量。 \"0011ZZ\" X\"00BB\" bit 位。 '0' '1' bit_vector 位矢量。 \"0011\" X\"00BB\" boolean 布尔值。 数值类型 整数类型 integer 范围为\\([-2^{32}-1,2^{31}-1]\\)整数。 natural 自然数。 positive 正整数。 signed unsigned time 时间。 单位 fs ps ns ns us ms sec min hr 实数类型 real 浮点数。 字符类型 character 字符。 'A' 'a' string 字符串。 \"Hello World!\" 用户定义数据类型 TYPE 数据类型名 {,数据类型名} 数据类型定义; 要放在语句的定义部分中，定义范围直到语句块的最后。 枚举类型 TYPE 数据类型名 IS (元素, ...) 元素是有序列性的，元素的值就是其下标的二进制数。 类型别名 TYPE 数据类型名 IS 数据类型定义 约束范围 数组 TYPE 数据类型名 IS ARRAY 范围 OF 原数据类型名; 当范围用到除整数类型以外的类型，应在数据范围前加数据类型名： type week is (sun, mon, tue, wed, thu, fri, sat); type workdate is array (week mon to fri) of std_logic; 要获取数组里的一个元素时，可以： 数组名(下标) 单位 TYPE 数据类型名 IS 范围 UNITS 基本单位; 单位描述; END UNITS 例： type time is range -1E18 to 1E18 units fs; ps = 1000fs; ns = 1000ps; us = 1000ns; ms = 1000us; sec = 1000ms; min = 60sec; hr = 60min; end units; 结构体 TYPE 数据类型名 IS RECORD 元素名 : 数据类型名; ... END RECORD; 例： type window is record length : integer; width : integer; end record; signal win : window; win.length \u003c= 10; 子类型 SUBTYPE 子类型名 IS 数据类型名[范围]; 例： subtype digit is integer range 0 to 9; subtype abus is std_logic_vector(7 downto 0); ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#数据类型"},{"categories":null,"content":"数据类型 很多类型后面可以加上约束区间： integer range 100 downto 1; bit_vector(3 downto 1) real range 2.0 to 30.0; 标准数据类型 类型变换函数表： 包 函数 功能 STD_LOGIC_1164 to_stdlogicvector 将 bit_vector 转换为 std_logic_vector to_bitvector 将 std_logic_vector 转换为 bit_vector to_stdlogic 将 bit 转换为 std_logic to_bit 将 std_logic 转换为 bit STD_LOGIC_ARITH conv_std_logic_vector 将 integer 、unsigned 或 signed 转换为 std_logic_vector conv_integer 将 unsigned 或 signed 转换为 integer STD_LOGIC_UNSIGNED conv_integer 将 std_logic_vector 转换为 integer 逻辑类型 std_logic 标准逻辑。 '0' '1' 'Z' std_logic_vector 标准逻辑向量。 \"0011ZZ\" X\"00BB\" bit 位。 '0' '1' bit_vector 位矢量。 \"0011\" X\"00BB\" boolean 布尔值。 数值类型 整数类型 integer 范围为\\([-2^{32}-1,2^{31}-1]\\)整数。 natural 自然数。 positive 正整数。 signed unsigned time 时间。 单位 fs ps ns ns us ms sec min hr 实数类型 real 浮点数。 字符类型 character 字符。 'A' 'a' string 字符串。 \"Hello World!\" 用户定义数据类型 TYPE 数据类型名 {,数据类型名} 数据类型定义; 要放在语句的定义部分中，定义范围直到语句块的最后。 枚举类型 TYPE 数据类型名 IS (元素, ...) 元素是有序列性的，元素的值就是其下标的二进制数。 类型别名 TYPE 数据类型名 IS 数据类型定义 约束范围 数组 TYPE 数据类型名 IS ARRAY 范围 OF 原数据类型名; 当范围用到除整数类型以外的类型，应在数据范围前加数据类型名： type week is (sun, mon, tue, wed, thu, fri, sat); type workdate is array (week mon to fri) of std_logic; 要获取数组里的一个元素时，可以： 数组名(下标) 单位 TYPE 数据类型名 IS 范围 UNITS 基本单位; 单位描述; END UNITS 例： type time is range -1E18 to 1E18 units fs; ps = 1000fs; ns = 1000ps; us = 1000ns; ms = 1000us; sec = 1000ms; min = 60sec; hr = 60min; end units; 结构体 TYPE 数据类型名 IS RECORD 元素名 : 数据类型名; ... END RECORD; 例： type window is record length : integer; width : integer; end record; signal win : window; win.length \u003c= 10; 子类型 SUBTYPE 子类型名 IS 数据类型名[范围]; 例： subtype digit is integer range 0 to 9; subtype abus is std_logic_vector(7 downto 0); ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#标准数据类型"},{"categories":null,"content":"数据类型 很多类型后面可以加上约束区间： integer range 100 downto 1; bit_vector(3 downto 1) real range 2.0 to 30.0; 标准数据类型 类型变换函数表： 包 函数 功能 STD_LOGIC_1164 to_stdlogicvector 将 bit_vector 转换为 std_logic_vector to_bitvector 将 std_logic_vector 转换为 bit_vector to_stdlogic 将 bit 转换为 std_logic to_bit 将 std_logic 转换为 bit STD_LOGIC_ARITH conv_std_logic_vector 将 integer 、unsigned 或 signed 转换为 std_logic_vector conv_integer 将 unsigned 或 signed 转换为 integer STD_LOGIC_UNSIGNED conv_integer 将 std_logic_vector 转换为 integer 逻辑类型 std_logic 标准逻辑。 '0' '1' 'Z' std_logic_vector 标准逻辑向量。 \"0011ZZ\" X\"00BB\" bit 位。 '0' '1' bit_vector 位矢量。 \"0011\" X\"00BB\" boolean 布尔值。 数值类型 整数类型 integer 范围为\\([-2^{32}-1,2^{31}-1]\\)整数。 natural 自然数。 positive 正整数。 signed unsigned time 时间。 单位 fs ps ns ns us ms sec min hr 实数类型 real 浮点数。 字符类型 character 字符。 'A' 'a' string 字符串。 \"Hello World!\" 用户定义数据类型 TYPE 数据类型名 {,数据类型名} 数据类型定义; 要放在语句的定义部分中，定义范围直到语句块的最后。 枚举类型 TYPE 数据类型名 IS (元素, ...) 元素是有序列性的，元素的值就是其下标的二进制数。 类型别名 TYPE 数据类型名 IS 数据类型定义 约束范围 数组 TYPE 数据类型名 IS ARRAY 范围 OF 原数据类型名; 当范围用到除整数类型以外的类型，应在数据范围前加数据类型名： type week is (sun, mon, tue, wed, thu, fri, sat); type workdate is array (week mon to fri) of std_logic; 要获取数组里的一个元素时，可以： 数组名(下标) 单位 TYPE 数据类型名 IS 范围 UNITS 基本单位; 单位描述; END UNITS 例： type time is range -1E18 to 1E18 units fs; ps = 1000fs; ns = 1000ps; us = 1000ns; ms = 1000us; sec = 1000ms; min = 60sec; hr = 60min; end units; 结构体 TYPE 数据类型名 IS RECORD 元素名 : 数据类型名; ... END RECORD; 例： type window is record length : integer; width : integer; end record; signal win : window; win.length \u003c= 10; 子类型 SUBTYPE 子类型名 IS 数据类型名[范围]; 例： subtype digit is integer range 0 to 9; subtype abus is std_logic_vector(7 downto 0); ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:2:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#用户定义数据类型"},{"categories":null,"content":"运算符 适用于数组类型： 运算符 功能 \u0026 拼接 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:3:0","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#运算符"},{"categories":null,"content":"逻辑运算符 适用于逻辑类型： 运算符 功能 and 与 or 或 not 非 nand 与非 nor 或非 xor 异或 xnor 同或 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:3:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#逻辑运算符"},{"categories":null,"content":"关系运算符 适用于任意数据类型： 运算符 功能 = 相等 /= 不相等 适用于枚举类型、数值类型及其对应的一维数组： 运算符 功能 \u003c 小于 \u003e 大于 \u003c= 小于或等于 \u003e= 大于或等于 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:3:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#关系运算符"},{"categories":null,"content":"算术运算符 适用整数类型或实数类型： 运算符 功能 * 乘 / 除 适用整数类型： 运算符 功能 + 加 - 减 ** 乘方 abs 绝对值 mod 取模 rem 取余 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:3:3","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#算术运算符"},{"categories":null,"content":"移位运算符 适用于 bit 或 boolean 的一维数组： 运算符 功能 sll 逻辑左移 srl 逻辑右移 sla 算术左移 sra 算术右移 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:3:4","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#移位运算符"},{"categories":null,"content":"语句 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:0","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#语句"},{"categories":null,"content":"顺序语句 wait wait on ：等待信号变化 waif until ：等待表达式为真 wait for ：等待固定的时间例： wait until (sendB = '1') for 1 ns; assert (sendB = '1') report \"sendB timed out at '1'\" severity error; assert assert 断言表达式 [报告表达式] -- 默认为 ASSERTION VIOLATION [严重性表达式] -- 默认为 ERROR 报告一个文本字符串，包含布尔表达式。为假时将输出规定的字符串到标准输出终端。例： process (clk, din) variable last_d_change : time := 0 ns; variable last_d_value : std_logic := 'X'; variable last_clk_value : std_logic := 'X'; begin if (last_d_value /= din) then last_d_change := NOW; last_d_value := din; end if; if (last_clk_value /= clk) then last_clk_value := clk; if (clk = '1') then -- 断言语句 assert (NOW - last_d_change \u003e= 20 ns) report \"setup violation\" severity warning; end if; end if; end process; 条件语句 if IF 表达式 THEN [顺序处理语句] [ELSIF 表达式 THEN [顺序处理语句] ELSE [顺序处理语句]] END IF; case CASE 表达式 IS WHEN 值|值|... =\u003e [顺序处理语句] ... WHEN OTHERS =\u003e [顺序处理语句] END CASE; 循环语句 [循环标示 :] [循环条件] LOOP 顺序处理语句 END LOOP[循环标示]; while 例： while (day = weekday) loop day := get_next_day(day); end loop for 遍历的范围可以是范围语句，也可以是子类型。循环过程中，循环变量的值不允许被修改。例： process (clk) type day_of_week is (sun, mon, tue, wed, thur, fri, sat); begin for i in day_of_week loop if i = sat then son \u003c= mow_lawn; elsif i = sun then church \u003c= family; else dad \u003c= go_to_work; end if; end loop; end process; next 直接跳转到下一次循环。例： process(A, B) constant max_limit : integer := 255; type d_type is array (0 to max_limit) of boolean; variable done : d_type; begin for i in 0 to max_limit loop if (done(i) = true) then next; else done (i) := true; end if; q(i) \u003c= a(i) and b(i); end loop; end process; exit 直接跳出循环，可以指定循环标示。例： process (a) begin first_loop : for i in 0 to 100 loop second_loop : for j in 1 to 10 loop ...... exit second_loop; ...... exit first_loop; end loop; end loop; end process; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#顺序语句"},{"categories":null,"content":"顺序语句 wait wait on ：等待信号变化 waif until ：等待表达式为真 wait for ：等待固定的时间例： wait until (sendB = '1') for 1 ns; assert (sendB = '1') report \"sendB timed out at '1'\" severity error; assert assert 断言表达式 [报告表达式] -- 默认为 ASSERTION VIOLATION [严重性表达式] -- 默认为 ERROR 报告一个文本字符串，包含布尔表达式。为假时将输出规定的字符串到标准输出终端。例： process (clk, din) variable last_d_change : time := 0 ns; variable last_d_value : std_logic := 'X'; variable last_clk_value : std_logic := 'X'; begin if (last_d_value /= din) then last_d_change := NOW; last_d_value := din; end if; if (last_clk_value /= clk) then last_clk_value := clk; if (clk = '1') then -- 断言语句 assert (NOW - last_d_change \u003e= 20 ns) report \"setup violation\" severity warning; end if; end if; end process; 条件语句 if IF 表达式 THEN [顺序处理语句] [ELSIF 表达式 THEN [顺序处理语句] ELSE [顺序处理语句]] END IF; case CASE 表达式 IS WHEN 值|值|... =\u003e [顺序处理语句] ... WHEN OTHERS =\u003e [顺序处理语句] END CASE; 循环语句 [循环标示 :] [循环条件] LOOP 顺序处理语句 END LOOP[循环标示]; while 例： while (day = weekday) loop day := get_next_day(day); end loop for 遍历的范围可以是范围语句，也可以是子类型。循环过程中，循环变量的值不允许被修改。例： process (clk) type day_of_week is (sun, mon, tue, wed, thur, fri, sat); begin for i in day_of_week loop if i = sat then son \u003c= mow_lawn; elsif i = sun then church \u003c= family; else dad \u003c= go_to_work; end if; end loop; end process; next 直接跳转到下一次循环。例： process(A, B) constant max_limit : integer := 255; type d_type is array (0 to max_limit) of boolean; variable done : d_type; begin for i in 0 to max_limit loop if (done(i) = true) then next; else done (i) := true; end if; q(i) \u003c= a(i) and b(i); end loop; end process; exit 直接跳出循环，可以指定循环标示。例： process (a) begin first_loop : for i in 0 to 100 loop second_loop : for j in 1 to 10 loop ...... exit second_loop; ...... exit first_loop; end loop; end loop; end process; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#wait"},{"categories":null,"content":"顺序语句 wait wait on ：等待信号变化 waif until ：等待表达式为真 wait for ：等待固定的时间例： wait until (sendB = '1') for 1 ns; assert (sendB = '1') report \"sendB timed out at '1'\" severity error; assert assert 断言表达式 [报告表达式] -- 默认为 ASSERTION VIOLATION [严重性表达式] -- 默认为 ERROR 报告一个文本字符串，包含布尔表达式。为假时将输出规定的字符串到标准输出终端。例： process (clk, din) variable last_d_change : time := 0 ns; variable last_d_value : std_logic := 'X'; variable last_clk_value : std_logic := 'X'; begin if (last_d_value /= din) then last_d_change := NOW; last_d_value := din; end if; if (last_clk_value /= clk) then last_clk_value := clk; if (clk = '1') then -- 断言语句 assert (NOW - last_d_change \u003e= 20 ns) report \"setup violation\" severity warning; end if; end if; end process; 条件语句 if IF 表达式 THEN [顺序处理语句] [ELSIF 表达式 THEN [顺序处理语句] ELSE [顺序处理语句]] END IF; case CASE 表达式 IS WHEN 值|值|... =\u003e [顺序处理语句] ... WHEN OTHERS =\u003e [顺序处理语句] END CASE; 循环语句 [循环标示 :] [循环条件] LOOP 顺序处理语句 END LOOP[循环标示]; while 例： while (day = weekday) loop day := get_next_day(day); end loop for 遍历的范围可以是范围语句，也可以是子类型。循环过程中，循环变量的值不允许被修改。例： process (clk) type day_of_week is (sun, mon, tue, wed, thur, fri, sat); begin for i in day_of_week loop if i = sat then son \u003c= mow_lawn; elsif i = sun then church \u003c= family; else dad \u003c= go_to_work; end if; end loop; end process; next 直接跳转到下一次循环。例： process(A, B) constant max_limit : integer := 255; type d_type is array (0 to max_limit) of boolean; variable done : d_type; begin for i in 0 to max_limit loop if (done(i) = true) then next; else done (i) := true; end if; q(i) \u003c= a(i) and b(i); end loop; end process; exit 直接跳出循环，可以指定循环标示。例： process (a) begin first_loop : for i in 0 to 100 loop second_loop : for j in 1 to 10 loop ...... exit second_loop; ...... exit first_loop; end loop; end loop; end process; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#assert"},{"categories":null,"content":"顺序语句 wait wait on ：等待信号变化 waif until ：等待表达式为真 wait for ：等待固定的时间例： wait until (sendB = '1') for 1 ns; assert (sendB = '1') report \"sendB timed out at '1'\" severity error; assert assert 断言表达式 [报告表达式] -- 默认为 ASSERTION VIOLATION [严重性表达式] -- 默认为 ERROR 报告一个文本字符串，包含布尔表达式。为假时将输出规定的字符串到标准输出终端。例： process (clk, din) variable last_d_change : time := 0 ns; variable last_d_value : std_logic := 'X'; variable last_clk_value : std_logic := 'X'; begin if (last_d_value /= din) then last_d_change := NOW; last_d_value := din; end if; if (last_clk_value /= clk) then last_clk_value := clk; if (clk = '1') then -- 断言语句 assert (NOW - last_d_change \u003e= 20 ns) report \"setup violation\" severity warning; end if; end if; end process; 条件语句 if IF 表达式 THEN [顺序处理语句] [ELSIF 表达式 THEN [顺序处理语句] ELSE [顺序处理语句]] END IF; case CASE 表达式 IS WHEN 值|值|... =\u003e [顺序处理语句] ... WHEN OTHERS =\u003e [顺序处理语句] END CASE; 循环语句 [循环标示 :] [循环条件] LOOP 顺序处理语句 END LOOP[循环标示]; while 例： while (day = weekday) loop day := get_next_day(day); end loop for 遍历的范围可以是范围语句，也可以是子类型。循环过程中，循环变量的值不允许被修改。例： process (clk) type day_of_week is (sun, mon, tue, wed, thur, fri, sat); begin for i in day_of_week loop if i = sat then son \u003c= mow_lawn; elsif i = sun then church \u003c= family; else dad \u003c= go_to_work; end if; end loop; end process; next 直接跳转到下一次循环。例： process(A, B) constant max_limit : integer := 255; type d_type is array (0 to max_limit) of boolean; variable done : d_type; begin for i in 0 to max_limit loop if (done(i) = true) then next; else done (i) := true; end if; q(i) \u003c= a(i) and b(i); end loop; end process; exit 直接跳出循环，可以指定循环标示。例： process (a) begin first_loop : for i in 0 to 100 loop second_loop : for j in 1 to 10 loop ...... exit second_loop; ...... exit first_loop; end loop; end loop; end process; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#条件语句"},{"categories":null,"content":"顺序语句 wait wait on ：等待信号变化 waif until ：等待表达式为真 wait for ：等待固定的时间例： wait until (sendB = '1') for 1 ns; assert (sendB = '1') report \"sendB timed out at '1'\" severity error; assert assert 断言表达式 [报告表达式] -- 默认为 ASSERTION VIOLATION [严重性表达式] -- 默认为 ERROR 报告一个文本字符串，包含布尔表达式。为假时将输出规定的字符串到标准输出终端。例： process (clk, din) variable last_d_change : time := 0 ns; variable last_d_value : std_logic := 'X'; variable last_clk_value : std_logic := 'X'; begin if (last_d_value /= din) then last_d_change := NOW; last_d_value := din; end if; if (last_clk_value /= clk) then last_clk_value := clk; if (clk = '1') then -- 断言语句 assert (NOW - last_d_change \u003e= 20 ns) report \"setup violation\" severity warning; end if; end if; end process; 条件语句 if IF 表达式 THEN [顺序处理语句] [ELSIF 表达式 THEN [顺序处理语句] ELSE [顺序处理语句]] END IF; case CASE 表达式 IS WHEN 值|值|... =\u003e [顺序处理语句] ... WHEN OTHERS =\u003e [顺序处理语句] END CASE; 循环语句 [循环标示 :] [循环条件] LOOP 顺序处理语句 END LOOP[循环标示]; while 例： while (day = weekday) loop day := get_next_day(day); end loop for 遍历的范围可以是范围语句，也可以是子类型。循环过程中，循环变量的值不允许被修改。例： process (clk) type day_of_week is (sun, mon, tue, wed, thur, fri, sat); begin for i in day_of_week loop if i = sat then son \u003c= mow_lawn; elsif i = sun then church \u003c= family; else dad \u003c= go_to_work; end if; end loop; end process; next 直接跳转到下一次循环。例： process(A, B) constant max_limit : integer := 255; type d_type is array (0 to max_limit) of boolean; variable done : d_type; begin for i in 0 to max_limit loop if (done(i) = true) then next; else done (i) := true; end if; q(i) \u003c= a(i) and b(i); end loop; end process; exit 直接跳出循环，可以指定循环标示。例： process (a) begin first_loop : for i in 0 to 100 loop second_loop : for j in 1 to 10 loop ...... exit second_loop; ...... exit first_loop; end loop; end loop; end process; ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#循环语句"},{"categories":null,"content":"并行语句 信号的赋值 直接赋值 例： architecture arch of demo is begin -- 并行赋值 d1 \u003c= din; d2 \u003c= din; -- 进程 process(din) begin -- 顺序赋值 c1 \u003c= din; c2 \u003c= din; end process; end arch; 条件赋值 目的信号 \u003c= 表达式 WHEN 条件 ELSE ... 表达式; 例： entity mux4 is port ( din0, din1, din2, din3, sel0, sel1 : in bit; dout : out bit); end mux4; architecture arch of mux4 is signal sel : bit_vector(1 downto 0); begin sel \u003c= sel1 \u0026 sel0; dout \u003c= din0 when sel = “00” else din1 when sel = “01” else din2 when sel = “10” else din3 when sel = “11” else ‘X’; end mux4; 选择赋值 WITH 表达式 SELECT 目的信号量 \u003c= 表达式 WHEN 条件; ... 例： entity mux4 is port ( din0, din1, din2, din3, sel0, sel1 : in bit; dout : out bit); end mux4; architecture arch of mux4 is signal sel : bit_vector(1 downto 0); begin sel \u003c= sel1 \u0026 sel0; with sel select dout \u003c= din1 when “00”, dout \u003c= din1 when “01”, dout \u003c= din2 when “10”, dout \u003c= din3 when “1”, ‘X” when others; end mux4; block 块名:BLOCK(条件) [参数 GENERIC 说明; [参数映射;] ] [端口说明; 端口映射;]] [块说明语句] BEGIN 并发语句组; END BLOCK 块名; 放在结构体的并行语句中，相当于一个子电路原理图，里面内的语句是并发执行的。只要右边的条件满足就被执行，如果省略条件则表示无条件执行。 process [进程名] : process (信号1, 信号2, ...) BEGIN ... END PROCESS; 进程语句是一种并发处理语句，在一个结构体中多个进行可以同时并行运行，是VHDL语言中描述硬件系统并发行为的最基本语句。括号内的信号是此进程的敏感信号，这些信号的变化会激活过程的执行。 特点 访问结构体或实体中定义的信号。 与其他进程并发运行，进程内语句都是按顺序执行的。 启动进程在进行结构中必须包含一个显式的敏感信号量表或包含一个 WAIT 语句。 进程之间的通信是通过信号量传递来实现。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#并行语句"},{"categories":null,"content":"并行语句 信号的赋值 直接赋值 例： architecture arch of demo is begin -- 并行赋值 d1 \u003c= din; d2 \u003c= din; -- 进程 process(din) begin -- 顺序赋值 c1 \u003c= din; c2 \u003c= din; end process; end arch; 条件赋值 目的信号 \u003c= 表达式 WHEN 条件 ELSE ... 表达式; 例： entity mux4 is port ( din0, din1, din2, din3, sel0, sel1 : in bit; dout : out bit); end mux4; architecture arch of mux4 is signal sel : bit_vector(1 downto 0); begin sel \u003c= sel1 \u0026 sel0; dout \u003c= din0 when sel = “00” else din1 when sel = “01” else din2 when sel = “10” else din3 when sel = “11” else ‘X’; end mux4; 选择赋值 WITH 表达式 SELECT 目的信号量 \u003c= 表达式 WHEN 条件; ... 例： entity mux4 is port ( din0, din1, din2, din3, sel0, sel1 : in bit; dout : out bit); end mux4; architecture arch of mux4 is signal sel : bit_vector(1 downto 0); begin sel \u003c= sel1 \u0026 sel0; with sel select dout \u003c= din1 when “00”, dout \u003c= din1 when “01”, dout \u003c= din2 when “10”, dout \u003c= din3 when “1”, ‘X” when others; end mux4; block 块名:BLOCK(条件) [参数 GENERIC 说明; [参数映射;] ] [端口说明; 端口映射;]] [块说明语句] BEGIN 并发语句组; END BLOCK 块名; 放在结构体的并行语句中，相当于一个子电路原理图，里面内的语句是并发执行的。只要右边的条件满足就被执行，如果省略条件则表示无条件执行。 process [进程名] : process (信号1, 信号2, ...) BEGIN ... END PROCESS; 进程语句是一种并发处理语句，在一个结构体中多个进行可以同时并行运行，是VHDL语言中描述硬件系统并发行为的最基本语句。括号内的信号是此进程的敏感信号，这些信号的变化会激活过程的执行。 特点 访问结构体或实体中定义的信号。 与其他进程并发运行，进程内语句都是按顺序执行的。 启动进程在进行结构中必须包含一个显式的敏感信号量表或包含一个 WAIT 语句。 进程之间的通信是通过信号量传递来实现。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#block"},{"categories":null,"content":"并行语句 信号的赋值 直接赋值 例： architecture arch of demo is begin -- 并行赋值 d1 \u003c= din; d2 \u003c= din; -- 进程 process(din) begin -- 顺序赋值 c1 \u003c= din; c2 \u003c= din; end process; end arch; 条件赋值 目的信号 \u003c= 表达式 WHEN 条件 ELSE ... 表达式; 例： entity mux4 is port ( din0, din1, din2, din3, sel0, sel1 : in bit; dout : out bit); end mux4; architecture arch of mux4 is signal sel : bit_vector(1 downto 0); begin sel \u003c= sel1 \u0026 sel0; dout \u003c= din0 when sel = “00” else din1 when sel = “01” else din2 when sel = “10” else din3 when sel = “11” else ‘X’; end mux4; 选择赋值 WITH 表达式 SELECT 目的信号量 \u003c= 表达式 WHEN 条件; ... 例： entity mux4 is port ( din0, din1, din2, din3, sel0, sel1 : in bit; dout : out bit); end mux4; architecture arch of mux4 is signal sel : bit_vector(1 downto 0); begin sel \u003c= sel1 \u0026 sel0; with sel select dout \u003c= din1 when “00”, dout \u003c= din1 when “01”, dout \u003c= din2 when “10”, dout \u003c= din3 when “1”, ‘X” when others; end mux4; block 块名:BLOCK(条件) [参数 GENERIC 说明; [参数映射;] ] [端口说明; 端口映射;]] [块说明语句] BEGIN 并发语句组; END BLOCK 块名; 放在结构体的并行语句中，相当于一个子电路原理图，里面内的语句是并发执行的。只要右边的条件满足就被执行，如果省略条件则表示无条件执行。 process [进程名] : process (信号1, 信号2, ...) BEGIN ... END PROCESS; 进程语句是一种并发处理语句，在一个结构体中多个进行可以同时并行运行，是VHDL语言中描述硬件系统并发行为的最基本语句。括号内的信号是此进程的敏感信号，这些信号的变化会激活过程的执行。 特点 访问结构体或实体中定义的信号。 与其他进程并发运行，进程内语句都是按顺序执行的。 启动进程在进行结构中必须包含一个显式的敏感信号量表或包含一个 WAIT 语句。 进程之间的通信是通过信号量传递来实现。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:4:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#process"},{"categories":null,"content":"预定义属性 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:0","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#预定义属性"},{"categories":null,"content":"值类预定义属性 访问该属性时，不需要传入参数。 值类型属性 返回类型的边界。 类型'left 用于返回类型或子类型的左边界。 类型'right 用于返回类型或子类型的右边界。 类型'high 用于返回类型或子类型的上限值。 类型'low 用于返回类型或子类型的下限值。 值类数组属性 类型'length 返回指定数组的总长度。 值类块属性 块'structure 当块或者结构体中只含元件具体装配语句或被动进程时返回真。 块'behavior 当块和结构体中如不含元件具体装配语句时返回真。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#值类预定义属性"},{"categories":null,"content":"值类预定义属性 访问该属性时，不需要传入参数。 值类型属性 返回类型的边界。 类型'left 用于返回类型或子类型的左边界。 类型'right 用于返回类型或子类型的右边界。 类型'high 用于返回类型或子类型的上限值。 类型'low 用于返回类型或子类型的下限值。 值类数组属性 类型'length 返回指定数组的总长度。 值类块属性 块'structure 当块或者结构体中只含元件具体装配语句或被动进程时返回真。 块'behavior 当块和结构体中如不含元件具体装配语句时返回真。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#值类型属性"},{"categories":null,"content":"值类预定义属性 访问该属性时，不需要传入参数。 值类型属性 返回类型的边界。 类型'left 用于返回类型或子类型的左边界。 类型'right 用于返回类型或子类型的右边界。 类型'high 用于返回类型或子类型的上限值。 类型'low 用于返回类型或子类型的下限值。 值类数组属性 类型'length 返回指定数组的总长度。 值类块属性 块'structure 当块或者结构体中只含元件具体装配语句或被动进程时返回真。 块'behavior 当块和结构体中如不含元件具体装配语句时返回真。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#值类数组属性"},{"categories":null,"content":"值类预定义属性 访问该属性时，不需要传入参数。 值类型属性 返回类型的边界。 类型'left 用于返回类型或子类型的左边界。 类型'right 用于返回类型或子类型的右边界。 类型'high 用于返回类型或子类型的上限值。 类型'low 用于返回类型或子类型的下限值。 值类数组属性 类型'length 返回指定数组的总长度。 值类块属性 块'structure 当块或者结构体中只含元件具体装配语句或被动进程时返回真。 块'behavior 当块和结构体中如不含元件具体装配语句时返回真。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:1","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#值类块属性"},{"categories":null,"content":"函数类预定义属性 访问该属性时，需要传入参数。 函数类型属性 返回类型值。 'POS(value) 返回传入值的位置号码。 'VAL(value) 返回从该位置号码传入的值。 'SUCC(value) 返回输入值后类型中的下一个值。 'PRED(value) 返回输入值前类型中的原先的值。 'LEFTOF(value) 表示立即返回一个值到输入值的左边。 'RIGHTOF(value) 表示立即返回一值到输入值的右边。 函数数组属性 返回数组的边界。 数组'LEFT(n) 返回指数范围 n 的左边界。 数组'RIGHT(n) 返回指数范围 n 的右边界。 数组'HIGH(n) 返回指数范围 n 的上限值。 数组'LOW(n) 返回指数范围 n 的下限值。 函数信号属性 返回信号历史信息。 S'EVENT 如果当前的△时间期间发生了事件返回真，否则返回假（信号是否有值的变化）。 S'ACTIVE 如果在当前的△时间期间做了事项处理返回真，否则返回假。 S'LAST_EVENT 返回从信号原先事件的跳变至今所经历的时间。 S'LAST_VALUE 返回在上一次事件之前 S 的原先值。 S'LAST_ACTIVE 返回自信号原先一次的事项处理至今所经历的时间。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#函数类预定义属性"},{"categories":null,"content":"函数类预定义属性 访问该属性时，需要传入参数。 函数类型属性 返回类型值。 'POS(value) 返回传入值的位置号码。 'VAL(value) 返回从该位置号码传入的值。 'SUCC(value) 返回输入值后类型中的下一个值。 'PRED(value) 返回输入值前类型中的原先的值。 'LEFTOF(value) 表示立即返回一个值到输入值的左边。 'RIGHTOF(value) 表示立即返回一值到输入值的右边。 函数数组属性 返回数组的边界。 数组'LEFT(n) 返回指数范围 n 的左边界。 数组'RIGHT(n) 返回指数范围 n 的右边界。 数组'HIGH(n) 返回指数范围 n 的上限值。 数组'LOW(n) 返回指数范围 n 的下限值。 函数信号属性 返回信号历史信息。 S'EVENT 如果当前的△时间期间发生了事件返回真，否则返回假（信号是否有值的变化）。 S'ACTIVE 如果在当前的△时间期间做了事项处理返回真，否则返回假。 S'LAST_EVENT 返回从信号原先事件的跳变至今所经历的时间。 S'LAST_VALUE 返回在上一次事件之前 S 的原先值。 S'LAST_ACTIVE 返回自信号原先一次的事项处理至今所经历的时间。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#函数类型属性"},{"categories":null,"content":"函数类预定义属性 访问该属性时，需要传入参数。 函数类型属性 返回类型值。 'POS(value) 返回传入值的位置号码。 'VAL(value) 返回从该位置号码传入的值。 'SUCC(value) 返回输入值后类型中的下一个值。 'PRED(value) 返回输入值前类型中的原先的值。 'LEFTOF(value) 表示立即返回一个值到输入值的左边。 'RIGHTOF(value) 表示立即返回一值到输入值的右边。 函数数组属性 返回数组的边界。 数组'LEFT(n) 返回指数范围 n 的左边界。 数组'RIGHT(n) 返回指数范围 n 的右边界。 数组'HIGH(n) 返回指数范围 n 的上限值。 数组'LOW(n) 返回指数范围 n 的下限值。 函数信号属性 返回信号历史信息。 S'EVENT 如果当前的△时间期间发生了事件返回真，否则返回假（信号是否有值的变化）。 S'ACTIVE 如果在当前的△时间期间做了事项处理返回真，否则返回假。 S'LAST_EVENT 返回从信号原先事件的跳变至今所经历的时间。 S'LAST_VALUE 返回在上一次事件之前 S 的原先值。 S'LAST_ACTIVE 返回自信号原先一次的事项处理至今所经历的时间。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#函数数组属性"},{"categories":null,"content":"函数类预定义属性 访问该属性时，需要传入参数。 函数类型属性 返回类型值。 'POS(value) 返回传入值的位置号码。 'VAL(value) 返回从该位置号码传入的值。 'SUCC(value) 返回输入值后类型中的下一个值。 'PRED(value) 返回输入值前类型中的原先的值。 'LEFTOF(value) 表示立即返回一个值到输入值的左边。 'RIGHTOF(value) 表示立即返回一值到输入值的右边。 函数数组属性 返回数组的边界。 数组'LEFT(n) 返回指数范围 n 的左边界。 数组'RIGHT(n) 返回指数范围 n 的右边界。 数组'HIGH(n) 返回指数范围 n 的上限值。 数组'LOW(n) 返回指数范围 n 的下限值。 函数信号属性 返回信号历史信息。 S'EVENT 如果当前的△时间期间发生了事件返回真，否则返回假（信号是否有值的变化）。 S'ACTIVE 如果在当前的△时间期间做了事项处理返回真，否则返回假。 S'LAST_EVENT 返回从信号原先事件的跳变至今所经历的时间。 S'LAST_VALUE 返回在上一次事件之前 S 的原先值。 S'LAST_ACTIVE 返回自信号原先一次的事项处理至今所经历的时间。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:2","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#函数信号属性"},{"categories":null,"content":"信号类预定义属性 S'DELAYED[(time)] 建立和参考信号同类型的信号，该信号后跟参考信号和延时可选时间表示式的时间。 ‘DELAYED 属性为信号建立延迟的版本并附在该信号上，它和传输延时信号赋值的功能相同，但简单。 S'STABLE[(time)] 在选择时间表达式指定的时间内参考信号无事件发生时，属性建立为真值的布尔信号。 S'QUIET[(time)] 参考信号或所选时间表达式指定时间内没事项处理时，属性建立一个为真值的布尔信号。 S'TRANSACTION 信号上有事件发生或为每个事项处理而翻转它的值时，该属性建立一个 BIT 类型的信号。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:3","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#信号类预定义属性"},{"categories":null,"content":"数据类型类预定义属性 t'BASE 返回类型或者子类型的基本类型，这个属性只能作另一属性的前缀。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:4","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#数据类型类预定义属性"},{"categories":null,"content":"数据范围类属性 a'RANGE[(n)] 数据范围类属性返回数组类型的范围值，并由所选的输入参数返回指定的下标范围。 a'REVERSE_RANGE[(n)] 数据范围类属性返回数组类型的范围值，并由所选的输入参数返回指定的下标逆序范围。 ","date":"2022-03-02","objectID":"/posts/notes/vhdl/:5:5","series":null,"tags":["编程语言","数字电路","电子"],"title":"VHDL","uri":"/posts/notes/vhdl/#数据范围类属性"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:0:0","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#"},{"categories":null,"content":"电学 ÷d /--\u003e E ---\\ ×q | | | v U F ^ | | | ÷q \\--- W \u003c--/ ×r ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:0","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电学"},{"categories":null,"content":"电场强度 意义 单位面积的电通量（和磁场强度类似） 电势的梯度 \\[\\vec{E}=-\\left(\\frac{\\partial V}{\\partial x},\\frac{\\partial V}{\\partial y},\\frac{\\partial V}{\\partial z}\\right)\\] 求法 通过已知电荷量的物理求电场 点电荷 库伦定律： \\[F=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{q\\cdot q_0}{r^2}\\] 其中： \\(q_0\\)为试探电荷 \\(\\varepsilon_{0}=8.85 \\times 10^{-12} C^{2} /\\left(N \\cdot m^{2}\\right)\\)：真空介电常量 可以得到电场强度的表达式： \\[E=\\frac{F}{q_0}=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{q}{r^2}\\] 物体（点电荷积分） \\[\\mathrm{d}E=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{\\mathrm{d}q}{r^2}\\Rightarrow E=\\int \\mathrm{d}E=\\int \\frac{1}{4\\pi\\epsilon}\\frac{\\mathrm{d}q}{r^2}\\] 建立坐标系，用\\(x\\)表示位置关系，那么\\(q(x),r(x)\\)均为\\(x\\)的函数，积分变量替换为\\(x\\)。 结论 记住\\(\\frac{\\lambda}{2\\pi\\epsilon_0x}\\sin\\theta_0\\)，平面是量纲的\\(\\frac{1}{2}\\)。 点电荷 \\[E=\\frac{F}{q_0}=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{q}{r^2}\\] 无限大平面 \\[E=\\frac{\\sigma}{2\\varepsilon_0}\\] \\(\\sigma\\)：电荷密度 长度为L的均匀带电棒 \\[E=\\frac{\\lambda}{2\\pi\\varepsilon_0 x}\\sin\\theta_0\\] \\(\\lambda\\)：电荷线密度 无限长直线 令\\(\\theta=\\frac{\\pi}{2}\\)，得到： \\[E=\\frac{\\lambda}{2\\pi\\varepsilon_0 x}\\] 一段圆弧的圆心 \\[E=\\frac{\\lambda}{2\\pi\\varepsilon_0 R}\\sin\\theta_0\\] 圆柱体（高斯定理推导） \\[E=\\begin{cases} \\frac{\\lambda}{2\\pi\\varepsilon_0 r} \u0026, r\u003eR \\\\ \\frac{\\lambda r}{2\\pi\\varepsilon_0 R^2} \u0026, r\u003cR \\end{cases}\\] 球体（高斯定理推导） \\[E=\\begin{cases} \\frac{qr}{4\\pi\\varepsilon_0R^3} \u0026, r\u003cR \\\\ \\frac{q}{4\\pi\\varepsilon_0 r^2} \u0026, r\u003eR \\end{cases}\\] 球面 \\[E=\\begin{cases} 0 \u0026, r\u003cR \\\\ \\frac{q}{4\\pi\\epsilon r^2} \u0026, r\u003eR \\end{cases}\\] 电场线 电场线几点注意事项： 电场线总是起自正电荷，终止于负电荷。 电场线不会自成闭合线，任意两条电场线也不会相交。 电场线密度大的地方，电场强度 E 越大。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电场强度"},{"categories":null,"content":"电场强度 意义 单位面积的电通量（和磁场强度类似） 电势的梯度 \\[\\vec{E}=-\\left(\\frac{\\partial V}{\\partial x},\\frac{\\partial V}{\\partial y},\\frac{\\partial V}{\\partial z}\\right)\\] 求法 通过已知电荷量的物理求电场 点电荷 库伦定律： \\[F=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{q\\cdot q_0}{r^2}\\] 其中： \\(q_0\\)为试探电荷 \\(\\varepsilon_{0}=8.85 \\times 10^{-12} C^{2} /\\left(N \\cdot m^{2}\\right)\\)：真空介电常量 可以得到电场强度的表达式： \\[E=\\frac{F}{q_0}=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{q}{r^2}\\] 物体（点电荷积分） \\[\\mathrm{d}E=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{\\mathrm{d}q}{r^2}\\Rightarrow E=\\int \\mathrm{d}E=\\int \\frac{1}{4\\pi\\epsilon}\\frac{\\mathrm{d}q}{r^2}\\] 建立坐标系，用\\(x\\)表示位置关系，那么\\(q(x),r(x)\\)均为\\(x\\)的函数，积分变量替换为\\(x\\)。 结论 记住\\(\\frac{\\lambda}{2\\pi\\epsilon_0x}\\sin\\theta_0\\)，平面是量纲的\\(\\frac{1}{2}\\)。 点电荷 \\[E=\\frac{F}{q_0}=\\frac{1}{4\\pi\\varepsilon_0}\\cdot \\frac{q}{r^2}\\] 无限大平面 \\[E=\\frac{\\sigma}{2\\varepsilon_0}\\] \\(\\sigma\\)：电荷密度 长度为L的均匀带电棒 \\[E=\\frac{\\lambda}{2\\pi\\varepsilon_0 x}\\sin\\theta_0\\] \\(\\lambda\\)：电荷线密度 无限长直线 令\\(\\theta=\\frac{\\pi}{2}\\)，得到： \\[E=\\frac{\\lambda}{2\\pi\\varepsilon_0 x}\\] 一段圆弧的圆心 \\[E=\\frac{\\lambda}{2\\pi\\varepsilon_0 R}\\sin\\theta_0\\] 圆柱体（高斯定理推导） \\[E=\\begin{cases} \\frac{\\lambda}{2\\pi\\varepsilon_0 r} \u0026, r\u003eR \\\\ \\frac{\\lambda r}{2\\pi\\varepsilon_0 R^2} \u0026, r","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电场线"},{"categories":null,"content":"电通量 求法 对于平面： \\[\\varPhi_e=E\\cdot S\\cos\\theta\\] 对于曲面： \\[\\varPhi_e=\\int \\mathrm{d}\\varPhi_e=\\int \\vec{E}\\cdot \\mathrm{d}\\vec{S}\\] 曲面的电通量可以等效为其投影平面的电通量。 高斯定理 电介质中的高斯定理 \\[\\oint \\vec D \\mathrm{d}\\vec S=\\sum q\\] \\(D=\\varepsilon_0\\varepsilon_rE\\)：电位移 电场（真空）中的高斯定理： \\[\\varPhi_{e}=\\oint \\vec{E} \\cdot d \\vec{S}=\\frac{1}{\\varepsilon_{0}} \\sum q\\] 其中： \\(S\\)：高斯面 \\(\\sum q\\)：高斯面内的电荷量代数和 \\(\\varepsilon_0\\)：真空介电常量 用法： 直接求电通量 求场强分布 磁场中的高斯定理： \\[\\varPhi_m=\\oint\\vec B \\mathrm{d}\\vec S=0\\] 电通量的高斯定理是不为\\(0\\)的，说明电场是个有源场，而磁场是为\\(0\\)的，磁场是个无源场。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:2","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电通量"},{"categories":null,"content":"电通量 求法 对于平面： \\[\\varPhi_e=E\\cdot S\\cos\\theta\\] 对于曲面： \\[\\varPhi_e=\\int \\mathrm{d}\\varPhi_e=\\int \\vec{E}\\cdot \\mathrm{d}\\vec{S}\\] 曲面的电通量可以等效为其投影平面的电通量。 高斯定理 电介质中的高斯定理 \\[\\oint \\vec D \\mathrm{d}\\vec S=\\sum q\\] \\(D=\\varepsilon_0\\varepsilon_rE\\)：电位移 电场（真空）中的高斯定理： \\[\\varPhi_{e}=\\oint \\vec{E} \\cdot d \\vec{S}=\\frac{1}{\\varepsilon_{0}} \\sum q\\] 其中： \\(S\\)：高斯面 \\(\\sum q\\)：高斯面内的电荷量代数和 \\(\\varepsilon_0\\)：真空介电常量 用法： 直接求电通量 求场强分布 磁场中的高斯定理： \\[\\varPhi_m=\\oint\\vec B \\mathrm{d}\\vec S=0\\] 电通量的高斯定理是不为\\(0\\)的，说明电场是个有源场，而磁场是为\\(0\\)的，磁场是个无源场。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:2","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#高斯定理"},{"categories":null,"content":"电位移 可以通过电介质中的高斯定理求得，然后通过\\(D=\\varepsilon_0\\varepsilon_rE\\)转换为电场强度。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:3","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电位移"},{"categories":null,"content":"电场能 \\[W=\\int_{V} w_{e} d V\\] 其中\\(V\\)为含有\\(E\\)的空间。 \\[W=\\frac{Q^{2}}{2 C}=\\frac{1}{2} C\\left(V_{1}-V_{2}\\right)^{2}=\\frac{1}{2} Q\\left(V_{1}-V_{2}\\right)\\] 电场能密度 单位：\\(J/m^3\\) \\[w_{e}=\\frac{1}{2} D E=\\frac{1}{2} \\varepsilon_{0} \\varepsilon_{r} E^{2}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:4","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电场能"},{"categories":null,"content":"电场能 \\[W=\\int_{V} w_{e} d V\\] 其中\\(V\\)为含有\\(E\\)的空间。 \\[W=\\frac{Q^{2}}{2 C}=\\frac{1}{2} C\\left(V_{1}-V_{2}\\right)^{2}=\\frac{1}{2} Q\\left(V_{1}-V_{2}\\right)\\] 电场能密度 单位：\\(J/m^3\\) \\[w_{e}=\\frac{1}{2} D E=\\frac{1}{2} \\varepsilon_{0} \\varepsilon_{r} E^{2}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:4","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电场能密度"},{"categories":null,"content":"电势 求法： 通过已知电荷量的物体求电势： 点电荷 \\[V=\\frac{q}{4\\pi\\varepsilon_0 r}\\] 物体（点电荷积分） \\[\\mathrm{d}V=\\frac{\\mathrm{d}q }{4\\pi\\varepsilon_0 r}\\Rightarrow V=\\int\\frac{\\mathrm{d}q}{4\\pi\\varepsilon_0 r}\\] 通过已知场强求电势： \\[V=\\int_p^\\infty\\vec{E}\\cdot \\mathrm{d}\\vec{l}\\] 其中\\(\\vec E,\\cos\\theta\\)可以是关于\\(x\\)的函数。如果为匀强电场，则有： \\[U=\\Delta V=E d\\] 通过高斯定理可以求出分段的匀强电场，就要分段地求解电势。 特殊情况下的电势： 如果是圆环、半圆环或者部分圆环，只要求出总带电量 Q，在圆心处有： \\(V=\\frac{Q}{4\\pi\\varepsilon_0 R}\\) 电势能 电势与试探电荷无关，但电势能与试探电荷有关，只要把电势差乘上\\(q_0\\)即可求出电势能。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:5","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电势"},{"categories":null,"content":"电势 求法： 通过已知电荷量的物体求电势： 点电荷 \\[V=\\frac{q}{4\\pi\\varepsilon_0 r}\\] 物体（点电荷积分） \\[\\mathrm{d}V=\\frac{\\mathrm{d}q }{4\\pi\\varepsilon_0 r}\\Rightarrow V=\\int\\frac{\\mathrm{d}q}{4\\pi\\varepsilon_0 r}\\] 通过已知场强求电势： \\[V=\\int_p^\\infty\\vec{E}\\cdot \\mathrm{d}\\vec{l}\\] 其中\\(\\vec E,\\cos\\theta\\)可以是关于\\(x\\)的函数。如果为匀强电场，则有： \\[U=\\Delta V=E d\\] 通过高斯定理可以求出分段的匀强电场，就要分段地求解电势。 特殊情况下的电势： 如果是圆环、半圆环或者部分圆环，只要求出总带电量 Q，在圆心处有： \\(V=\\frac{Q}{4\\pi\\varepsilon_0 R}\\) 电势能 电势与试探电荷无关，但电势能与试探电荷有关，只要把电势差乘上\\(q_0\\)即可求出电势能。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:5","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电势能"},{"categories":null,"content":"导体 电荷分布在表面，内部场强处处为零 因此如果在导体内部的空腔中放置带电体产生电场，导体内表面会带上与带电体等大异号的电荷，导体外表面会带上与带电体等大同号的电荷，产生电场用于抵消带电体产生的电场，以保证内部合场强为\\(0\\)。 导体表面电场强度\\(E=\\frac{\\sigma}{\\varepsilon_0}\\) \\(\\sigma\\)：电荷量密度 导体表面曲率越大（尖锐），电荷密度越大 \\(\\varepsilon\\)：真空介电常量 导体是等势体，表面是等势面，但场强并非处处相等 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:6","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#导体"},{"categories":null,"content":"电容器 大小表达式：\\(C=\\frac{q}{U}\\) 电容充电时电压是会变化的，但是充电速度是由电流\\(\\frac{q}{t}\\)决定的。在恒定电流下，相同时间充入的电荷量是相同的，对于不同大小的电容表现为电容越大，充满电需要的时间越长。在充入相同电荷量的情况下，电容两端的电压越低（越远离外电源电压），电容的大小越大；在相同电压下，储存的电荷量越多，电容的大小越大。电容最大电压越小，电容越大。 电场强度：\\(E=\\frac{\\sigma}{\\varepsilon_0}=\\frac{U}{d}\\) 由于两个极板是导体，可以使用导体表面的电场强度公式，而电容内部为匀强电场，因此\\(E\\)有两种表达式。 电势差：\\(U=\\frac{q}{C}=E\\cdot d\\) 相互作用力：\\(F=\\frac{1}{2}E\\cdot q\\) 介电常量/电容率 若电容器含介质，则： \\(C=\\varepsilon_rC_0\\) \\(E=\\frac{E_0}{\\varepsilon_r}\\) \\(\\varepsilon=\\varepsilon_0\\cdot\\varepsilon_r\\) 其中\\(\\varepsilon_r\\)是相对介电常量，真空中为\\(1\\)。假设在带电量为\\(q\\)的电容器插入电介质，使\\(C=\\varepsilon_r C_0\\)，要保证带电量\\(q=UC=EdC\\)不变，因此\\(E=\\frac{E_0}{\\varepsilon_0}\\)。 常用电容器（含介质\\(\\varepsilon=\\varepsilon_0\\cdot\\varepsilon_r\\)） 平行板电容器 \\[C=\\frac{\\varepsilon S}{d}\\] 并且： \\(q=\\sigma S\\) 圆柱形球形电容器 \\[C=\\frac{2 \\pi \\varepsilon l}{\\ln R_{B} / R_{A}}\\] 球形电容器 \\[C=4 \\pi \\varepsilon \\frac{R_{A} R_{B}}{R_{B}-R_{A}}\\] 孤立导体电容器 令球形电容器的\\(R_B\\to\\infty\\)可以得到： \\[C=4 \\pi \\varepsilon R_{A}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:7","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电容器"},{"categories":null,"content":"电介质 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:1:8","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电介质"},{"categories":null,"content":"磁学 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:0","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#磁学"},{"categories":null,"content":"磁感应强度 单位面积的磁通量，单位是\\(T\\)。 求法 毕奥-萨伐尔定律 磁场中的安培环路定理 磁场强度 毕奥-萨伐尔定律 描述了在一点的电流对一点产生的磁感应强度。 \\[d B=\\frac{\\mu_{0}}{4 \\pi} \\cdot \\frac{I d l \\cdot \\sin \\theta}{r^{2}} \\Rightarrow B=\\int d B=\\frac{\\mu_{0}}{4 \\pi} \\int \\frac{I d l \\sin \\theta}{r^{2}}\\] \\(\\mathrm{d}l\\)：导线长度的微元。 \\(\\sin\\theta\\)：\\(\\mathrm{d}l\\)到该点连线与\\(\\mathrm{d}l\\)夹角的正弦值。 \\(\\mathrm{d}B\\)：磁感应强度的微元，与\\(r\\)和\\(\\mathrm{d}l\\)的叉乘同向（满足右手定则）。 \\(\\mu_0=4\\pi\\times 10^{-7} \\text{T}\\cdot \\text{m}/\\text{A}\\)：真空磁导率。 记忆方法：记住\\(\\mu_0\\)的量纲 结论 直线的记住\\(\\frac{\\mu_0I}{2\\pi a}\\)，圆弧记住\\(\\frac{\\mu_uI}{2a}\\)，平面是量纲的\\(\\frac{1}{2}\\)。 长为L导线，距离a： \\[B=\\frac{\\mu_0I}{2\\pi a}\\cdot \\frac{\\cos\\theta_1-\\cos\\theta_2}{2}\\] 无限长导线距离a： 令\\(\\theta_1\\to 0,\\theta_2\\to \\frac{\\pi}{2}\\)： \\[B=\\frac{\\mu_0 I}{2\\pi a}\\] 半无限长导线的一端 \\[B=\\frac{\\mu_0I}{4\\pi a}\\] 圆环电流的圆心： \\[B=\\frac{\\mu_0 I}{2R}\\] 圆弧的圆心： \\[B=\\frac{\\mu_0 I}{2 R}\\cdot \\frac{\\varphi}{2\\pi}\\] \\(\\varphi\\)：弧度单位 无限大平面： \\[B=\\frac{1}{2}\\mu_0 a\\] \\(a\\)：流过单位长度的电流 无限长螺线管： \\[B=\\mu_0 nI\\] \\(n=\\frac{N}{l}\\)：单位长度线圈匝数（匝数密度） 安培环路定理 和高斯定理很类似，不同的是高斯定理是闭合曲面，安培环路定理是闭合路径。电场和磁场的高斯定理和安培环路定理的性质恰好相反。 电场中的安培环路定理 \\[\\oint\\vec E \\mathrm{d}\\vec l=0\\] 表明电场中沿任意闭合路径移动一圈，电势差为\\(0\\)，因此电势能不变。 磁介质中的安培环路定理 \\[\\oint\\vec H \\mathrm{d}\\vec l=\\sum I\\] \\(H=\\frac{B}{\\mu_0\\mu_r}=\\frac{B}{\\mu_0}-M\\Rightarrow B=\\mu_0\\mu_rH\\) \\(M\\)：磁化强度 \\(H\\)：磁场强度 \\(\\mu=\\mu_0\\mu_r\\)：磁导率 相对磁导率\\(\\mu_r=\\frac{B}{B_0}\\)： \\(B\\)：磁介质中的磁感应强度 \\(B_0\\)：真空中的磁感应强度 \\(\\mu_0\\)：真空磁导率 \\(\\mu\\) 磁质 \\(\\mu_r=1\\) 真空 \\(\\mu_r\u003e1\\) 顺磁质 \\(\\mu_r\u003c1\\) 抗磁质 \\(\\mu_r \\gg 1\\) 铁磁质 磁场中（真空）的安培环路定理 \\[\\oint\\vec B \\mathrm{d}\\vec l=\\mu_0\\sum I\\] 真空磁导率\\(\\mu_0=4\\pi\\times 10^{-7} \\text{T}\\cdot \\text{m}/\\text{A}\\) 用于求导线周围磁感应强度的分布。如果环路是对称的，则： \\[B\\cdot\\oint \\mathrm{d}l=2\\pi rB=\\mu_0\\sum I\\Rightarrow B=\\frac{\\mu_0\\sum I}{2\\pi r}\\] 电流的定义是单位时间内通过某一 截面 的电荷量，因此电流可以用截面做比\\(I=I_0 \\frac{S}{S_0}\\)。 细节 安培环路定理只与环路内电流有关，与电流位置以及环路外电流无关。 \\(\\sum I\\)是指环路内的净电流（所有电流的代数和） 环路上一点的磁感应强度\\(B\\)，不仅由环路内电流影响，还由环路外电流影响。但是总体环路上的积分只受环路内的电流影响。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#磁感应强度"},{"categories":null,"content":"磁感应强度 单位面积的磁通量，单位是\\(T\\)。 求法 毕奥-萨伐尔定律 磁场中的安培环路定理 磁场强度 毕奥-萨伐尔定律 描述了在一点的电流对一点产生的磁感应强度。 \\[d B=\\frac{\\mu_{0}}{4 \\pi} \\cdot \\frac{I d l \\cdot \\sin \\theta}{r^{2}} \\Rightarrow B=\\int d B=\\frac{\\mu_{0}}{4 \\pi} \\int \\frac{I d l \\sin \\theta}{r^{2}}\\] \\(\\mathrm{d}l\\)：导线长度的微元。 \\(\\sin\\theta\\)：\\(\\mathrm{d}l\\)到该点连线与\\(\\mathrm{d}l\\)夹角的正弦值。 \\(\\mathrm{d}B\\)：磁感应强度的微元，与\\(r\\)和\\(\\mathrm{d}l\\)的叉乘同向（满足右手定则）。 \\(\\mu_0=4\\pi\\times 10^{-7} \\text{T}\\cdot \\text{m}/\\text{A}\\)：真空磁导率。 记忆方法：记住\\(\\mu_0\\)的量纲 结论 直线的记住\\(\\frac{\\mu_0I}{2\\pi a}\\)，圆弧记住\\(\\frac{\\mu_uI}{2a}\\)，平面是量纲的\\(\\frac{1}{2}\\)。 长为L导线，距离a： \\[B=\\frac{\\mu_0I}{2\\pi a}\\cdot \\frac{\\cos\\theta_1-\\cos\\theta_2}{2}\\] 无限长导线距离a： 令\\(\\theta_1\\to 0,\\theta_2\\to \\frac{\\pi}{2}\\)： \\[B=\\frac{\\mu_0 I}{2\\pi a}\\] 半无限长导线的一端 \\[B=\\frac{\\mu_0I}{4\\pi a}\\] 圆环电流的圆心： \\[B=\\frac{\\mu_0 I}{2R}\\] 圆弧的圆心： \\[B=\\frac{\\mu_0 I}{2 R}\\cdot \\frac{\\varphi}{2\\pi}\\] \\(\\varphi\\)：弧度单位 无限大平面： \\[B=\\frac{1}{2}\\mu_0 a\\] \\(a\\)：流过单位长度的电流 无限长螺线管： \\[B=\\mu_0 nI\\] \\(n=\\frac{N}{l}\\)：单位长度线圈匝数（匝数密度） 安培环路定理 和高斯定理很类似，不同的是高斯定理是闭合曲面，安培环路定理是闭合路径。电场和磁场的高斯定理和安培环路定理的性质恰好相反。 电场中的安培环路定理 \\[\\oint\\vec E \\mathrm{d}\\vec l=0\\] 表明电场中沿任意闭合路径移动一圈，电势差为\\(0\\)，因此电势能不变。 磁介质中的安培环路定理 \\[\\oint\\vec H \\mathrm{d}\\vec l=\\sum I\\] \\(H=\\frac{B}{\\mu_0\\mu_r}=\\frac{B}{\\mu_0}-M\\Rightarrow B=\\mu_0\\mu_rH\\) \\(M\\)：磁化强度 \\(H\\)：磁场强度 \\(\\mu=\\mu_0\\mu_r\\)：磁导率 相对磁导率\\(\\mu_r=\\frac{B}{B_0}\\)： \\(B\\)：磁介质中的磁感应强度 \\(B_0\\)：真空中的磁感应强度 \\(\\mu_0\\)：真空磁导率 \\(\\mu\\) 磁质 \\(\\mu_r=1\\) 真空 \\(\\mu_r\u003e1\\) 顺磁质 \\(\\mu_r\u003c1\\) 抗磁质 \\(\\mu_r \\gg 1\\) 铁磁质 磁场中（真空）的安培环路定理 \\[\\oint\\vec B \\mathrm{d}\\vec l=\\mu_0\\sum I\\] 真空磁导率\\(\\mu_0=4\\pi\\times 10^{-7} \\text{T}\\cdot \\text{m}/\\text{A}\\) 用于求导线周围磁感应强度的分布。如果环路是对称的，则： \\[B\\cdot\\oint \\mathrm{d}l=2\\pi rB=\\mu_0\\sum I\\Rightarrow B=\\frac{\\mu_0\\sum I}{2\\pi r}\\] 电流的定义是单位时间内通过某一 截面 的电荷量，因此电流可以用截面做比\\(I=I_0 \\frac{S}{S_0}\\)。 细节 安培环路定理只与环路内电流有关，与电流位置以及环路外电流无关。 \\(\\sum I\\)是指环路内的净电流（所有电流的代数和） 环路上一点的磁感应强度\\(B\\)，不仅由环路内电流影响，还由环路外电流影响。但是总体环路上的积分只受环路内的电流影响。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#毕奥-萨伐尔定律"},{"categories":null,"content":"磁感应强度 单位面积的磁通量，单位是\\(T\\)。 求法 毕奥-萨伐尔定律 磁场中的安培环路定理 磁场强度 毕奥-萨伐尔定律 描述了在一点的电流对一点产生的磁感应强度。 \\[d B=\\frac{\\mu_{0}}{4 \\pi} \\cdot \\frac{I d l \\cdot \\sin \\theta}{r^{2}} \\Rightarrow B=\\int d B=\\frac{\\mu_{0}}{4 \\pi} \\int \\frac{I d l \\sin \\theta}{r^{2}}\\] \\(\\mathrm{d}l\\)：导线长度的微元。 \\(\\sin\\theta\\)：\\(\\mathrm{d}l\\)到该点连线与\\(\\mathrm{d}l\\)夹角的正弦值。 \\(\\mathrm{d}B\\)：磁感应强度的微元，与\\(r\\)和\\(\\mathrm{d}l\\)的叉乘同向（满足右手定则）。 \\(\\mu_0=4\\pi\\times 10^{-7} \\text{T}\\cdot \\text{m}/\\text{A}\\)：真空磁导率。 记忆方法：记住\\(\\mu_0\\)的量纲 结论 直线的记住\\(\\frac{\\mu_0I}{2\\pi a}\\)，圆弧记住\\(\\frac{\\mu_uI}{2a}\\)，平面是量纲的\\(\\frac{1}{2}\\)。 长为L导线，距离a： \\[B=\\frac{\\mu_0I}{2\\pi a}\\cdot \\frac{\\cos\\theta_1-\\cos\\theta_2}{2}\\] 无限长导线距离a： 令\\(\\theta_1\\to 0,\\theta_2\\to \\frac{\\pi}{2}\\)： \\[B=\\frac{\\mu_0 I}{2\\pi a}\\] 半无限长导线的一端 \\[B=\\frac{\\mu_0I}{4\\pi a}\\] 圆环电流的圆心： \\[B=\\frac{\\mu_0 I}{2R}\\] 圆弧的圆心： \\[B=\\frac{\\mu_0 I}{2 R}\\cdot \\frac{\\varphi}{2\\pi}\\] \\(\\varphi\\)：弧度单位 无限大平面： \\[B=\\frac{1}{2}\\mu_0 a\\] \\(a\\)：流过单位长度的电流 无限长螺线管： \\[B=\\mu_0 nI\\] \\(n=\\frac{N}{l}\\)：单位长度线圈匝数（匝数密度） 安培环路定理 和高斯定理很类似，不同的是高斯定理是闭合曲面，安培环路定理是闭合路径。电场和磁场的高斯定理和安培环路定理的性质恰好相反。 电场中的安培环路定理 \\[\\oint\\vec E \\mathrm{d}\\vec l=0\\] 表明电场中沿任意闭合路径移动一圈，电势差为\\(0\\)，因此电势能不变。 磁介质中的安培环路定理 \\[\\oint\\vec H \\mathrm{d}\\vec l=\\sum I\\] \\(H=\\frac{B}{\\mu_0\\mu_r}=\\frac{B}{\\mu_0}-M\\Rightarrow B=\\mu_0\\mu_rH\\) \\(M\\)：磁化强度 \\(H\\)：磁场强度 \\(\\mu=\\mu_0\\mu_r\\)：磁导率 相对磁导率\\(\\mu_r=\\frac{B}{B_0}\\)： \\(B\\)：磁介质中的磁感应强度 \\(B_0\\)：真空中的磁感应强度 \\(\\mu_0\\)：真空磁导率 \\(\\mu\\) 磁质 \\(\\mu_r=1\\) 真空 \\(\\mu_r\u003e1\\) 顺磁质 \\(\\mu_r\u003c1\\) 抗磁质 \\(\\mu_r \\gg 1\\) 铁磁质 磁场中（真空）的安培环路定理 \\[\\oint\\vec B \\mathrm{d}\\vec l=\\mu_0\\sum I\\] 真空磁导率\\(\\mu_0=4\\pi\\times 10^{-7} \\text{T}\\cdot \\text{m}/\\text{A}\\) 用于求导线周围磁感应强度的分布。如果环路是对称的，则： \\[B\\cdot\\oint \\mathrm{d}l=2\\pi rB=\\mu_0\\sum I\\Rightarrow B=\\frac{\\mu_0\\sum I}{2\\pi r}\\] 电流的定义是单位时间内通过某一 截面 的电荷量，因此电流可以用截面做比\\(I=I_0 \\frac{S}{S_0}\\)。 细节 安培环路定理只与环路内电流有关，与电流位置以及环路外电流无关。 \\(\\sum I\\)是指环路内的净电流（所有电流的代数和） 环路上一点的磁感应强度\\(B\\)，不仅由环路内电流影响，还由环路外电流影响。但是总体环路上的积分只受环路内的电流影响。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#安培环路定理"},{"categories":null,"content":"磁通量 平面 \\[\\varPhi_e=B\\cdot S\\cos\\theta\\] 曲面 \\[\\varPhi_e=\\int_S\\vec B\\cdot \\mathrm{d}\\vec S\\] 向外穿出为正，向内穿入为负。与电通量一样，曲面的磁通量可以等效为其投影平面的磁通量。对于闭合曲面，磁通量满足高斯定理而恒为\\(0\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:2","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#磁通量"},{"categories":null,"content":"洛伦兹力 \\[F=Bqv\\] 当洛伦兹力提供向心力时： \\[F=Bqv=\\frac{mv^2}{R}=m\\omega^2R\\Rightarrow \\begin{cases}R\u0026=\\frac{mv}{qB} \\\\ T\u0026=\\frac{2\\pi}{\\omega}=2\\pi \\frac{m}{qB}\\end{cases}\\] 安培力 \\[F=I\\cdot B\\cdot L\\] 磁矩 \\[p_m=I\\cdot S\\] \\(S\\)：电流围成的面积。 方向遵循右手螺旋定则，四指握电流方向 磁力矩 \\[M=nBp_m I\\sin\\theta=nBI^2S\\sin\\theta\\] \\(n\\)：线圈匝数 \\(\\sin\\theta\\)：磁矩与磁感应强度的夹角 \\(p_m\\)：磁矩 做功： \\[A=I\\Delta \\varPhi_m\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:3","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#洛伦兹力"},{"categories":null,"content":"洛伦兹力 \\[F=Bqv\\] 当洛伦兹力提供向心力时： \\[F=Bqv=\\frac{mv^2}{R}=m\\omega^2R\\Rightarrow \\begin{cases}R\u0026=\\frac{mv}{qB} \\\\ T\u0026=\\frac{2\\pi}{\\omega}=2\\pi \\frac{m}{qB}\\end{cases}\\] 安培力 \\[F=I\\cdot B\\cdot L\\] 磁矩 \\[p_m=I\\cdot S\\] \\(S\\)：电流围成的面积。 方向遵循右手螺旋定则，四指握电流方向 磁力矩 \\[M=nBp_m I\\sin\\theta=nBI^2S\\sin\\theta\\] \\(n\\)：线圈匝数 \\(\\sin\\theta\\)：磁矩与磁感应强度的夹角 \\(p_m\\)：磁矩 做功： \\[A=I\\Delta \\varPhi_m\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:3","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#安培力"},{"categories":null,"content":"磁场强度 如果通电导线四周是磁介质，那么就要先用磁介质中的安培环路定理求得磁场强度，再用\\(B=\\mu_0\\mu_rH\\)求得磁感应强度。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:4","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#磁场强度"},{"categories":null,"content":"磁场能 磁能密度 \\[w_m=\\frac{1}{2}\\frac{B^2}{\\mu_0}\\] \\(B\\)：磁感应强度 \\(\\mu_0\\)：真空磁导率 通过\\(\\mu_0\\)的量纲分析，可知磁能密度的量纲为\\(N/m^2=J/m^3\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:5","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#磁场能"},{"categories":null,"content":"磁场能 磁能密度 \\[w_m=\\frac{1}{2}\\frac{B^2}{\\mu_0}\\] \\(B\\)：磁感应强度 \\(\\mu_0\\)：真空磁导率 通过\\(\\mu_0\\)的量纲分析，可知磁能密度的量纲为\\(N/m^2=J/m^3\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:5","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#磁能密度"},{"categories":null,"content":"电动势 感生电动势（磁感应强度变化） \\[\\varepsilon=-\\frac{d \\Phi}{d t}=\\oint \\vec{E}_{k} d \\vec{l}=-\\int \\frac{\\partial \\vec{B}}{\\partial t} d \\vec{S}\\] 动生电动势（面积变化） \\[\\varepsilon=-\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t}=B\\cdot l\\cdot v\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:6","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#电动势"},{"categories":null,"content":"自感电动势 \\[\\varepsilon=L \\frac{\\mathrm{d}I}{\\mathrm{d}t}\\] 自感系数\\(L=\\frac{\\varPhi}{I}\\) 注意：这个式子只是自感系数的定义式，而不是决定式，自感系数与形状、大小、匝数、磁介质有关，与电流和磁通量无关。因此可以通过代换把定义式中的电流和磁通量消去，得到决定式。由于通电螺线管产生的磁感应强度与匝数密度有关，因此通电螺线管的自感系数与长度与匝数均有关。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:7","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#自感电动势"},{"categories":null,"content":"互感系数 \\[M=\\frac{\\varPhi_2}{I_1}=\\frac{\\varPhi_1}{I_2}\\] 也就是\\(\\varPhi_1I_1=\\varPhi_2I_2\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:8","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#互感系数"},{"categories":null,"content":"麦克斯韦方程组 电场高斯定理：电场是有源场，电荷总伴随着电场 \\[\\oint \\vec{D}\\mathrm{d}\\vec{S}=\\sum q=\\int_{V} \\rho d V\\] 磁场高斯定理：磁场是无源场，磁力线闭合 \\[\\oint \\vec B \\mathrm{d} \\vec S=0\\] 变化的电场产生磁场 全电流安培环路定理： \\[\\oint \\vec{H} \\mathrm{d} \\vec{l}=I+I_{d}=\\int_{S} \\vec{j} \\mathrm{d} \\vec{S}+\\int_{S} \\frac{\\partial \\vec{D}}{\\partial t} \\mathrm{d} \\vec{S}\\] 变化的磁场一定伴随电场 \\[\\oint \\vec{E} \\mathrm{d} \\vec{l}=-\\frac{d \\Phi}{\\mathrm{d} t}=-\\int \\frac{\\partial \\vec{B}}{\\partial t} \\mathrm{d} \\vec{S}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:2:9","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#麦克斯韦方程组"},{"categories":null,"content":"振动 方程 \\[x=A\\cos \\left(\\omega t+\\varphi_0\\right)\\quad(SI)\\] \\(A=\\sqrt{x_0^2+\\frac{v_0^2}{\\omega^2}}\\) 只要知道一个位置的位移（坐标原点）和这个位置对应的速度即可求出振幅 角频率\\(\\omega=\\sqrt{\\frac{k}{m}}=\\frac{2\\pi}{T}\\) 周期\\(T=\\frac{2\\pi}{\\omega}\\) 频率\\(v=\\frac{1}{T}=\\frac{\\omega}{2\\pi}\\) 旋转矢量法 能量 机械能守恒：\\(E=\\frac{1}{2}mv^2+\\frac{1}{2}kx^2\\) 当 \\(E_k=0\\) 时， \\(E=E_\\mathrm{p}=\\frac{1}{2}kA^2\\) 合成 分别画矢量图：几何关系求解（通常都是在一条直线上的） 直接套公式 \\(A=\\sqrt{A_1^2+A_2^2+2A_1A_2\\cos(\\varphi_2-\\varphi_1)}\\) \\(\\tan=\\frac{A_1\\sin\\varphi_1+A_2\\sin\\varphi_2}{A_1\\cos\\varphi_1+A_2\\cos\\varphi_2}\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:3:0","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#振动"},{"categories":null,"content":"机械波 振动方程 如果\\(u\\)反相，则\\(\\frac{x}{u}\\)（波速）等前要变号： \\(y=A \\cos \\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi_{0}\\right]\\) \\(y=A \\cos \\left[2 \\pi\\left(v t-\\frac{x}{\\lambda}\\right)+\\varphi_{0}\\right]\\) \\(y=A \\cos \\left[\\omega t+\\varphi_{0}-\\frac{2 \\pi}{\\lambda} \\cdot x\\right]\\) 波速：\\(u=\\frac{\\lambda}{T}=\\lambda\\cdot v\\) 相位差 ：\\(\\Delta\\varphi=\\frac{2\\pi}{\\lambda}\\Delta x\\) 波动方程 求原点振动方程 \\(y=A\\cos(\\omega t+\\varphi_0)\\) 求波速 代入公式求波动方程 \\(y=A \\cos \\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi_{0}\\right]\\) 通过波动方程求任意点的振动方程 能量 势能取决于形变程度，因此对于机械波的每一点动能恒等于势能 干涉 条件 振动方向相同 频率相同 相位差恒定： 偶数倍：同大同小，相干加强 奇数倍：一大一小，相干减弱 干涉的相位差： \\[\\Delta \\varphi=\\varphi_2-\\varphi_1-\\frac{2\\pi(r_2-r_1)}{\\lambda}\\] 也就是波源本身的相位差和点到波源距离产生的相位差的和。 驻波 \\[\\begin{aligned} y_{1}\u0026=A \\cos 2 \\pi\\left(v t-\\frac{x}{\\lambda}\\right) \\\\ y_{2}\u0026=A \\cos 2 \\pi\\left(v t+\\frac{x}{\\lambda}\\right) \\end{aligned}\\] 平衡位置的点（波节）均不变，波的最大值（波腹）发生变化 驻波方程：\\(y=2 A \\cos 2 \\pi \\frac{x}{\\lambda} \\cdot \\cos 2 \\pi v t\\) 波节位置：\\(x=(2 k+1) \\frac{\\lambda}{4}(k=0, \\pm 1, \\pm 2)\\) 波腹位置：\\(x=k \\frac{\\lambda}{2}(k=0, \\pm 1, \\pm 2)\\) 多普勒效应 波源或接收在移动，波的频率会发生变化： \\[v=\\left(1-\\frac{u_0}{u}\\right)v_0\\] \\(u\\)：波源的移动速度 \\(u_0\\)：接收方的移动速度 \\(v_0\\)：波源的频率 \\(v\\)：接收方收到的频率 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:3:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#机械波"},{"categories":null,"content":"光学 干涉类型 光程差 条纹宽度 双缝干涉 \\(\\delta=d\\sin\\theta=\\frac{dx}{D}\\) \\(\\Delta x=\\frac{D\\lambda}{d}\\) 单缝干涉 \\(\\delta=a\\sin\\theta\\) 中央明条纹：\\(\\Delta x=\\frac{2f\\lambda}{a}\\) 次级明条纹：\\(\\Delta x=\\frac{f\\lambda}{a}\\) 光栅衍射 \\(\\delta=(a+b)\\sin\\theta\\) 等倾干涉 \\(\\delta=2nd\\quad(+\\frac{\\lambda}{2})\\) 劈尖干涉 \\(\\delta=2nd\\quad(+\\frac{\\lambda}{2})\\) 条纹高度差：\\(\\Delta h=\\frac{\\lambda}{2n}\\) 条纹间距：\\(\\frac{\\Delta h}{\\sin\\theta}\\) 透射增强：暗条纹反射增强：亮条纹 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:4:0","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#光学"},{"categories":null,"content":"马吕斯定律 自然光\\(\\xrightarrow{\\times\\frac{1}{2}}\\)偏振光1\\(\\xrightarrow{\\times\\cos^2\\theta_{12}}\\)偏振光2 … ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:4:1","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#马吕斯定律"},{"categories":null,"content":"布儒斯特定律 以下互为充要条件： 若反射光为线偏振光（完全偏振光） 折射光（透射光）为部分偏振光 反射光与折射光垂直 \\(\\tan i_B=\\frac{n_2}{n_1}\\)（\\(i_B\\)为入射角） ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/:4:2","series":null,"tags":["物理"],"title":"大学物理","uri":"/posts/notes/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/#布儒斯特定律"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:0:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#"},{"categories":null,"content":"电路元素 交流电路为什么要引入复数？复数相对于实数而言多了一个维度，一个数就可以表示更多的特性。电阻只能单一地阻碍电流，而电容和电感则可以在时间上阻碍电流，并且可以滞后或者超前，因此可以借用复数表示该特性。引入复数，可以将戴维南定理或欧姆定律等电路基本定律应用于电容与电感，就可以不用一直带着积分或者微分，而是只要掌握复数的运算法则即可。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#电路元素"},{"categories":null,"content":"支路 无分支的一段电路（必须有元件，不能只是导线）。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:1:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#支路"},{"categories":null,"content":"结点 三条及以上支路的连接点（多个结点直接通过导线连接，只算一个结点）。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:1:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#结点"},{"categories":null,"content":"回路 支路构成的闭合路径。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:1:3","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#回路"},{"categories":null,"content":"网孔 内部不含支路的回路。网孔数=支路数-（结点数-1）。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:1:4","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#网孔"},{"categories":null,"content":"等效变换 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#等效变换"},{"categories":null,"content":"电源等效变换 非理想电压源和电流源之间可以等效替换，等效的电压源/电流源直接用欧姆定律算，内阻变换位置。 变换对象：变换的源既可以是理想源，也可以是受控源。 变换后源的方向：不要以电压作为参考，而是以电流为参考。替换后的源产生电流的方向应该和原来的源保持一致。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#电源等效变换"},{"categories":null,"content":"电阻等效变换 \\(\\Delta/Y\\)形电阻等效变换 \\(R_Y=\\frac{\\text{相邻电阻乘积}}{\\text{电阻之和}}\\) \\(R_\\Delta=\\frac{\\text{两两乘积之和}}{\\text{相对的电阻}}\\) 规律： 总是两个除以一个 分子分母总有一边是相加的 凭感觉判断大小：对于一个角而言，△很像是并联，Y形下这个角的电阻相当于两个电阻的并联，应该是小的，因此分母要多一点 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#电阻等效变换"},{"categories":null,"content":"电阻等效变换 \\(\\Delta/Y\\)形电阻等效变换 \\(R_Y=\\frac{\\text{相邻电阻乘积}}{\\text{电阻之和}}\\) \\(R_\\Delta=\\frac{\\text{两两乘积之和}}{\\text{相对的电阻}}\\) 规律： 总是两个除以一个 分子分母总有一边是相加的 凭感觉判断大小：对于一个角而言，△很像是并联，Y形下这个角的电阻相当于两个电阻的并联，应该是小的，因此分母要多一点 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#delta-y-形电阻等效变换"},{"categories":null,"content":"元件省略 电压源和电流源/电阻并联→电压源 电流源与电压源/电阻串联→电流源 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:3","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#元件省略"},{"categories":null,"content":"戴维南定理 戴维南等效电路 求开路电压 求等效电阻 输入电阻\\(\\Rightarrow\\)等效电阻 输入电阻 置零 电压源→短路 电流源→断路 方法 哪种方法能表示出的变量越多用哪个 加压求流 加流求压 短路电流\\(\\Rightarrow\\) 等效电阻 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:4","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#戴维南定理"},{"categories":null,"content":"诺顿定理 求短路电流 求等效电阻 输入电阻⇒ 等效电阻 输入电阻 置零 电压源→短路 电流源→断路 方法 哪种方法能表示出的变量越多用哪个 加压求流 加流求压 开路电压\\(\\Rightarrow\\)等效电阻 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:5","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#诺顿定理"},{"categories":null,"content":"密勒定理 设有一个具有n个节点的线性电路，其中节点0为参考点。而节点1和节点2之间有一阻抗Z相接： 若节点电位\\(\\dot U_2\\)与\\(\\dot U_1\\)的比值为常数\\(\\dot K\\)，即\\(\\frac{\\dot U_2}{\\dot U_1}=\\dot K\\)，则可以把节点1和节点2间的\\(Z\\)等效为分别在节点1与参考节点0之间接一个阻抗\\(Z_1\\)和在节点2与参考节点0之间接另一个阻抗\\(Z_2\\)： 并且有： \\[\\begin{cases} Z_1\u0026=\\frac{Z}{1-\\dot K} \\\\ Z_2\u0026=Z\\cdot \\frac{\\dot K}{\\dot K-1}=\\frac{Z}{1-\\frac{1}{\\dot K}} \\end{cases}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:2:6","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#密勒定理"},{"categories":null,"content":"等效电阻 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#等效电阻"},{"categories":null,"content":"输入电阻 如果输入信号为电压源，那么输入电阻越大越好；如果是电流源，输入电阻越小越好，输出信号恰好相反。 置零 电压源→短路 电流源→断路 方法 哪种方法能表示出的变量越多用哪个。 加压求流 加流求压 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:3:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#输入电阻"},{"categories":null,"content":"输出电阻 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:3:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#输出电阻"},{"categories":null,"content":"基尔霍夫定律 假定方向 相同 电流\\(\\Leftrightarrow\\)电压 在电阻上可通过欧姆定律互相推导 电流方向由高电位到低电位 与实际方向（题目标注）相同 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#基尔霍夫定律"},{"categories":null,"content":"基尔霍夫电压定律 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:4:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#基尔霍夫电压定律"},{"categories":null,"content":"基尔霍夫电流定律 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#基尔霍夫电流定律"},{"categories":null,"content":"电路求解 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#电路求解"},{"categories":null,"content":"支路电流法 选择（结点数-1）个结点列 KCL 。 选择（支路数-（结点数-1））个支路列 KVL 。 联立求解。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:5:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#支路电流法"},{"categories":null,"content":"结点电压法 标注 选择相关结点的电位假定为0，其他结点从1开始标注 等效变换 和电流源串联的电阻不要写入方程。 省略 电压源和电流源/电阻并联→电压源 电流源与电压源/电阻串联→电流源 求电导\\(G\\) 自电导\\(G_{aa}\\) 与结点连接电阻的倒数和 互电导\\(G_{ab}=G_{ba}\\) 两个结点之间支路（注意不能含结点）所有电阻的倒数和再取负 求源流入结点电流\\(i_{sn}\\) 流出为负。 电压源：\\(i=\\frac{u}{R}\\) \\(R\\)：与电压源串联的电阻 电流源：\\(i\\) 列方程求解 \\[\\left\\{\\begin{array}{l} G_{11} u_{\\mathrm{n} 1}+G_{12} u_{\\mathrm{n} 2}+\\ldots+G_{1 \\mathrm{n}} u_{\\mathrm{nn}}=i_{\\mathrm{Sn} 1} \\\\ G_{21} u_{\\mathrm{n} 1}+G_{22} u_{\\mathrm{n} 2}+\\ldots+G_{2 \\mathrm{n}} u_{\\mathrm{nn}}=i_{\\mathrm{Sn} 2} \\\\ \\vdots \\\\ G_{\\mathrm{n} 1} u_{\\mathrm{n} 1}+G_{\\mathrm{n} 2} u_{\\mathrm{n} 2}+\\ldots+G_{\\mathrm{nn}} u_{\\mathrm{nn}}=i_{\\mathrm{Snn}} \\end{array}\\right.\\] 每一行对应一个结点。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:5:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#结点电压法"},{"categories":null,"content":"回路电流法 标注 选择（支路数-（结点数-1））个回路指定绕行方向并从1开始标注。 求电阻\\(R\\) 自电阻\\(R_{aa}\\)：回路电阻之和 互电阻\\(R_{ab}=R_{ba}\\) 两个回路共有的电阻之和，如果两个回路对流过电阻的假定电流方向相反要取负（对于网孔电流总是取负） 求源对回路产生的电压\\(u_{sn}\\) 与假定方向相反取负。 电压源：\\(u\\) 电流源：有电流源的回路电流已知，无需列出方程。 \\[u=iR\\] \\(R\\)：与电流源并联的电阻 列方程求解 \\[\\left\\{\\begin{array}{l} R_{11} i_{l 1}+R_{12} i_{11}+\\ldots+R_{1 l} i_{l}=u_{\\mathrm{S} l 1} \\\\ R_{21} i_{l 1}+R_{22} i_{l 1}+\\ldots+R_{2 l} i_{l l}=u_{\\mathrm{S} l 2} \\\\ \\vdots \\\\ R_{l l} i_{l 1}+R_{l 2} i_{l 1}+\\ldots+R_{l l} i_{l l}=u_{\\mathrm{Sll}} \\end{array}\\right.\\] 求出的电流是回路电流，要求支路电流要把所有相关回路电流带方向相加。 \\(u_{sn}\\) 回路上产生的电压升（在电压源上体现为-到+）。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:5:3","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#回路电流法"},{"categories":null,"content":"网孔电流法 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#网孔电流法"},{"categories":null,"content":"叠加定理 待求部分内 置零 电压源→短路 电流源→断路 求解待求参数 待求部分外 置零 电压源→短路 电流源→断路 求解待求参数 待求参数=置零待求部分内求出的参数+置零待求部分外得出的参数。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#叠加定理"},{"categories":null,"content":"功率 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#功率"},{"categories":null,"content":"有功功率 \\[P=UI\\cos\\varphi\\] 有功功率（单位\\(W\\)）\\(\\Rightarrow\\)平均功率，只要在纯电阻上找，相当于把U、I画在坐标系里向量的点乘，因此纯电容和纯电感的有功功率不管U、I多大，因为它们垂直，所以都是0。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#有功功率"},{"categories":null,"content":"无功功率 \\[Q=UI\\sin\\varphi\\] 无功功率（单位\\(\\operatorname{var}\\)）只要在纯电感、纯电容上找， ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#无功功率"},{"categories":null,"content":"功率因数 \\(\\cos\\varphi\\) \\(\\tan\\varphi=\\frac{Q_\\text{总}}{P_\\text{总}}\\) \\(Z=|Z|\\angle{\\varphi}\\) \\(U=ZI\\) \\(I=\\frac{U}{Z}\\) \\(\\varphi\\) 由元件阻抗的相位确定 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:3","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#功率因数"},{"categories":null,"content":"复功率 \\[\\bar S=P+jQ\\] ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:4","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#复功率"},{"categories":null,"content":"视在功率 \\[S_N=\\sqrt{P^2+Q^2}\\] 视在功率（单位\\(\\operatorname{VA}\\)） ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:5","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#视在功率"},{"categories":null,"content":"最大功率 \\[P_{\\max}=\\frac{u_\\mathrm{oc}}{4R_\\mathrm{eq}}\\] 将可变电阻之外的部分作戴维南/诺顿等效，当可变电阻阻值等于等效内阻时达到最大功率。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:7:6","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#最大功率"},{"categories":null,"content":"欧姆定律 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:8:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#欧姆定律"},{"categories":null,"content":"时间常数 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:9:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#时间常数"},{"categories":null,"content":"动态电路 看图写正弦交流变量表达式 \\(u=U_m\\sin(\\omega t+\\varphi)\\) \\(T=\\frac{2\\pi}{\\omega}=\\frac{1}{f}\\) \\(\\omega\\)：角频率 \\(\\varphi\\)：初相 交流量的运算 加减 \\[i=I_m\\sin(\\omega t+\\varphi)\\Rightarrow i=\\frac{I_m}{\\sqrt2}(\\cos\\varphi+j\\cdot\\sin\\varphi) \\\\ \\Rightarrow i=a+bj\\xrightarrow{运算后} i=\\sqrt2\\sqrt{a^2+b^2}\\sin(\\omega t+\\arctan\\frac{b}{a})\\] \\(\\omega\\) 相同的情况下才能进行加减乘除，这个值往往可以从题干直接获取。 \\(\\arctan\\frac{b}{a}\\) 画图来确定。 乘除 变换→计算→变回来 变换 \\(u=U_m\\sin(\\omega t+\\varphi)\\Leftrightarrow u=\\frac{U_m}{\\sqrt2}\\angle{\\varphi},\\varphi\\in[-180^{\\circ},180^{\\circ}]\\) \\(i=I_m\\sin(\\omega t+\\varphi)\\Leftrightarrow i=\\frac{I_m}{\\sqrt2}\\angle{\\varphi},\\varphi\\in[-180^{\\circ},180^{\\circ}]\\) \\(Z=a+bj\\Rightarrow Z=\\sqrt{a^2+b^2}\\angle{\\arctan\\frac{b}{a}}\\) 计算 \\(\\frac{x\\angle{\\varphi_1}}{y\\angle{\\varphi_2}}=\\frac{x}{y}\\angle{\\varphi_1-\\varphi_2}\\) \\(x\\angle{\\varphi_1}\\cdot y\\angle{\\varphi_2}=xy\\angle{\\varphi_1+\\varphi_2}\\) ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:10:0","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#动态电路"},{"categories":null,"content":"阻抗 把元件全部转换为Z，Z的并联串联关系和电阻一样。 \\[Z=\\begin{cases} R\u0026,\\text{电阻}\\\\ jX_L\u0026,\\text{电感}\\\\ -jX_C\\quad\u0026,\\text{电容} \\end{cases}\\] \\(X_L=\\omega L\\) \\(X_C=\\frac{1}{\\omega C}\\) 单位是F ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:10:1","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#阻抗"},{"categories":null,"content":"导纳 \\[Y=\\frac{1}{Z}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:10:2","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#导纳"},{"categories":null,"content":"相量图 就是画在极坐标下的射线： \\[\\rho\\angle{\\theta}\\] 概念 同相：朝向相同 电流流过电阻 反相：朝向相反 超前：在另一个变量的逆时针方向 电流流过电感 u比i超前90°，在一条电路上i肯定是不变的，只有u有可能超前或滞后 滞后：在另一个变量的顺时针方向 电流流过电容 u比i滞后90° 规律 满足矢量加减法 电路图中看出的分压关系，在相量图中表示为矢量的加减关系 \\(\\dot U=\\dot U_1+\\dot U_2\\) \\(U=|\\dot U|\\) ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:10:3","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#相量图"},{"categories":null,"content":"三要素法 用于动态电路求解。 \\(u_C(t)=u_C(\\infty)+\\left[u_C(0_+)-u_C(\\infty)\\right]e^{-\\frac{t-t_0}{\\tau}}\\) 可以求出任意时刻的电压 \\(\\tau=RC\\) \\(i_C=C\\frac{\\mathrm du_C}{\\mathrm dt}\\) \\(i_L(t)=i_L(\\infty)+\\left[i_L(0_+)-i_L(\\infty)\\right]e^{-\\frac{t-t_0}{\\tau}}\\) \\(\\tau=\\frac{L}{R}\\) \\(u_L=L\\frac{\\mathrm di_L}{\\mathrm dt}\\) 上式的\\(t_0,R\\)为： \\(t_0\\) 开始时间（其实就是图像在水平方向的移动，左加右减） \\(R\\) 变化后电路中，求去掉所求电容/电感后，其两端的输入电阻 输入电阻 置零 电压源→短路 电流源→断路 方法 哪种方法能表示出的变量越多用哪个 加压求流 加流求压 ","date":"2022-03-02","objectID":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/:10:4","series":null,"tags":["电子"],"title":"电路基础","uri":"/posts/notes/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/#三要素法"},{"categories":null,"content":"复数 常识： 两个复数（不全为实数）不能比较大小。 表示 \\(r=\\sqrt{x^2+y^2},\\theta=\\text{arg}(z),x=r\\cos\\theta,y=r\\sin\\theta\\)： 代数表示：\\(z=x+yi\\) 实部\\(\\text{Re}(z)=x\\) 虚部\\(\\text{Im}(z)=y\\) 三角表示：\\(z=r(\\cos\\theta+i\\sin\\theta)\\) 指数表示：\\(z=re^{i\\theta}\\) 其中三角表示和指数表示通过欧拉公式进行变换。 对于负频率： \\[x-yi=re^{-i\\theta}=r\\left( \\cos\\theta-i\\sin\\theta \\right)\\] 对于一个数 乘以\\(-1\\)：代表在复平面上旋转\\(180^\\circ\\) 乘以\\(j\\)：代表在复平面上逆时针旋转\\(90^\\circ\\) 运算 加减：复平面上向量的叠加（首尾相连） 实部与实部相加，虚部与虚部相加： \\[\\left(x_{1}+i y_{1}\\right) \\pm\\left(x_{2}+i y_{2}\\right) \\quad=\\left(x_{1} \\pm x_{2}\\right)+i\\left(y_{1} \\pm y_{2}\\right)\\] 相乘：模的扩大和辐角的相加 \\[\\left(x_{1}+i y_{1}\\right)\\left(x_{2}+i y_{2}\\right)=\\left(x_{1} x_{2}-y_{1} y_{2}\\right)+i\\left(x_{2} y_{1}+x_{1} y_{2}\\right)\\] 除法：模的缩小和辐角的相减 分子分母同时乘上能让分母变成平方差形式的项，即可把分母中的虚部消去： \\[\\frac{x_{1}+i y_{1}}{x_{2}+i y_{2}}=\\frac{\\left(x_{1}+i y_{1}\\right)\\left(x_{2}-i y_{2}\\right)}{\\left(x_{2}+i y_{2}\\right)\\left(x_{2}-i y_{2}\\right)}=\\frac{\\left(x_{1}+i y_{1}\\right)\\left(x_{2}-i y_{2}\\right)}{x_2^2+y_2^2}\\] 方根：复数辐角的等分 分步解法： \\[\\omega=\\sqrt[n]{x+i y}=(x+i y)^{\\frac{1}{n}}\\] 化为三角表示式：\\(x+i y=r(\\cos \\theta+i \\sin \\theta)\\) 设新的复数为开方结果：设 \\(\\omega=\\rho(\\cos \\varphi+i \\sin \\varphi)=[r(\\cos \\theta+i \\sin \\theta)]^{\\frac{1}{n}}\\) 与原来复数的对应关系：\\(\\begin{cases} \\rho\u0026=r^{\\frac{1}{n}} \\\\ \\varphi\u0026=\\frac{\\theta+2 k \\pi}{n},\\quad k=0,1, \\ldots, n-1\\end{cases} \\) 套公式： \\[\\sqrt[n]{z}=|z|^{\\frac{1}{2}}\\cdot\\left(\\cos\\frac{\\theta + 2k\\pi}{n} + i\\sin\\frac{\\theta + 2k\\pi}{n}\\right)\\] 其中 \\(\\begin{cases}k=0,1,2,\\dots,n-1 \\\\ \\theta = \\text{arg}(z)\\end{cases}\\)。 模 \\[|z|=\\sqrt{[\\operatorname{Re}(z)]^2+[\\operatorname{Im}(z)]^2}\\] 运算规律： \\(|z_1\\cdot z_2|=|z_1|\\cdot |z_2|\\) \\(\\left|\\frac{z_1}{z_2}\\right|=\\frac{|z_1|}{|z_2|}\\) 共轭复数 实部不变，虚部相反：\\(z=x+i y, \\bar{z}=x-i y\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:1:0","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#复数"},{"categories":null,"content":"辐角 \\(\\text{Arg}(z)=\\text{arg}(z)+2k\\pi,k=0,\\pm 1, \\pm 2, \\dots\\) 运算规律（可以由复数的指数表示推导）： \\(\\text{Arg}(z_1z_2)=\\text{Arg}(z_1)+\\text{Arg}(z_2)\\) \\(\\text{Arg}(\\frac{z_1}{z_2})=\\text{Arg}(z_1)-\\text{Arg}(z_2)\\) 辐角主值 辐角主值就是线段和x轴的夹角。 求法：画出复数的坐标系，x轴代表实部，y轴代表虚部。求出辐角主值，然后对辐角主值加减\\(2k\\pi\\)。 范围：\\(\\text{arg}(z)\\in(-\\pi,\\pi]\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:1:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#辐角"},{"categories":null,"content":"辐角 \\(\\text{Arg}(z)=\\text{arg}(z)+2k\\pi,k=0,\\pm 1, \\pm 2, \\dots\\) 运算规律（可以由复数的指数表示推导）： \\(\\text{Arg}(z_1z_2)=\\text{Arg}(z_1)+\\text{Arg}(z_2)\\) \\(\\text{Arg}(\\frac{z_1}{z_2})=\\text{Arg}(z_1)-\\text{Arg}(z_2)\\) 辐角主值 辐角主值就是线段和x轴的夹角。 求法：画出复数的坐标系，x轴代表实部，y轴代表虚部。求出辐角主值，然后对辐角主值加减\\(2k\\pi\\)。 范围：\\(\\text{arg}(z)\\in(-\\pi,\\pi]\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:1:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#辐角主值"},{"categories":null,"content":"方程 直角坐标方程转换为复数形式方程 \\[\\begin{cases}x=\\frac{z+\\bar z}{2}\\\\y=\\frac{z-\\bar z}{2i}\\end{cases}\\] 代入方程后得到有关\\(z,\\bar z\\)的方程就是答案。 复数形式方程转化为直角坐标方程 \\[\\begin{cases}z=x+yi\\\\bar z=x-yi\\end{cases}\\] 参数方程转换为复数形式方程将\\(\\begin{cases}x=\\dots\\\\y=\\dots\\end{cases}\\)代入\\(z=x+yi\\)即可。 复数形式方程转换为参数方程/一般形式从原方程中分离出实部与虚部，写成\\(\\begin{aligned}x=\\text{Im}(z)\\\\y=\\text{Re}(z)\\end{aligned}\\) 求复数在某映射下的象把复数代入映射方程。 已知范围的情况 以复数的指数表示设未知数，并代入映射方程 用\\(\\theta\\)表示\\(\\text{arg}(w)\\) \\(\\text{arg}(w)=\\frac{\\text{arg}(w)}{\\theta}\\cdot \\text{arg}(z)\\)，等号右边的范围是已知的。 用x、y表示的方程 求出映射方程的反函数（由w用z来表示，改成z用w来表示），并将\\(z=x+yi\\)、\\(w=u+vi\\)代入。 将x和y都用\\(u,v\\)来表示，并代入原方程。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:1:2","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#方程"},{"categories":null,"content":"复变函数 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:0","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#复变函数"},{"categories":null,"content":"初等函数 复变函数在实数域内是和实数函数是一致的，可以用这个来辅助记忆或检验。 指数函数 \\[\\operatorname{exp}z=e^z=e^x(\\cos y+i\\sin y)\\] 并且\\(\\operatorname{exp}z\\)以\\(2k\\pi i\\)为周期，当虚部\\(y\\)为\\(0\\)时，\\(z=x\\)，即\\(\\operatorname{exp}z=e^z\\)，永远达不到周期\\(2k\\pi i\\)，也就可以看作周期不存在。那么如何证明周期存在呢？ \\[e^{z+2k\\pi i}=e^z\\cdot (1\\cdot e^{2k\\pi i})=e^z\\] 由于\\(e^{2k\\pi i}\\)可以看作是模为\\(1\\)，与\\(x\\)轴夹角为0的复数，也就是\\(1\\)，因此可以证明周期存在。 计算 通过\\(z=x+yi\\)，可以把\\(e^z\\)化成\\(e^x(\\cos y+i\\sin y)\\)，计算加化简即可。 对数函数 \\[e^\\omega=z\\Rightarrow \\omega=\\operatorname{Ln}z\\] 其中： \\[\\begin{aligned} \\operatorname{Ln}z\u0026=\\ln\\left|z\\right|+i\\operatorname{Arg}z\\\\ \\ln z\u0026=\\ln\\left|z\\right|+i\\operatorname{arg}z \\end{aligned}\\] 幂函数 \\[a^b=e^{\\operatorname{Ln}a^b}=e^{b\\operatorname{Ln}a}\\] 三角函数 根据欧拉公式： \\[\\begin{cases}\\cos z+i\\sin z = e^{iz} \\\\ \\cos z-i\\sin z = e^{-iz} \\end{cases}\\] 即可凑出三角函数： 正弦函数 ：\\(\\sin z = \\frac{e^{iz}-e^{-iz}}{2i}\\) 余弦函数 ：\\(\\cos z=\\frac{e^{iz}+e^{-iz}}{2}\\) 双曲正弦函数\\(\\operatorname{sh}y\\) ：\\(\\sin iy=\\frac{e^{-y}-e^{y}}{2i}=i\\operatorname{sh}y\\) 双曲余弦函数\\(\\operatorname{ch}y\\) ：\\(\\cos iy=\\frac{e^{-y}+e^{y}}{2}=\\operatorname{ch}y\\) 如果把\\(e^{i\\omega t}\\)和\\(e^{-i\\omega t}\\)看作两个方向相反的沿着时间轴旋转的螺旋线，那么它们在复平面上的和（向量和）在虚轴上的投影就被抵消了。注意：\\(\\left|\\sin z\\right|\\leq 1,\\left|\\cos z\\right|\\leq 1\\)不再成立。 正弦0出0，余弦0出1（没有虚部），正弦是奇函数，所以 i 可以像负号一样提出来，sin变成 sh ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#初等函数"},{"categories":null,"content":"初等函数 复变函数在实数域内是和实数函数是一致的，可以用这个来辅助记忆或检验。 指数函数 \\[\\operatorname{exp}z=e^z=e^x(\\cos y+i\\sin y)\\] 并且\\(\\operatorname{exp}z\\)以\\(2k\\pi i\\)为周期，当虚部\\(y\\)为\\(0\\)时，\\(z=x\\)，即\\(\\operatorname{exp}z=e^z\\)，永远达不到周期\\(2k\\pi i\\)，也就可以看作周期不存在。那么如何证明周期存在呢？ \\[e^{z+2k\\pi i}=e^z\\cdot (1\\cdot e^{2k\\pi i})=e^z\\] 由于\\(e^{2k\\pi i}\\)可以看作是模为\\(1\\)，与\\(x\\)轴夹角为0的复数，也就是\\(1\\)，因此可以证明周期存在。 计算 通过\\(z=x+yi\\)，可以把\\(e^z\\)化成\\(e^x(\\cos y+i\\sin y)\\)，计算加化简即可。 对数函数 \\[e^\\omega=z\\Rightarrow \\omega=\\operatorname{Ln}z\\] 其中： \\[\\begin{aligned} \\operatorname{Ln}z\u0026=\\ln\\left|z\\right|+i\\operatorname{Arg}z\\\\ \\ln z\u0026=\\ln\\left|z\\right|+i\\operatorname{arg}z \\end{aligned}\\] 幂函数 \\[a^b=e^{\\operatorname{Ln}a^b}=e^{b\\operatorname{Ln}a}\\] 三角函数 根据欧拉公式： \\[\\begin{cases}\\cos z+i\\sin z = e^{iz} \\\\ \\cos z-i\\sin z = e^{-iz} \\end{cases}\\] 即可凑出三角函数： 正弦函数 ：\\(\\sin z = \\frac{e^{iz}-e^{-iz}}{2i}\\) 余弦函数 ：\\(\\cos z=\\frac{e^{iz}+e^{-iz}}{2}\\) 双曲正弦函数\\(\\operatorname{sh}y\\) ：\\(\\sin iy=\\frac{e^{-y}-e^{y}}{2i}=i\\operatorname{sh}y\\) 双曲余弦函数\\(\\operatorname{ch}y\\) ：\\(\\cos iy=\\frac{e^{-y}+e^{y}}{2}=\\operatorname{ch}y\\) 如果把\\(e^{i\\omega t}\\)和\\(e^{-i\\omega t}\\)看作两个方向相反的沿着时间轴旋转的螺旋线，那么它们在复平面上的和（向量和）在虚轴上的投影就被抵消了。注意：\\(\\left|\\sin z\\right|\\leq 1,\\left|\\cos z\\right|\\leq 1\\)不再成立。 正弦0出0，余弦0出1（没有虚部），正弦是奇函数，所以 i 可以像负号一样提出来，sin变成 sh ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#指数函数"},{"categories":null,"content":"初等函数 复变函数在实数域内是和实数函数是一致的，可以用这个来辅助记忆或检验。 指数函数 \\[\\operatorname{exp}z=e^z=e^x(\\cos y+i\\sin y)\\] 并且\\(\\operatorname{exp}z\\)以\\(2k\\pi i\\)为周期，当虚部\\(y\\)为\\(0\\)时，\\(z=x\\)，即\\(\\operatorname{exp}z=e^z\\)，永远达不到周期\\(2k\\pi i\\)，也就可以看作周期不存在。那么如何证明周期存在呢？ \\[e^{z+2k\\pi i}=e^z\\cdot (1\\cdot e^{2k\\pi i})=e^z\\] 由于\\(e^{2k\\pi i}\\)可以看作是模为\\(1\\)，与\\(x\\)轴夹角为0的复数，也就是\\(1\\)，因此可以证明周期存在。 计算 通过\\(z=x+yi\\)，可以把\\(e^z\\)化成\\(e^x(\\cos y+i\\sin y)\\)，计算加化简即可。 对数函数 \\[e^\\omega=z\\Rightarrow \\omega=\\operatorname{Ln}z\\] 其中： \\[\\begin{aligned} \\operatorname{Ln}z\u0026=\\ln\\left|z\\right|+i\\operatorname{Arg}z\\\\ \\ln z\u0026=\\ln\\left|z\\right|+i\\operatorname{arg}z \\end{aligned}\\] 幂函数 \\[a^b=e^{\\operatorname{Ln}a^b}=e^{b\\operatorname{Ln}a}\\] 三角函数 根据欧拉公式： \\[\\begin{cases}\\cos z+i\\sin z = e^{iz} \\\\ \\cos z-i\\sin z = e^{-iz} \\end{cases}\\] 即可凑出三角函数： 正弦函数 ：\\(\\sin z = \\frac{e^{iz}-e^{-iz}}{2i}\\) 余弦函数 ：\\(\\cos z=\\frac{e^{iz}+e^{-iz}}{2}\\) 双曲正弦函数\\(\\operatorname{sh}y\\) ：\\(\\sin iy=\\frac{e^{-y}-e^{y}}{2i}=i\\operatorname{sh}y\\) 双曲余弦函数\\(\\operatorname{ch}y\\) ：\\(\\cos iy=\\frac{e^{-y}+e^{y}}{2}=\\operatorname{ch}y\\) 如果把\\(e^{i\\omega t}\\)和\\(e^{-i\\omega t}\\)看作两个方向相反的沿着时间轴旋转的螺旋线，那么它们在复平面上的和（向量和）在虚轴上的投影就被抵消了。注意：\\(\\left|\\sin z\\right|\\leq 1,\\left|\\cos z\\right|\\leq 1\\)不再成立。 正弦0出0，余弦0出1（没有虚部），正弦是奇函数，所以 i 可以像负号一样提出来，sin变成 sh ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#对数函数"},{"categories":null,"content":"初等函数 复变函数在实数域内是和实数函数是一致的，可以用这个来辅助记忆或检验。 指数函数 \\[\\operatorname{exp}z=e^z=e^x(\\cos y+i\\sin y)\\] 并且\\(\\operatorname{exp}z\\)以\\(2k\\pi i\\)为周期，当虚部\\(y\\)为\\(0\\)时，\\(z=x\\)，即\\(\\operatorname{exp}z=e^z\\)，永远达不到周期\\(2k\\pi i\\)，也就可以看作周期不存在。那么如何证明周期存在呢？ \\[e^{z+2k\\pi i}=e^z\\cdot (1\\cdot e^{2k\\pi i})=e^z\\] 由于\\(e^{2k\\pi i}\\)可以看作是模为\\(1\\)，与\\(x\\)轴夹角为0的复数，也就是\\(1\\)，因此可以证明周期存在。 计算 通过\\(z=x+yi\\)，可以把\\(e^z\\)化成\\(e^x(\\cos y+i\\sin y)\\)，计算加化简即可。 对数函数 \\[e^\\omega=z\\Rightarrow \\omega=\\operatorname{Ln}z\\] 其中： \\[\\begin{aligned} \\operatorname{Ln}z\u0026=\\ln\\left|z\\right|+i\\operatorname{Arg}z\\\\ \\ln z\u0026=\\ln\\left|z\\right|+i\\operatorname{arg}z \\end{aligned}\\] 幂函数 \\[a^b=e^{\\operatorname{Ln}a^b}=e^{b\\operatorname{Ln}a}\\] 三角函数 根据欧拉公式： \\[\\begin{cases}\\cos z+i\\sin z = e^{iz} \\\\ \\cos z-i\\sin z = e^{-iz} \\end{cases}\\] 即可凑出三角函数： 正弦函数 ：\\(\\sin z = \\frac{e^{iz}-e^{-iz}}{2i}\\) 余弦函数 ：\\(\\cos z=\\frac{e^{iz}+e^{-iz}}{2}\\) 双曲正弦函数\\(\\operatorname{sh}y\\) ：\\(\\sin iy=\\frac{e^{-y}-e^{y}}{2i}=i\\operatorname{sh}y\\) 双曲余弦函数\\(\\operatorname{ch}y\\) ：\\(\\cos iy=\\frac{e^{-y}+e^{y}}{2}=\\operatorname{ch}y\\) 如果把\\(e^{i\\omega t}\\)和\\(e^{-i\\omega t}\\)看作两个方向相反的沿着时间轴旋转的螺旋线，那么它们在复平面上的和（向量和）在虚轴上的投影就被抵消了。注意：\\(\\left|\\sin z\\right|\\leq 1,\\left|\\cos z\\right|\\leq 1\\)不再成立。 正弦0出0，余弦0出1（没有虚部），正弦是奇函数，所以 i 可以像负号一样提出来，sin变成 sh ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#幂函数"},{"categories":null,"content":"初等函数 复变函数在实数域内是和实数函数是一致的，可以用这个来辅助记忆或检验。 指数函数 \\[\\operatorname{exp}z=e^z=e^x(\\cos y+i\\sin y)\\] 并且\\(\\operatorname{exp}z\\)以\\(2k\\pi i\\)为周期，当虚部\\(y\\)为\\(0\\)时，\\(z=x\\)，即\\(\\operatorname{exp}z=e^z\\)，永远达不到周期\\(2k\\pi i\\)，也就可以看作周期不存在。那么如何证明周期存在呢？ \\[e^{z+2k\\pi i}=e^z\\cdot (1\\cdot e^{2k\\pi i})=e^z\\] 由于\\(e^{2k\\pi i}\\)可以看作是模为\\(1\\)，与\\(x\\)轴夹角为0的复数，也就是\\(1\\)，因此可以证明周期存在。 计算 通过\\(z=x+yi\\)，可以把\\(e^z\\)化成\\(e^x(\\cos y+i\\sin y)\\)，计算加化简即可。 对数函数 \\[e^\\omega=z\\Rightarrow \\omega=\\operatorname{Ln}z\\] 其中： \\[\\begin{aligned} \\operatorname{Ln}z\u0026=\\ln\\left|z\\right|+i\\operatorname{Arg}z\\\\ \\ln z\u0026=\\ln\\left|z\\right|+i\\operatorname{arg}z \\end{aligned}\\] 幂函数 \\[a^b=e^{\\operatorname{Ln}a^b}=e^{b\\operatorname{Ln}a}\\] 三角函数 根据欧拉公式： \\[\\begin{cases}\\cos z+i\\sin z = e^{iz} \\\\ \\cos z-i\\sin z = e^{-iz} \\end{cases}\\] 即可凑出三角函数： 正弦函数 ：\\(\\sin z = \\frac{e^{iz}-e^{-iz}}{2i}\\) 余弦函数 ：\\(\\cos z=\\frac{e^{iz}+e^{-iz}}{2}\\) 双曲正弦函数\\(\\operatorname{sh}y\\) ：\\(\\sin iy=\\frac{e^{-y}-e^{y}}{2i}=i\\operatorname{sh}y\\) 双曲余弦函数\\(\\operatorname{ch}y\\) ：\\(\\cos iy=\\frac{e^{-y}+e^{y}}{2}=\\operatorname{ch}y\\) 如果把\\(e^{i\\omega t}\\)和\\(e^{-i\\omega t}\\)看作两个方向相反的沿着时间轴旋转的螺旋线，那么它们在复平面上的和（向量和）在虚轴上的投影就被抵消了。注意：\\(\\left|\\sin z\\right|\\leq 1,\\left|\\cos z\\right|\\leq 1\\)不再成立。 正弦0出0，余弦0出1（没有虚部），正弦是奇函数，所以 i 可以像负号一样提出来，sin变成 sh ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:1","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#三角函数"},{"categories":null,"content":"导数 导数的通用定义： \\[f^{\\prime}\\left(z_{0}\\right)=\\lim _{\\Delta z \\to 0} \\frac{f\\left(z_{0}+\\Delta z\\right)-f\\left(z_{0}\\right)}{\\Delta z}\\] \\(f(z)=u+iv\\)在点\\(z\\)处可导\\(\\Leftrightarrow\\)\\(u,v\\)在该点可导且满足柯西-黎曼方程， \\(f^{\\prime}(z)=\\frac{\\partial u}{\\partial x}+i \\frac{\\partial v}{\\partial x}=\\frac{\\partial v}{\\partial y}-i \\frac{\\partial u}{\\partial y}\\)（注意这里的两个等号均可用于求导数） ux正常，uy变态 注意\\(z\\)实际上包含了实部与虚部，而\\(x,y\\)用于表达实部与虚部，所以 \\(z\\)中包含了两个变量，或者说一个\\(z\\)就可以确定\\(x,y\\)的值。公式的\\(u,v\\)就是用\\(x,y\\)表示的实部和虚部。 柯西-黎曼方程 对于\\(f(z)=u+iv\\)： \\[\\left\\{\\begin{array}{l}\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\end{array}\\right.\\] 简称C-R方程，用于求复数函数的导数。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:2","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#导数"},{"categories":null,"content":"导数 导数的通用定义： \\[f^{\\prime}\\left(z_{0}\\right)=\\lim _{\\Delta z \\to 0} \\frac{f\\left(z_{0}+\\Delta z\\right)-f\\left(z_{0}\\right)}{\\Delta z}\\] \\(f(z)=u+iv\\)在点\\(z\\)处可导\\(\\Leftrightarrow\\)\\(u,v\\)在该点可导且满足柯西-黎曼方程， \\(f^{\\prime}(z)=\\frac{\\partial u}{\\partial x}+i \\frac{\\partial v}{\\partial x}=\\frac{\\partial v}{\\partial y}-i \\frac{\\partial u}{\\partial y}\\)（注意这里的两个等号均可用于求导数） ux正常，uy变态 注意\\(z\\)实际上包含了实部与虚部，而\\(x,y\\)用于表达实部与虚部，所以 \\(z\\)中包含了两个变量，或者说一个\\(z\\)就可以确定\\(x,y\\)的值。公式的\\(u,v\\)就是用\\(x,y\\)表示的实部和虚部。 柯西-黎曼方程 对于\\(f(z)=u+iv\\)： \\[\\left\\{\\begin{array}{l}\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\end{array}\\right.\\] 简称C-R方程，用于求复数函数的导数。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:2","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#柯西-黎曼方程"},{"categories":null,"content":"解析 \\(f(z)=u+iv\\)在区域\\(D\\)内解析\\(\\Leftrightarrow\\)\\(u,v\\)在区域\\(D\\)内可导且满足柯西-黎曼方程\\(\\Leftrightarrow\\)\\(f(z)\\)在区域\\(D\\)内处处可导。 与可导和连续的关系 解析\\(\\Rightarrow\\)可导\\(\\Rightarrow\\)连续（仅可单向推导），即： 连续\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)可导\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)解析 不连续\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不可导\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不解析（逆否命题） \\(z\\)平面上可解析\\(\\Leftrightarrow\\)处处可导 判断 写出\\(u(x, y)\\)、\\(v(x, y)\\) 代入柯西-黎曼方程 \\(\\left\\{\\begin{array}{l}\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\end{array}\\right. \\) 求出可导/解析区域（解出的\\(x\\)和\\(y\\)的约束关系）。 可导可以是点、直线、区域，而解析必须在区域上解析。 奇点 \\(f(z)\\)不解析的点。根据在\\(f(z)\\)展开式中\\((z-z_0)\\)负幂项有不同个数，有以下情况： 在\\(z_0\\)点 洛朗级数展开式中系数非\\(0\\)的负幂项个数/极点级数 可去奇点 \\(0\\) \\(m\\)级极点 \\(m\\) 本性奇点 \\(\\infty\\) 注意： 定义是用洛朗级数定义的，但是对任何一个函数都适用 如果极点级数为负，这个点就不是奇点。 奇点的可以通过零点（连续求导/分子分母分别求）来求。 零点 即\\(f(z)=0\\)的点。 \\(m\\)级零点：\\(\\begin{cases}f^{(m)}(z_0)\u0026\\neq 0 \\\\ f^{(n)}(z_0)\u0026=0,0\\leq\\forall n\u003cm\\end{cases}\\) 当\\(m=1\\)时，即一级零点就可以当作普通的函数零点。确定是几级零点的时候，就对\\(f(z)\\)进行连续求导，直到导数不为\\(0\\)为止，求导次数（包括导数不为\\(0\\)的那次）就是零点的级数。 零点和极点的关系：个数互为相反数 \\(z_0\\)是\\(f(z)\\)的\\(m\\)级零点\\(\\Leftrightarrow\\)\\(z_0\\)是\\(\\frac{1}{f(z)}\\)的\\(m\\)级极点 \\(z_0\\)是\\(f(z)\\)的\\(m\\)级零点，并且是\\(g(z)\\)的\\(n\\)级零点\\(\\Rightarrow\\)\\(z_0\\)是\\(\\frac{g(z)}{f(z)}\\)的\\(n-m\\)级零点\\(\\Rightarrow\\)\\(z_0\\)是\\(\\frac{g(z)}{f(z)}\\)的\\(m-n\\)级极点 也就是说，零点和极点呈倒数关系，负级的极点就是正级的零点，正级的极点就是负级的零点。 调和函数 函数\\(\\varphi(x, y)\\)在区域\\(D\\)上满足\\(\\frac{\\partial^{2} \\varphi}{\\partial x^{2}}+\\frac{\\partial^{2} \\varphi}{\\partial y^{2}}=0\\)，则\\(\\varphi(x,y)\\)为区域\\(D\\)的调和函数。 共轭调和函数 任意解析函数\\(f(z)=u+i v\\)，均满足\\(\\left\\{\\begin{array}{l}\\frac{\\partial^{2} u}{\\partial x^{2}}+\\frac{\\partial^{2} u}{\\partial y^{2}}=0 \\\\ \\frac{\\partial^{2} v}{\\partial x^{2}}+\\frac{\\partial^{2} v}{\\partial y^{2}}=0\\end{array}\\right.\\)。也就是从一个解析函数中可以得到两个调和函数，并且虚部\\(v\\)称为实部\\(u\\)的共轭调和函数（顺序不可颠倒）。 通过两个共轭调和函数求出对应的解析函数：假设题目中\\(u\\)是已知的： 由 \\(\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y}\\) 求出 \\(v=\\int\\frac{\\partial u}{\\partial x}\\mathrm dy=v+C(x)\\) 由于要求的解析函数肯定满足柯西-黎曼方程，因此可以通过联立柯西-黎曼方程求解出另一个函数。注意，通过\\(v(x,y)\\)的偏导数求不定积分，后面应该加上另外一个变量的常函数，而不是常数。 由 \\(\\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\) 求出 \\(C^\\prime(x)\\)（这里的\\(v\\)（包含）用的就是上一步求出来的） 对\\(C^\\prime\\)积分，求出含常数项\\(C_1\\)的\\(C(x)\\)，再求出 \\(v\\)，进而求出\\(f(z)\\) 将已知的\\(x,y,f(z)\\)的值代入，解出\\(C_1\\) 把 \\(x=z,y=0\\) 代入 \\(f=u+iv\\)，得到最终结果 由于\\(z=x+yi\\)，直接令\\(x=z,y=0\\)即可得到最后只含有\\(z\\)的式子。 ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:3","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#解析"},{"categories":null,"content":"解析 \\(f(z)=u+iv\\)在区域\\(D\\)内解析\\(\\Leftrightarrow\\)\\(u,v\\)在区域\\(D\\)内可导且满足柯西-黎曼方程\\(\\Leftrightarrow\\)\\(f(z)\\)在区域\\(D\\)内处处可导。 与可导和连续的关系 解析\\(\\Rightarrow\\)可导\\(\\Rightarrow\\)连续（仅可单向推导），即： 连续\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)可导\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)解析 不连续\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不可导\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不解析（逆否命题） \\(z\\)平面上可解析\\(\\Leftrightarrow\\)处处可导 判断 写出\\(u(x, y)\\)、\\(v(x, y)\\) 代入柯西-黎曼方程 \\(\\left\\{\\begin{array}{l}\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\end{array}\\right. \\) 求出可导/解析区域（解出的\\(x\\)和\\(y\\)的约束关系）。 可导可以是点、直线、区域，而解析必须在区域上解析。 奇点 \\(f(z)\\)不解析的点。根据在\\(f(z)\\)展开式中\\((z-z_0)\\)负幂项有不同个数，有以下情况： 在\\(z_0\\)点 洛朗级数展开式中系数非\\(0\\)的负幂项个数/极点级数 可去奇点 \\(0\\) \\(m\\)级极点 \\(m\\) 本性奇点 \\(\\infty\\) 注意： 定义是用洛朗级数定义的，但是对任何一个函数都适用 如果极点级数为负，这个点就不是奇点。 奇点的可以通过零点（连续求导/分子分母分别求）来求。 零点 即\\(f(z)=0\\)的点。 \\(m\\)级零点：\\(\\begin{cases}f^{(m)}(z_0)\u0026\\neq 0 \\\\ f^{(n)}(z_0)\u0026=0,0\\leq\\forall n","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:3","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#奇点"},{"categories":null,"content":"解析 \\(f(z)=u+iv\\)在区域\\(D\\)内解析\\(\\Leftrightarrow\\)\\(u,v\\)在区域\\(D\\)内可导且满足柯西-黎曼方程\\(\\Leftrightarrow\\)\\(f(z)\\)在区域\\(D\\)内处处可导。 与可导和连续的关系 解析\\(\\Rightarrow\\)可导\\(\\Rightarrow\\)连续（仅可单向推导），即： 连续\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)可导\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)解析 不连续\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不可导\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不解析（逆否命题） \\(z\\)平面上可解析\\(\\Leftrightarrow\\)处处可导 判断 写出\\(u(x, y)\\)、\\(v(x, y)\\) 代入柯西-黎曼方程 \\(\\left\\{\\begin{array}{l}\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\end{array}\\right. \\) 求出可导/解析区域（解出的\\(x\\)和\\(y\\)的约束关系）。 可导可以是点、直线、区域，而解析必须在区域上解析。 奇点 \\(f(z)\\)不解析的点。根据在\\(f(z)\\)展开式中\\((z-z_0)\\)负幂项有不同个数，有以下情况： 在\\(z_0\\)点 洛朗级数展开式中系数非\\(0\\)的负幂项个数/极点级数 可去奇点 \\(0\\) \\(m\\)级极点 \\(m\\) 本性奇点 \\(\\infty\\) 注意： 定义是用洛朗级数定义的，但是对任何一个函数都适用 如果极点级数为负，这个点就不是奇点。 奇点的可以通过零点（连续求导/分子分母分别求）来求。 零点 即\\(f(z)=0\\)的点。 \\(m\\)级零点：\\(\\begin{cases}f^{(m)}(z_0)\u0026\\neq 0 \\\\ f^{(n)}(z_0)\u0026=0,0\\leq\\forall n","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:3","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#零点"},{"categories":null,"content":"解析 \\(f(z)=u+iv\\)在区域\\(D\\)内解析\\(\\Leftrightarrow\\)\\(u,v\\)在区域\\(D\\)内可导且满足柯西-黎曼方程\\(\\Leftrightarrow\\)\\(f(z)\\)在区域\\(D\\)内处处可导。 与可导和连续的关系 解析\\(\\Rightarrow\\)可导\\(\\Rightarrow\\)连续（仅可单向推导），即： 连续\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)可导\\(\\begin{aligned}\\nRightarrow\\\\Leftarrow\\end{aligned}\\)解析 不连续\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不可导\\(\\begin{aligned}\\Rightarrow\\\\nLeftarrow\\end{aligned}\\)不解析（逆否命题） \\(z\\)平面上可解析\\(\\Leftrightarrow\\)处处可导 判断 写出\\(u(x, y)\\)、\\(v(x, y)\\) 代入柯西-黎曼方程 \\(\\left\\{\\begin{array}{l}\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}\\end{array}\\right. \\) 求出可导/解析区域（解出的\\(x\\)和\\(y\\)的约束关系）。 可导可以是点、直线、区域，而解析必须在区域上解析。 奇点 \\(f(z)\\)不解析的点。根据在\\(f(z)\\)展开式中\\((z-z_0)\\)负幂项有不同个数，有以下情况： 在\\(z_0\\)点 洛朗级数展开式中系数非\\(0\\)的负幂项个数/极点级数 可去奇点 \\(0\\) \\(m\\)级极点 \\(m\\) 本性奇点 \\(\\infty\\) 注意： 定义是用洛朗级数定义的，但是对任何一个函数都适用 如果极点级数为负，这个点就不是奇点。 奇点的可以通过零点（连续求导/分子分母分别求）来求。 零点 即\\(f(z)=0\\)的点。 \\(m\\)级零点：\\(\\begin{cases}f^{(m)}(z_0)\u0026\\neq 0 \\\\ f^{(n)}(z_0)\u0026=0,0\\leq\\forall n","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:3","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#调和函数"},{"categories":null,"content":"极限 数列的极限 复数列收敛等价于实部收敛，虚部也收敛：复数列\\(\\left\\{ \\alpha_n=a_n+ib_n \\right\\}\\)收敛\\(\\Leftrightarrow\\) \\(\\lim\\limits_{n\\to\\infty}a_n=a,\\lim\\limits_{n\\to\\infty}b_n=b\\Leftrightarrow \\lim\\limits_{n\\to\\infty}\\alpha_n=a+ib\\) 收敛 类型 绝对收敛 \\(\\sum\\limits_{n=1}^\\infty\\left| a_n \\right|\\) 收敛，且\\(\\sum\\limits_{n=1}^\\infty a_n\\)收敛。 条件收敛 \\(\\sum\\limits_{n=1}^\\infty \\left| a_n \\right|\\) 不收敛，但\\(\\sum\\limits_{n=1}^\\infty a_n\\)收敛，则\\(\\sum\\limits_{n=1}^\\infty a_n\\)条件收敛。 绝对值不收敛，就是非绝对收敛，就是条件收敛，由于\\(\\rho\\)是用绝对值来判断的，因此无法判断条件收敛和发散 判断 对于 \\(\\sum\\limits_{n=0}^\\infty a_n\\)： 比值法判断敛散性 \\[\\rho=\\lim_{n\\to\\infty}\\left|\\frac{a_{n+1}}{a_n}\\right|\\] 根值法判断敛散性 \\[\\rho=\\lim_{n\\to\\infty}\\sqrt[n]{\\left|a_n\\right|}\\] 对于以上方法求出的\\(\\rho\\)： \\(\\rho\u003c1\\)：收敛 \\(\\rho\u003e1\\)：发散/条件收敛 \\(R=\\frac{1}{\\rho}\\)：收敛半径 \\(|z|\u003cR\\)：收敛域（绝对值符号代表模长） 结论 调和级数\\(\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\)是发散的。 若\\(\\sum\\limits_{n=1}^\\infty a_nz^n\\)在\\(z_0\\)发散，则\\(|z|\u003e|z_0|\\)处发散 若\\(\\sum\\limits_{n=1}^\\infty a_nz^n\\)在\\(z_0\\)收敛，则\\(|z|\u003c|z_0|\\)处绝对收敛 \\(z\\)是一个变量，如等于\\(2\\)时相当于\\(a_12^1+a_22^2+a_32^3+\\dots+a_n2^n\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:4","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#极限"},{"categories":null,"content":"极限 数列的极限 复数列收敛等价于实部收敛，虚部也收敛：复数列\\(\\left\\{ \\alpha_n=a_n+ib_n \\right\\}\\)收敛\\(\\Leftrightarrow\\) \\(\\lim\\limits_{n\\to\\infty}a_n=a,\\lim\\limits_{n\\to\\infty}b_n=b\\Leftrightarrow \\lim\\limits_{n\\to\\infty}\\alpha_n=a+ib\\) 收敛 类型 绝对收敛 \\(\\sum\\limits_{n=1}^\\infty\\left| a_n \\right|\\) 收敛，且\\(\\sum\\limits_{n=1}^\\infty a_n\\)收敛。 条件收敛 \\(\\sum\\limits_{n=1}^\\infty \\left| a_n \\right|\\) 不收敛，但\\(\\sum\\limits_{n=1}^\\infty a_n\\)收敛，则\\(\\sum\\limits_{n=1}^\\infty a_n\\)条件收敛。 绝对值不收敛，就是非绝对收敛，就是条件收敛，由于\\(\\rho\\)是用绝对值来判断的，因此无法判断条件收敛和发散 判断 对于 \\(\\sum\\limits_{n=0}^\\infty a_n\\)： 比值法判断敛散性 \\[\\rho=\\lim_{n\\to\\infty}\\left|\\frac{a_{n+1}}{a_n}\\right|\\] 根值法判断敛散性 \\[\\rho=\\lim_{n\\to\\infty}\\sqrt[n]{\\left|a_n\\right|}\\] 对于以上方法求出的\\(\\rho\\)： \\(\\rho\u003c1\\)：收敛 \\(\\rho\u003e1\\)：发散/条件收敛 \\(R=\\frac{1}{\\rho}\\)：收敛半径 \\(|z||z_0|\\)处发散 若\\(\\sum\\limits_{n=1}^\\infty a_nz^n\\)在\\(z_0\\)收敛，则\\(|z|\u003c|z_0|\\)处绝对收敛 \\(z\\)是一个变量，如等于\\(2\\)时相当于\\(a_12^1+a_22^2+a_32^3+\\dots+a_n2^n\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:4","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#数列的极限"},{"categories":null,"content":"极限 数列的极限 复数列收敛等价于实部收敛，虚部也收敛：复数列\\(\\left\\{ \\alpha_n=a_n+ib_n \\right\\}\\)收敛\\(\\Leftrightarrow\\) \\(\\lim\\limits_{n\\to\\infty}a_n=a,\\lim\\limits_{n\\to\\infty}b_n=b\\Leftrightarrow \\lim\\limits_{n\\to\\infty}\\alpha_n=a+ib\\) 收敛 类型 绝对收敛 \\(\\sum\\limits_{n=1}^\\infty\\left| a_n \\right|\\) 收敛，且\\(\\sum\\limits_{n=1}^\\infty a_n\\)收敛。 条件收敛 \\(\\sum\\limits_{n=1}^\\infty \\left| a_n \\right|\\) 不收敛，但\\(\\sum\\limits_{n=1}^\\infty a_n\\)收敛，则\\(\\sum\\limits_{n=1}^\\infty a_n\\)条件收敛。 绝对值不收敛，就是非绝对收敛，就是条件收敛，由于\\(\\rho\\)是用绝对值来判断的，因此无法判断条件收敛和发散 判断 对于 \\(\\sum\\limits_{n=0}^\\infty a_n\\)： 比值法判断敛散性 \\[\\rho=\\lim_{n\\to\\infty}\\left|\\frac{a_{n+1}}{a_n}\\right|\\] 根值法判断敛散性 \\[\\rho=\\lim_{n\\to\\infty}\\sqrt[n]{\\left|a_n\\right|}\\] 对于以上方法求出的\\(\\rho\\)： \\(\\rho\u003c1\\)：收敛 \\(\\rho\u003e1\\)：发散/条件收敛 \\(R=\\frac{1}{\\rho}\\)：收敛半径 \\(|z||z_0|\\)处发散 若\\(\\sum\\limits_{n=1}^\\infty a_nz^n\\)在\\(z_0\\)收敛，则\\(|z|\u003c|z_0|\\)处绝对收敛 \\(z\\)是一个变量，如等于\\(2\\)时相当于\\(a_12^1+a_22^2+a_32^3+\\dots+a_n2^n\\) ","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:4","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#收敛"},{"categories":null,"content":"级数 调和级数 \\[\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\] 泰勒级数 幂级数 和函数 幂级数展开式/泰勒展开式 收敛域 \\(\\frac{1}{1-z}\\) \\(\\sum\\limits_{n=0}^{\\infty} z^{n}=1+z+z^{2}+\\ldots \\ldots+z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(\\frac{1}{1+z}\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} z^{n}=1-z+z^{2}+\\ldots \\ldots+(-1)^{n} z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(e^{z}\\) \\(\\sum\\limits_{n=0}^{\\infty} \\frac{1}{n !} z^{n}=1+z+\\frac{z^{2}}{2 !}+\\ldots \\ldots+\\frac{z^{n}}{n !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\sin z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}=z-\\frac{z^{3}}{3 !}+\\frac{z^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\cos z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n}}{(2 n) !}=1-\\frac{z^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{z^{2 n}}{(2 n) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) 注意，\\(n\\)都是从\\(0\\)开始的。收敛域的意义就是在某个条件下，展开式收敛并且等于和函数。在 \\(z=a\\) 处展开为幂级数，就是展开为 \\((z-a)^n\\) 形式。 \\(z\\)的负号守恒（要么在前，要么在后） 第二个式子就是把\\(-z\\)代入第一个式子 收敛域为无穷时必须有分母牵制 有\\(-1\\)才有奇偶数之分 正弦是奇函数，也是奇数\\(2n+1\\) 余弦是偶函数，也是偶数\\(2n\\) 洛朗级数 可以看作是泰勒级数的推广。对于泰勒级数，幂的次数都是大于或等于0的，方法同幂级数，下限为\\(n=-\\infty\\)。 留数 若\\(f(z)=\\sum\\limits_{n=-\\infty}^{+\\infty}c_n(z-z_0)^n\\)，则\\(\\operatorname{Res}\\left[ f(z),z_0 \\right]=c_{-1}\\)，也就是\\((z-z_0)\\)展开式中\\((z-z_0)^{-1}\\)项的系数。如果展开式不含\\((z-z_0)^{-1}\\)，则留数为\\(0\\)（如\\(\\operatorname{Res}[\\cos z, 0]=0\\)） 性质 \\[\\sum_{i=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]=0\\] 其中\\(z_i\\)为所有奇点并且包括无穷点。 规则 很多函数没法轻松地使用洛朗级数展开，就有如下求留数的规则： 规则1 若\\(z_0\\)为\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}\\left[ f(z),z \\right]=\\lim_{z\\to z_0}(z-z_0)f(z)\\] 很好理解，要求\\(c_{-1}(z-z_0)^{-1}\\)中的\\(c_{-1}\\)，只要把\\(f(z)\\)乘上\\((z-z_0)\\)，函数在\\(z_0\\)的值就是\\(c_{-1}\\)，为了防止函数里的项无意义，所以求极限。 规则2 \\(z_0\\)为\\(f(z)\\)的\\(m\\)级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}\\left[ (z-z_0)^m f(z) \\right]}{\\mathrm{d}z^{m-1}} \\] 和规则1的理解方式一样，由于是\\(m\\)级极点，说明说\\((z-z_0)^m\\)前面的点都是不解析的， \\((z-z_0)^mf(z)=\\dots+c_{-m}+c_{-m+1}(z-z_0)+\\dots+c_{-1}(z-z_0)^{m-1}\\)，对\\((z-z_0)\\)求\\(m-1\\)阶导得到\\(\\dots+(m-1)!\\cdot c_{-1}+\\dots\\)，最后除以\\((m-1)!\\)得到\\(c_1\\)。 规则3 若\\(f(z)=\\frac{P(z)}{Q(z)}\\)，\\(z_0\\)是\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{P(z)}{Q^\\prime(z_0)}\\] 有些函数用奇点代入规则1或规则2出现极限不存在（往往是分母不是\\((z-z_0)^n\\)这种形式），可以用规则3，感觉有点像洛必达法则。 规则4 \\[\\operatorname{Res}[f(z),\\infty]=-\\operatorname{Res}\\left[f\\left( \\frac{1}{z} \\right) \\cdot \\frac{1}{z^2},0\\right]\\] 相当于将规则2的\\(z\\)用\\(\\frac{1}{z}\\)代换，原函数乘上\\(\\frac{\\mathrm{d}\\frac{1}{z}}{\\mathrm{d}z}=-\\frac{1}{z^2}\\)。 求积分 留数可用于求积分，对于\\(z_k\\)是在\\(c\\)内部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_k \\right]\\] 对于\\(z_i\\)是在\\(c\\)外部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=-2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]\\] \\(f(z)\\)的在\\(c\\)上的积分，就是求\\(f(z)\\)在\\(c\\)内部所有奇点的留数之和。用留数求积分可以推导出高阶导数公式，因为只要\\((z-z_0)^n\\)在分母上，那么\\(z_0\\)必为\\(n\\)级奇点，根据规则2，即可推出高阶导数公式。 由于是奇点，所以有虚数单位\\(i\\)，是环路积分，所以有\\(2\\pi\\)。 对于以下几种用实数无法求出的积分，可以用留数来求： 对于三角函数的积分 \\[\\int_{0}^{2 \\pi} R(\\cos \\theta, \\sin \\theta) d \\theta, \\quad d \\theta=\\frac{d z}{i z}\\] 令\\(\\left\\{\\begin{array}{l}\\sin \\theta=\\frac{z-z^{-1}}{2 i} \\\\ \\cos \\theta=\\frac{z+z^{-1}}{2}\\end{array} \\Rightarrow \\oint_{|z|=1} f(z) d z\\right.\\) 就是把三角函数用上面的含\\(z\\)表达式代换，对\\(\\mathrm{d}\\theta\\)也进行代换，然后把积分号换成环路积分。变成环路积分就可以用留数来求了。 其实就是三角函数的变式（\\(e^{\\pm iz}\\rightarrow (z=e^{iz})^{\\pm 1}\\)），少了的\\(iz\\)要在\\(\\mathrm{d}\\theta\\)上补回来。 无穷积分（分上下限为正负无穷） \\[\\int_{-\\infty}^{+\\infty} R(x) d x=2 \\pi i \\sum \\operatorname{Res}\\left[R(z), z_{k}\\right]\\] 其中\\(z_{k}\\) 为\\(R(z)\\)在上半平面内的奇点。 含\\(e^{aix}\\)的无穷积分、三角函数积分 \\[\\begin{aligned} \u0026\\int_{-\\infty}^{+ \\infty} R(x) e^{a i x} d x \\\\ =\u00262 \\pi i \\sum \\operatorname{Res}\\left[R(z) e^{a i z}, z_{k}\\right] \\\\ =\u0026\\int_{-\\infty}^{+ \\infty} R(x) \\cos a x d x+i \\int_{-\\infty}^{+ \\infty} R(x) \\sin a x d x \\end{aligned}\\] 可以看作就是方法2的推广（\\(a=0\\)代入）。最后一个等号是把\\(e^{aix}\\)看作复数的指数表示，然后化为复数的三角表示，这两个项可以单独出现在题目中的，如果单独出现，也可以向前变换成复数的指数表示。 与留数求积分的特例： 环路积分变成反常积分 \\(f(x)\\)变成\\(R(x)e^{aix}\\) 傅里叶级数 \\[f(t)=\\dots+c_{-2}e^{-2 it}+c_{-1}e^{- it}+c_0+c_1e^{ it}+c_2e^{2 it}+\\dots=\\sum_{\\omega=-\\infty}^{+\\infty}c_\\omega e^{\\omega it}\\] 其中\\(f(t)\\)是一个复","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:5","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#级数"},{"categories":null,"content":"级数 调和级数 \\[\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\] 泰勒级数 幂级数 和函数 幂级数展开式/泰勒展开式 收敛域 \\(\\frac{1}{1-z}\\) \\(\\sum\\limits_{n=0}^{\\infty} z^{n}=1+z+z^{2}+\\ldots \\ldots+z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(\\frac{1}{1+z}\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} z^{n}=1-z+z^{2}+\\ldots \\ldots+(-1)^{n} z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(e^{z}\\) \\(\\sum\\limits_{n=0}^{\\infty} \\frac{1}{n !} z^{n}=1+z+\\frac{z^{2}}{2 !}+\\ldots \\ldots+\\frac{z^{n}}{n !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\sin z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}=z-\\frac{z^{3}}{3 !}+\\frac{z^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\cos z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n}}{(2 n) !}=1-\\frac{z^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{z^{2 n}}{(2 n) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) 注意，\\(n\\)都是从\\(0\\)开始的。收敛域的意义就是在某个条件下，展开式收敛并且等于和函数。在 \\(z=a\\) 处展开为幂级数，就是展开为 \\((z-a)^n\\) 形式。 \\(z\\)的负号守恒（要么在前，要么在后） 第二个式子就是把\\(-z\\)代入第一个式子 收敛域为无穷时必须有分母牵制 有\\(-1\\)才有奇偶数之分 正弦是奇函数，也是奇数\\(2n+1\\) 余弦是偶函数，也是偶数\\(2n\\) 洛朗级数 可以看作是泰勒级数的推广。对于泰勒级数，幂的次数都是大于或等于0的，方法同幂级数，下限为\\(n=-\\infty\\)。 留数 若\\(f(z)=\\sum\\limits_{n=-\\infty}^{+\\infty}c_n(z-z_0)^n\\)，则\\(\\operatorname{Res}\\left[ f(z),z_0 \\right]=c_{-1}\\)，也就是\\((z-z_0)\\)展开式中\\((z-z_0)^{-1}\\)项的系数。如果展开式不含\\((z-z_0)^{-1}\\)，则留数为\\(0\\)（如\\(\\operatorname{Res}[\\cos z, 0]=0\\)） 性质 \\[\\sum_{i=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]=0\\] 其中\\(z_i\\)为所有奇点并且包括无穷点。 规则 很多函数没法轻松地使用洛朗级数展开，就有如下求留数的规则： 规则1 若\\(z_0\\)为\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}\\left[ f(z),z \\right]=\\lim_{z\\to z_0}(z-z_0)f(z)\\] 很好理解，要求\\(c_{-1}(z-z_0)^{-1}\\)中的\\(c_{-1}\\)，只要把\\(f(z)\\)乘上\\((z-z_0)\\)，函数在\\(z_0\\)的值就是\\(c_{-1}\\)，为了防止函数里的项无意义，所以求极限。 规则2 \\(z_0\\)为\\(f(z)\\)的\\(m\\)级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}\\left[ (z-z_0)^m f(z) \\right]}{\\mathrm{d}z^{m-1}} \\] 和规则1的理解方式一样，由于是\\(m\\)级极点，说明说\\((z-z_0)^m\\)前面的点都是不解析的， \\((z-z_0)^mf(z)=\\dots+c_{-m}+c_{-m+1}(z-z_0)+\\dots+c_{-1}(z-z_0)^{m-1}\\)，对\\((z-z_0)\\)求\\(m-1\\)阶导得到\\(\\dots+(m-1)!\\cdot c_{-1}+\\dots\\)，最后除以\\((m-1)!\\)得到\\(c_1\\)。 规则3 若\\(f(z)=\\frac{P(z)}{Q(z)}\\)，\\(z_0\\)是\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{P(z)}{Q^\\prime(z_0)}\\] 有些函数用奇点代入规则1或规则2出现极限不存在（往往是分母不是\\((z-z_0)^n\\)这种形式），可以用规则3，感觉有点像洛必达法则。 规则4 \\[\\operatorname{Res}[f(z),\\infty]=-\\operatorname{Res}\\left[f\\left( \\frac{1}{z} \\right) \\cdot \\frac{1}{z^2},0\\right]\\] 相当于将规则2的\\(z\\)用\\(\\frac{1}{z}\\)代换，原函数乘上\\(\\frac{\\mathrm{d}\\frac{1}{z}}{\\mathrm{d}z}=-\\frac{1}{z^2}\\)。 求积分 留数可用于求积分，对于\\(z_k\\)是在\\(c\\)内部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_k \\right]\\] 对于\\(z_i\\)是在\\(c\\)外部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=-2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]\\] \\(f(z)\\)的在\\(c\\)上的积分，就是求\\(f(z)\\)在\\(c\\)内部所有奇点的留数之和。用留数求积分可以推导出高阶导数公式，因为只要\\((z-z_0)^n\\)在分母上，那么\\(z_0\\)必为\\(n\\)级奇点，根据规则2，即可推出高阶导数公式。 由于是奇点，所以有虚数单位\\(i\\)，是环路积分，所以有\\(2\\pi\\)。 对于以下几种用实数无法求出的积分，可以用留数来求： 对于三角函数的积分 \\[\\int_{0}^{2 \\pi} R(\\cos \\theta, \\sin \\theta) d \\theta, \\quad d \\theta=\\frac{d z}{i z}\\] 令\\(\\left\\{\\begin{array}{l}\\sin \\theta=\\frac{z-z^{-1}}{2 i} \\\\ \\cos \\theta=\\frac{z+z^{-1}}{2}\\end{array} \\Rightarrow \\oint_{|z|=1} f(z) d z\\right.\\) 就是把三角函数用上面的含\\(z\\)表达式代换，对\\(\\mathrm{d}\\theta\\)也进行代换，然后把积分号换成环路积分。变成环路积分就可以用留数来求了。 其实就是三角函数的变式（\\(e^{\\pm iz}\\rightarrow (z=e^{iz})^{\\pm 1}\\)），少了的\\(iz\\)要在\\(\\mathrm{d}\\theta\\)上补回来。 无穷积分（分上下限为正负无穷） \\[\\int_{-\\infty}^{+\\infty} R(x) d x=2 \\pi i \\sum \\operatorname{Res}\\left[R(z), z_{k}\\right]\\] 其中\\(z_{k}\\) 为\\(R(z)\\)在上半平面内的奇点。 含\\(e^{aix}\\)的无穷积分、三角函数积分 \\[\\begin{aligned} \u0026\\int_{-\\infty}^{+ \\infty} R(x) e^{a i x} d x \\\\ =\u00262 \\pi i \\sum \\operatorname{Res}\\left[R(z) e^{a i z}, z_{k}\\right] \\\\ =\u0026\\int_{-\\infty}^{+ \\infty} R(x) \\cos a x d x+i \\int_{-\\infty}^{+ \\infty} R(x) \\sin a x d x \\end{aligned}\\] 可以看作就是方法2的推广（\\(a=0\\)代入）。最后一个等号是把\\(e^{aix}\\)看作复数的指数表示，然后化为复数的三角表示，这两个项可以单独出现在题目中的，如果单独出现，也可以向前变换成复数的指数表示。 与留数求积分的特例： 环路积分变成反常积分 \\(f(x)\\)变成\\(R(x)e^{aix}\\) 傅里叶级数 \\[f(t)=\\dots+c_{-2}e^{-2 it}+c_{-1}e^{- it}+c_0+c_1e^{ it}+c_2e^{2 it}+\\dots=\\sum_{\\omega=-\\infty}^{+\\infty}c_\\omega e^{\\omega it}\\] 其中\\(f(t)\\)是一个复","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:5","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#调和级数"},{"categories":null,"content":"级数 调和级数 \\[\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\] 泰勒级数 幂级数 和函数 幂级数展开式/泰勒展开式 收敛域 \\(\\frac{1}{1-z}\\) \\(\\sum\\limits_{n=0}^{\\infty} z^{n}=1+z+z^{2}+\\ldots \\ldots+z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(\\frac{1}{1+z}\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} z^{n}=1-z+z^{2}+\\ldots \\ldots+(-1)^{n} z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(e^{z}\\) \\(\\sum\\limits_{n=0}^{\\infty} \\frac{1}{n !} z^{n}=1+z+\\frac{z^{2}}{2 !}+\\ldots \\ldots+\\frac{z^{n}}{n !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\sin z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}=z-\\frac{z^{3}}{3 !}+\\frac{z^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\cos z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n}}{(2 n) !}=1-\\frac{z^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{z^{2 n}}{(2 n) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) 注意，\\(n\\)都是从\\(0\\)开始的。收敛域的意义就是在某个条件下，展开式收敛并且等于和函数。在 \\(z=a\\) 处展开为幂级数，就是展开为 \\((z-a)^n\\) 形式。 \\(z\\)的负号守恒（要么在前，要么在后） 第二个式子就是把\\(-z\\)代入第一个式子 收敛域为无穷时必须有分母牵制 有\\(-1\\)才有奇偶数之分 正弦是奇函数，也是奇数\\(2n+1\\) 余弦是偶函数，也是偶数\\(2n\\) 洛朗级数 可以看作是泰勒级数的推广。对于泰勒级数，幂的次数都是大于或等于0的，方法同幂级数，下限为\\(n=-\\infty\\)。 留数 若\\(f(z)=\\sum\\limits_{n=-\\infty}^{+\\infty}c_n(z-z_0)^n\\)，则\\(\\operatorname{Res}\\left[ f(z),z_0 \\right]=c_{-1}\\)，也就是\\((z-z_0)\\)展开式中\\((z-z_0)^{-1}\\)项的系数。如果展开式不含\\((z-z_0)^{-1}\\)，则留数为\\(0\\)（如\\(\\operatorname{Res}[\\cos z, 0]=0\\)） 性质 \\[\\sum_{i=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]=0\\] 其中\\(z_i\\)为所有奇点并且包括无穷点。 规则 很多函数没法轻松地使用洛朗级数展开，就有如下求留数的规则： 规则1 若\\(z_0\\)为\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}\\left[ f(z),z \\right]=\\lim_{z\\to z_0}(z-z_0)f(z)\\] 很好理解，要求\\(c_{-1}(z-z_0)^{-1}\\)中的\\(c_{-1}\\)，只要把\\(f(z)\\)乘上\\((z-z_0)\\)，函数在\\(z_0\\)的值就是\\(c_{-1}\\)，为了防止函数里的项无意义，所以求极限。 规则2 \\(z_0\\)为\\(f(z)\\)的\\(m\\)级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}\\left[ (z-z_0)^m f(z) \\right]}{\\mathrm{d}z^{m-1}} \\] 和规则1的理解方式一样，由于是\\(m\\)级极点，说明说\\((z-z_0)^m\\)前面的点都是不解析的， \\((z-z_0)^mf(z)=\\dots+c_{-m}+c_{-m+1}(z-z_0)+\\dots+c_{-1}(z-z_0)^{m-1}\\)，对\\((z-z_0)\\)求\\(m-1\\)阶导得到\\(\\dots+(m-1)!\\cdot c_{-1}+\\dots\\)，最后除以\\((m-1)!\\)得到\\(c_1\\)。 规则3 若\\(f(z)=\\frac{P(z)}{Q(z)}\\)，\\(z_0\\)是\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{P(z)}{Q^\\prime(z_0)}\\] 有些函数用奇点代入规则1或规则2出现极限不存在（往往是分母不是\\((z-z_0)^n\\)这种形式），可以用规则3，感觉有点像洛必达法则。 规则4 \\[\\operatorname{Res}[f(z),\\infty]=-\\operatorname{Res}\\left[f\\left( \\frac{1}{z} \\right) \\cdot \\frac{1}{z^2},0\\right]\\] 相当于将规则2的\\(z\\)用\\(\\frac{1}{z}\\)代换，原函数乘上\\(\\frac{\\mathrm{d}\\frac{1}{z}}{\\mathrm{d}z}=-\\frac{1}{z^2}\\)。 求积分 留数可用于求积分，对于\\(z_k\\)是在\\(c\\)内部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_k \\right]\\] 对于\\(z_i\\)是在\\(c\\)外部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=-2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]\\] \\(f(z)\\)的在\\(c\\)上的积分，就是求\\(f(z)\\)在\\(c\\)内部所有奇点的留数之和。用留数求积分可以推导出高阶导数公式，因为只要\\((z-z_0)^n\\)在分母上，那么\\(z_0\\)必为\\(n\\)级奇点，根据规则2，即可推出高阶导数公式。 由于是奇点，所以有虚数单位\\(i\\)，是环路积分，所以有\\(2\\pi\\)。 对于以下几种用实数无法求出的积分，可以用留数来求： 对于三角函数的积分 \\[\\int_{0}^{2 \\pi} R(\\cos \\theta, \\sin \\theta) d \\theta, \\quad d \\theta=\\frac{d z}{i z}\\] 令\\(\\left\\{\\begin{array}{l}\\sin \\theta=\\frac{z-z^{-1}}{2 i} \\\\ \\cos \\theta=\\frac{z+z^{-1}}{2}\\end{array} \\Rightarrow \\oint_{|z|=1} f(z) d z\\right.\\) 就是把三角函数用上面的含\\(z\\)表达式代换，对\\(\\mathrm{d}\\theta\\)也进行代换，然后把积分号换成环路积分。变成环路积分就可以用留数来求了。 其实就是三角函数的变式（\\(e^{\\pm iz}\\rightarrow (z=e^{iz})^{\\pm 1}\\)），少了的\\(iz\\)要在\\(\\mathrm{d}\\theta\\)上补回来。 无穷积分（分上下限为正负无穷） \\[\\int_{-\\infty}^{+\\infty} R(x) d x=2 \\pi i \\sum \\operatorname{Res}\\left[R(z), z_{k}\\right]\\] 其中\\(z_{k}\\) 为\\(R(z)\\)在上半平面内的奇点。 含\\(e^{aix}\\)的无穷积分、三角函数积分 \\[\\begin{aligned} \u0026\\int_{-\\infty}^{+ \\infty} R(x) e^{a i x} d x \\\\ =\u00262 \\pi i \\sum \\operatorname{Res}\\left[R(z) e^{a i z}, z_{k}\\right] \\\\ =\u0026\\int_{-\\infty}^{+ \\infty} R(x) \\cos a x d x+i \\int_{-\\infty}^{+ \\infty} R(x) \\sin a x d x \\end{aligned}\\] 可以看作就是方法2的推广（\\(a=0\\)代入）。最后一个等号是把\\(e^{aix}\\)看作复数的指数表示，然后化为复数的三角表示，这两个项可以单独出现在题目中的，如果单独出现，也可以向前变换成复数的指数表示。 与留数求积分的特例： 环路积分变成反常积分 \\(f(x)\\)变成\\(R(x)e^{aix}\\) 傅里叶级数 \\[f(t)=\\dots+c_{-2}e^{-2 it}+c_{-1}e^{- it}+c_0+c_1e^{ it}+c_2e^{2 it}+\\dots=\\sum_{\\omega=-\\infty}^{+\\infty}c_\\omega e^{\\omega it}\\] 其中\\(f(t)\\)是一个复","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:5","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#泰勒级数"},{"categories":null,"content":"级数 调和级数 \\[\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\] 泰勒级数 幂级数 和函数 幂级数展开式/泰勒展开式 收敛域 \\(\\frac{1}{1-z}\\) \\(\\sum\\limits_{n=0}^{\\infty} z^{n}=1+z+z^{2}+\\ldots \\ldots+z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(\\frac{1}{1+z}\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} z^{n}=1-z+z^{2}+\\ldots \\ldots+(-1)^{n} z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(e^{z}\\) \\(\\sum\\limits_{n=0}^{\\infty} \\frac{1}{n !} z^{n}=1+z+\\frac{z^{2}}{2 !}+\\ldots \\ldots+\\frac{z^{n}}{n !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\sin z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}=z-\\frac{z^{3}}{3 !}+\\frac{z^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\cos z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n}}{(2 n) !}=1-\\frac{z^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{z^{2 n}}{(2 n) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) 注意，\\(n\\)都是从\\(0\\)开始的。收敛域的意义就是在某个条件下，展开式收敛并且等于和函数。在 \\(z=a\\) 处展开为幂级数，就是展开为 \\((z-a)^n\\) 形式。 \\(z\\)的负号守恒（要么在前，要么在后） 第二个式子就是把\\(-z\\)代入第一个式子 收敛域为无穷时必须有分母牵制 有\\(-1\\)才有奇偶数之分 正弦是奇函数，也是奇数\\(2n+1\\) 余弦是偶函数，也是偶数\\(2n\\) 洛朗级数 可以看作是泰勒级数的推广。对于泰勒级数，幂的次数都是大于或等于0的，方法同幂级数，下限为\\(n=-\\infty\\)。 留数 若\\(f(z)=\\sum\\limits_{n=-\\infty}^{+\\infty}c_n(z-z_0)^n\\)，则\\(\\operatorname{Res}\\left[ f(z),z_0 \\right]=c_{-1}\\)，也就是\\((z-z_0)\\)展开式中\\((z-z_0)^{-1}\\)项的系数。如果展开式不含\\((z-z_0)^{-1}\\)，则留数为\\(0\\)（如\\(\\operatorname{Res}[\\cos z, 0]=0\\)） 性质 \\[\\sum_{i=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]=0\\] 其中\\(z_i\\)为所有奇点并且包括无穷点。 规则 很多函数没法轻松地使用洛朗级数展开，就有如下求留数的规则： 规则1 若\\(z_0\\)为\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}\\left[ f(z),z \\right]=\\lim_{z\\to z_0}(z-z_0)f(z)\\] 很好理解，要求\\(c_{-1}(z-z_0)^{-1}\\)中的\\(c_{-1}\\)，只要把\\(f(z)\\)乘上\\((z-z_0)\\)，函数在\\(z_0\\)的值就是\\(c_{-1}\\)，为了防止函数里的项无意义，所以求极限。 规则2 \\(z_0\\)为\\(f(z)\\)的\\(m\\)级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}\\left[ (z-z_0)^m f(z) \\right]}{\\mathrm{d}z^{m-1}} \\] 和规则1的理解方式一样，由于是\\(m\\)级极点，说明说\\((z-z_0)^m\\)前面的点都是不解析的， \\((z-z_0)^mf(z)=\\dots+c_{-m}+c_{-m+1}(z-z_0)+\\dots+c_{-1}(z-z_0)^{m-1}\\)，对\\((z-z_0)\\)求\\(m-1\\)阶导得到\\(\\dots+(m-1)!\\cdot c_{-1}+\\dots\\)，最后除以\\((m-1)!\\)得到\\(c_1\\)。 规则3 若\\(f(z)=\\frac{P(z)}{Q(z)}\\)，\\(z_0\\)是\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{P(z)}{Q^\\prime(z_0)}\\] 有些函数用奇点代入规则1或规则2出现极限不存在（往往是分母不是\\((z-z_0)^n\\)这种形式），可以用规则3，感觉有点像洛必达法则。 规则4 \\[\\operatorname{Res}[f(z),\\infty]=-\\operatorname{Res}\\left[f\\left( \\frac{1}{z} \\right) \\cdot \\frac{1}{z^2},0\\right]\\] 相当于将规则2的\\(z\\)用\\(\\frac{1}{z}\\)代换，原函数乘上\\(\\frac{\\mathrm{d}\\frac{1}{z}}{\\mathrm{d}z}=-\\frac{1}{z^2}\\)。 求积分 留数可用于求积分，对于\\(z_k\\)是在\\(c\\)内部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_k \\right]\\] 对于\\(z_i\\)是在\\(c\\)外部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=-2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]\\] \\(f(z)\\)的在\\(c\\)上的积分，就是求\\(f(z)\\)在\\(c\\)内部所有奇点的留数之和。用留数求积分可以推导出高阶导数公式，因为只要\\((z-z_0)^n\\)在分母上，那么\\(z_0\\)必为\\(n\\)级奇点，根据规则2，即可推出高阶导数公式。 由于是奇点，所以有虚数单位\\(i\\)，是环路积分，所以有\\(2\\pi\\)。 对于以下几种用实数无法求出的积分，可以用留数来求： 对于三角函数的积分 \\[\\int_{0}^{2 \\pi} R(\\cos \\theta, \\sin \\theta) d \\theta, \\quad d \\theta=\\frac{d z}{i z}\\] 令\\(\\left\\{\\begin{array}{l}\\sin \\theta=\\frac{z-z^{-1}}{2 i} \\\\ \\cos \\theta=\\frac{z+z^{-1}}{2}\\end{array} \\Rightarrow \\oint_{|z|=1} f(z) d z\\right.\\) 就是把三角函数用上面的含\\(z\\)表达式代换，对\\(\\mathrm{d}\\theta\\)也进行代换，然后把积分号换成环路积分。变成环路积分就可以用留数来求了。 其实就是三角函数的变式（\\(e^{\\pm iz}\\rightarrow (z=e^{iz})^{\\pm 1}\\)），少了的\\(iz\\)要在\\(\\mathrm{d}\\theta\\)上补回来。 无穷积分（分上下限为正负无穷） \\[\\int_{-\\infty}^{+\\infty} R(x) d x=2 \\pi i \\sum \\operatorname{Res}\\left[R(z), z_{k}\\right]\\] 其中\\(z_{k}\\) 为\\(R(z)\\)在上半平面内的奇点。 含\\(e^{aix}\\)的无穷积分、三角函数积分 \\[\\begin{aligned} \u0026\\int_{-\\infty}^{+ \\infty} R(x) e^{a i x} d x \\\\ =\u00262 \\pi i \\sum \\operatorname{Res}\\left[R(z) e^{a i z}, z_{k}\\right] \\\\ =\u0026\\int_{-\\infty}^{+ \\infty} R(x) \\cos a x d x+i \\int_{-\\infty}^{+ \\infty} R(x) \\sin a x d x \\end{aligned}\\] 可以看作就是方法2的推广（\\(a=0\\)代入）。最后一个等号是把\\(e^{aix}\\)看作复数的指数表示，然后化为复数的三角表示，这两个项可以单独出现在题目中的，如果单独出现，也可以向前变换成复数的指数表示。 与留数求积分的特例： 环路积分变成反常积分 \\(f(x)\\)变成\\(R(x)e^{aix}\\) 傅里叶级数 \\[f(t)=\\dots+c_{-2}e^{-2 it}+c_{-1}e^{- it}+c_0+c_1e^{ it}+c_2e^{2 it}+\\dots=\\sum_{\\omega=-\\infty}^{+\\infty}c_\\omega e^{\\omega it}\\] 其中\\(f(t)\\)是一个复","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:5","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#洛朗级数"},{"categories":null,"content":"级数 调和级数 \\[\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\] 泰勒级数 幂级数 和函数 幂级数展开式/泰勒展开式 收敛域 \\(\\frac{1}{1-z}\\) \\(\\sum\\limits_{n=0}^{\\infty} z^{n}=1+z+z^{2}+\\ldots \\ldots+z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(\\frac{1}{1+z}\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} z^{n}=1-z+z^{2}+\\ldots \\ldots+(-1)^{n} z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(e^{z}\\) \\(\\sum\\limits_{n=0}^{\\infty} \\frac{1}{n !} z^{n}=1+z+\\frac{z^{2}}{2 !}+\\ldots \\ldots+\\frac{z^{n}}{n !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\sin z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}=z-\\frac{z^{3}}{3 !}+\\frac{z^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\cos z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n}}{(2 n) !}=1-\\frac{z^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{z^{2 n}}{(2 n) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) 注意，\\(n\\)都是从\\(0\\)开始的。收敛域的意义就是在某个条件下，展开式收敛并且等于和函数。在 \\(z=a\\) 处展开为幂级数，就是展开为 \\((z-a)^n\\) 形式。 \\(z\\)的负号守恒（要么在前，要么在后） 第二个式子就是把\\(-z\\)代入第一个式子 收敛域为无穷时必须有分母牵制 有\\(-1\\)才有奇偶数之分 正弦是奇函数，也是奇数\\(2n+1\\) 余弦是偶函数，也是偶数\\(2n\\) 洛朗级数 可以看作是泰勒级数的推广。对于泰勒级数，幂的次数都是大于或等于0的，方法同幂级数，下限为\\(n=-\\infty\\)。 留数 若\\(f(z)=\\sum\\limits_{n=-\\infty}^{+\\infty}c_n(z-z_0)^n\\)，则\\(\\operatorname{Res}\\left[ f(z),z_0 \\right]=c_{-1}\\)，也就是\\((z-z_0)\\)展开式中\\((z-z_0)^{-1}\\)项的系数。如果展开式不含\\((z-z_0)^{-1}\\)，则留数为\\(0\\)（如\\(\\operatorname{Res}[\\cos z, 0]=0\\)） 性质 \\[\\sum_{i=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]=0\\] 其中\\(z_i\\)为所有奇点并且包括无穷点。 规则 很多函数没法轻松地使用洛朗级数展开，就有如下求留数的规则： 规则1 若\\(z_0\\)为\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}\\left[ f(z),z \\right]=\\lim_{z\\to z_0}(z-z_0)f(z)\\] 很好理解，要求\\(c_{-1}(z-z_0)^{-1}\\)中的\\(c_{-1}\\)，只要把\\(f(z)\\)乘上\\((z-z_0)\\)，函数在\\(z_0\\)的值就是\\(c_{-1}\\)，为了防止函数里的项无意义，所以求极限。 规则2 \\(z_0\\)为\\(f(z)\\)的\\(m\\)级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}\\left[ (z-z_0)^m f(z) \\right]}{\\mathrm{d}z^{m-1}} \\] 和规则1的理解方式一样，由于是\\(m\\)级极点，说明说\\((z-z_0)^m\\)前面的点都是不解析的， \\((z-z_0)^mf(z)=\\dots+c_{-m}+c_{-m+1}(z-z_0)+\\dots+c_{-1}(z-z_0)^{m-1}\\)，对\\((z-z_0)\\)求\\(m-1\\)阶导得到\\(\\dots+(m-1)!\\cdot c_{-1}+\\dots\\)，最后除以\\((m-1)!\\)得到\\(c_1\\)。 规则3 若\\(f(z)=\\frac{P(z)}{Q(z)}\\)，\\(z_0\\)是\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{P(z)}{Q^\\prime(z_0)}\\] 有些函数用奇点代入规则1或规则2出现极限不存在（往往是分母不是\\((z-z_0)^n\\)这种形式），可以用规则3，感觉有点像洛必达法则。 规则4 \\[\\operatorname{Res}[f(z),\\infty]=-\\operatorname{Res}\\left[f\\left( \\frac{1}{z} \\right) \\cdot \\frac{1}{z^2},0\\right]\\] 相当于将规则2的\\(z\\)用\\(\\frac{1}{z}\\)代换，原函数乘上\\(\\frac{\\mathrm{d}\\frac{1}{z}}{\\mathrm{d}z}=-\\frac{1}{z^2}\\)。 求积分 留数可用于求积分，对于\\(z_k\\)是在\\(c\\)内部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_k \\right]\\] 对于\\(z_i\\)是在\\(c\\)外部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=-2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]\\] \\(f(z)\\)的在\\(c\\)上的积分，就是求\\(f(z)\\)在\\(c\\)内部所有奇点的留数之和。用留数求积分可以推导出高阶导数公式，因为只要\\((z-z_0)^n\\)在分母上，那么\\(z_0\\)必为\\(n\\)级奇点，根据规则2，即可推出高阶导数公式。 由于是奇点，所以有虚数单位\\(i\\)，是环路积分，所以有\\(2\\pi\\)。 对于以下几种用实数无法求出的积分，可以用留数来求： 对于三角函数的积分 \\[\\int_{0}^{2 \\pi} R(\\cos \\theta, \\sin \\theta) d \\theta, \\quad d \\theta=\\frac{d z}{i z}\\] 令\\(\\left\\{\\begin{array}{l}\\sin \\theta=\\frac{z-z^{-1}}{2 i} \\\\ \\cos \\theta=\\frac{z+z^{-1}}{2}\\end{array} \\Rightarrow \\oint_{|z|=1} f(z) d z\\right.\\) 就是把三角函数用上面的含\\(z\\)表达式代换，对\\(\\mathrm{d}\\theta\\)也进行代换，然后把积分号换成环路积分。变成环路积分就可以用留数来求了。 其实就是三角函数的变式（\\(e^{\\pm iz}\\rightarrow (z=e^{iz})^{\\pm 1}\\)），少了的\\(iz\\)要在\\(\\mathrm{d}\\theta\\)上补回来。 无穷积分（分上下限为正负无穷） \\[\\int_{-\\infty}^{+\\infty} R(x) d x=2 \\pi i \\sum \\operatorname{Res}\\left[R(z), z_{k}\\right]\\] 其中\\(z_{k}\\) 为\\(R(z)\\)在上半平面内的奇点。 含\\(e^{aix}\\)的无穷积分、三角函数积分 \\[\\begin{aligned} \u0026\\int_{-\\infty}^{+ \\infty} R(x) e^{a i x} d x \\\\ =\u00262 \\pi i \\sum \\operatorname{Res}\\left[R(z) e^{a i z}, z_{k}\\right] \\\\ =\u0026\\int_{-\\infty}^{+ \\infty} R(x) \\cos a x d x+i \\int_{-\\infty}^{+ \\infty} R(x) \\sin a x d x \\end{aligned}\\] 可以看作就是方法2的推广（\\(a=0\\)代入）。最后一个等号是把\\(e^{aix}\\)看作复数的指数表示，然后化为复数的三角表示，这两个项可以单独出现在题目中的，如果单独出现，也可以向前变换成复数的指数表示。 与留数求积分的特例： 环路积分变成反常积分 \\(f(x)\\)变成\\(R(x)e^{aix}\\) 傅里叶级数 \\[f(t)=\\dots+c_{-2}e^{-2 it}+c_{-1}e^{- it}+c_0+c_1e^{ it}+c_2e^{2 it}+\\dots=\\sum_{\\omega=-\\infty}^{+\\infty}c_\\omega e^{\\omega it}\\] 其中\\(f(t)\\)是一个复","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:5","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#留数"},{"categories":null,"content":"级数 调和级数 \\[\\sum\\limits_{n=1}^\\infty \\frac{1}{n}\\] 泰勒级数 幂级数 和函数 幂级数展开式/泰勒展开式 收敛域 \\(\\frac{1}{1-z}\\) \\(\\sum\\limits_{n=0}^{\\infty} z^{n}=1+z+z^{2}+\\ldots \\ldots+z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(\\frac{1}{1+z}\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} z^{n}=1-z+z^{2}+\\ldots \\ldots+(-1)^{n} z^{n}\\) \\(\\vert z\\vert \u003c1\\) \\(e^{z}\\) \\(\\sum\\limits_{n=0}^{\\infty} \\frac{1}{n !} z^{n}=1+z+\\frac{z^{2}}{2 !}+\\ldots \\ldots+\\frac{z^{n}}{n !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\sin z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}=z-\\frac{z^{3}}{3 !}+\\frac{z^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{z^{2 n+1}}{(2 n+1) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) \\(\\cos z\\) \\(\\sum\\limits_{n=0}^{\\infty}(-1)^{n} \\frac{z^{2 n}}{(2 n) !}=1-\\frac{z^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{z^{2 n}}{(2 n) !}\\) \\(0\u003c\\vert z\\vert \u003c+\\infty\\) 注意，\\(n\\)都是从\\(0\\)开始的。收敛域的意义就是在某个条件下，展开式收敛并且等于和函数。在 \\(z=a\\) 处展开为幂级数，就是展开为 \\((z-a)^n\\) 形式。 \\(z\\)的负号守恒（要么在前，要么在后） 第二个式子就是把\\(-z\\)代入第一个式子 收敛域为无穷时必须有分母牵制 有\\(-1\\)才有奇偶数之分 正弦是奇函数，也是奇数\\(2n+1\\) 余弦是偶函数，也是偶数\\(2n\\) 洛朗级数 可以看作是泰勒级数的推广。对于泰勒级数，幂的次数都是大于或等于0的，方法同幂级数，下限为\\(n=-\\infty\\)。 留数 若\\(f(z)=\\sum\\limits_{n=-\\infty}^{+\\infty}c_n(z-z_0)^n\\)，则\\(\\operatorname{Res}\\left[ f(z),z_0 \\right]=c_{-1}\\)，也就是\\((z-z_0)\\)展开式中\\((z-z_0)^{-1}\\)项的系数。如果展开式不含\\((z-z_0)^{-1}\\)，则留数为\\(0\\)（如\\(\\operatorname{Res}[\\cos z, 0]=0\\)） 性质 \\[\\sum_{i=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]=0\\] 其中\\(z_i\\)为所有奇点并且包括无穷点。 规则 很多函数没法轻松地使用洛朗级数展开，就有如下求留数的规则： 规则1 若\\(z_0\\)为\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}\\left[ f(z),z \\right]=\\lim_{z\\to z_0}(z-z_0)f(z)\\] 很好理解，要求\\(c_{-1}(z-z_0)^{-1}\\)中的\\(c_{-1}\\)，只要把\\(f(z)\\)乘上\\((z-z_0)\\)，函数在\\(z_0\\)的值就是\\(c_{-1}\\)，为了防止函数里的项无意义，所以求极限。 规则2 \\(z_0\\)为\\(f(z)\\)的\\(m\\)级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}\\left[ (z-z_0)^m f(z) \\right]}{\\mathrm{d}z^{m-1}} \\] 和规则1的理解方式一样，由于是\\(m\\)级极点，说明说\\((z-z_0)^m\\)前面的点都是不解析的， \\((z-z_0)^mf(z)=\\dots+c_{-m}+c_{-m+1}(z-z_0)+\\dots+c_{-1}(z-z_0)^{m-1}\\)，对\\((z-z_0)\\)求\\(m-1\\)阶导得到\\(\\dots+(m-1)!\\cdot c_{-1}+\\dots\\)，最后除以\\((m-1)!\\)得到\\(c_1\\)。 规则3 若\\(f(z)=\\frac{P(z)}{Q(z)}\\)，\\(z_0\\)是\\(f(z)\\)的一级极点，则： \\[\\operatorname{Res}[f(z),z_0]=\\frac{P(z)}{Q^\\prime(z_0)}\\] 有些函数用奇点代入规则1或规则2出现极限不存在（往往是分母不是\\((z-z_0)^n\\)这种形式），可以用规则3，感觉有点像洛必达法则。 规则4 \\[\\operatorname{Res}[f(z),\\infty]=-\\operatorname{Res}\\left[f\\left( \\frac{1}{z} \\right) \\cdot \\frac{1}{z^2},0\\right]\\] 相当于将规则2的\\(z\\)用\\(\\frac{1}{z}\\)代换，原函数乘上\\(\\frac{\\mathrm{d}\\frac{1}{z}}{\\mathrm{d}z}=-\\frac{1}{z^2}\\)。 求积分 留数可用于求积分，对于\\(z_k\\)是在\\(c\\)内部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_k \\right]\\] 对于\\(z_i\\)是在\\(c\\)外部的奇点： \\[\\oint_c f(z)\\mathrm{d}z=-2\\pi i\\sum\\limits_{k=1}^n\\operatorname{Res}\\left[ f(z),z_i \\right]\\] \\(f(z)\\)的在\\(c\\)上的积分，就是求\\(f(z)\\)在\\(c\\)内部所有奇点的留数之和。用留数求积分可以推导出高阶导数公式，因为只要\\((z-z_0)^n\\)在分母上，那么\\(z_0\\)必为\\(n\\)级奇点，根据规则2，即可推出高阶导数公式。 由于是奇点，所以有虚数单位\\(i\\)，是环路积分，所以有\\(2\\pi\\)。 对于以下几种用实数无法求出的积分，可以用留数来求： 对于三角函数的积分 \\[\\int_{0}^{2 \\pi} R(\\cos \\theta, \\sin \\theta) d \\theta, \\quad d \\theta=\\frac{d z}{i z}\\] 令\\(\\left\\{\\begin{array}{l}\\sin \\theta=\\frac{z-z^{-1}}{2 i} \\\\ \\cos \\theta=\\frac{z+z^{-1}}{2}\\end{array} \\Rightarrow \\oint_{|z|=1} f(z) d z\\right.\\) 就是把三角函数用上面的含\\(z\\)表达式代换，对\\(\\mathrm{d}\\theta\\)也进行代换，然后把积分号换成环路积分。变成环路积分就可以用留数来求了。 其实就是三角函数的变式（\\(e^{\\pm iz}\\rightarrow (z=e^{iz})^{\\pm 1}\\)），少了的\\(iz\\)要在\\(\\mathrm{d}\\theta\\)上补回来。 无穷积分（分上下限为正负无穷） \\[\\int_{-\\infty}^{+\\infty} R(x) d x=2 \\pi i \\sum \\operatorname{Res}\\left[R(z), z_{k}\\right]\\] 其中\\(z_{k}\\) 为\\(R(z)\\)在上半平面内的奇点。 含\\(e^{aix}\\)的无穷积分、三角函数积分 \\[\\begin{aligned} \u0026\\int_{-\\infty}^{+ \\infty} R(x) e^{a i x} d x \\\\ =\u00262 \\pi i \\sum \\operatorname{Res}\\left[R(z) e^{a i z}, z_{k}\\right] \\\\ =\u0026\\int_{-\\infty}^{+ \\infty} R(x) \\cos a x d x+i \\int_{-\\infty}^{+ \\infty} R(x) \\sin a x d x \\end{aligned}\\] 可以看作就是方法2的推广（\\(a=0\\)代入）。最后一个等号是把\\(e^{aix}\\)看作复数的指数表示，然后化为复数的三角表示，这两个项可以单独出现在题目中的，如果单独出现，也可以向前变换成复数的指数表示。 与留数求积分的特例： 环路积分变成反常积分 \\(f(x)\\)变成\\(R(x)e^{aix}\\) 傅里叶级数 \\[f(t)=\\dots+c_{-2}e^{-2 it}+c_{-1}e^{- it}+c_0+c_1e^{ it}+c_2e^{2 it}+\\dots=\\sum_{\\omega=-\\infty}^{+\\infty}c_\\omega e^{\\omega it}\\] 其中\\(f(t)\\)是一个复","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:5","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#傅里叶级数"},{"categories":null,"content":"积分 柯西-古萨基本定理 如果\\(f(z)\\)在曲线\\(c\\)围成的区域内处处解析（没有奇点），则： \\[\\oint_cf(z)\\mathrm{d}z=0\\] 又叫柯西积分定理。 柯西积分公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f(z_0)=\\frac{1}{2\\pi i}\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z\\] 如果柯西积分定理的条件不满足（分母为\\(0\\)导致不解析，但是对于分子解析），可以使用柯西积分公式计算，进行变换得： \\[\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z=2\\pi i f(z_0)\\] 让积分号内部的式子与要积分的式子相同，即可凑出\\(f(z)\\)和\\(z_0\\)，那么等式右边就是个确定的值，即可求出积分。 可以得到，分母在\\(z_0\\)处为\\(0\\)，而\\(f(z)\\)在\\(z_0\\)处不为\\(0\\)，因此右边就用\\(f(z_0)\\)来算，\\(\\frac{f(z)}{z-z_0}\\)这个“解析函数”是虚的，因此要乘上\\(i\\)，去心邻域是圆的，因此要乘上\\(2\\pi\\)。 高阶导数公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f^{(n)}(z_0)=\\frac{n!}{2\\pi i}\\oint \\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm{d}z\\] 作变换可用于求分母为\\(n\\)次方的环路积分： \\[\\oint \\frac{f(z)}{(z-z_0)^{n}}\\mathrm{d}z=\\frac{2\\pi i}{(n-1)!}\\cdot f^{(n-1)}(z_0)\\] 可以看作是柯西积分公式的推广。 从柯西积分公式推导过来记，当\\(n=0\\)时，\\(0! = 1\\)，就是柯西积分公式。或者从留数求积分的方法来推出。 积分变换 小波变换 傅里叶变换无法很好的分析不平稳的信号（频率随着时间变化的信号），即缺乏频率在时间上的信息（什么时候出现什么样的频率）： 而小波变换更换了傅里叶变换的无限长三角函数（\\(e^{j\\omega t}\\)）的作为基，换成了幅值随时间衰减的小波（\\(\\psi\\left(\\frac{t-\\tau}{a}\\right)\\)）作为基： \\[W T(a, \\tau)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{\\infty} f(t) * \\psi\\left(\\frac{t-\\tau}{a}\\right) \\mathrm{d} t\\] 不同于变量只有频率的傅里叶变换，小波变换有两个变量： 尺度（scale）\\(a\\)：控制小波函数在时间轴方向上的伸缩，对应于频率（反比）。 平移量（translation）\\(\\tau\\)：控制小波函数的平移，对应于时刻。 因此小波变换让除突变处的小波系数为\\(0\\)，即可克服吉布斯现象： 不同于傅里叶变换得到频谱，小波变换得到时频谱。 傅里叶变换 傅里叶变换\\(\\mathcal{F}\\)，实现时域到频域的变换： \\[F(\\omega)=\\int_{-\\infty}^{+ \\infty} f(t) e^{-j \\omega t} \\mathrm{d} t=\\mathcal{F}[f(t)]\\] \\(F(\\omega)\\)：傅里叶级数展开式中，频率\\(\\omega\\)的项对应的系数。 \\(f(t)e^{-j\\omega t}\\)：即\\(\\frac{f(t)}{e^{j\\omega t}}\\) 很好地体现出了\\(F(\\omega)\\)作为系数意义 —— 信号变量（复平面上的图形）与三角函数（复平面上转动的点）的相关性： \\(e^{j\\omega t}=\\left( i\\sin\\omega t+\\cos\\omega t\\right)\\) 表示时间为\\(t\\)时，复平面上的一个点。 \\(\\int_{-\\infty}^{+\\infty}\\)：所有的函数值，都对某个频率\\(\\omega\\)作出贡献。 傅里叶变换与傅里叶级数有以下区别： 傅立叶级数对应的是周期信号，而傅立叶变换则对应的是一个时间连续可积信号（不一定是周期信号）。 傅立叶级数要求信号在一个周期内能量有限，而后者则要求在整个区间能量有限。 傅立叶级数的对应\\(\\omega\\)是离散的，而傅立叶变换则对应\\(\\omega\\)是连续的。 傅里叶逆变换\\(\\mathcal{F}^{-1}\\)： \\[f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+ \\infty} F(\\omega) e^{j \\omega t} d t=\\mathcal{F}^{-1}[F(\\omega)]\\] 傅立叶变换和逆变换中的变量分别是\\(\\omega\\)和\\(t\\)，积分变量分别是\\(t\\)和\\(\\omega\\)。复数中的虚数单位\\(i\\)在积分中写成\\(j\\)。 变换对 常见的傅里叶变换对： 指数函数 \\(e^{-\\beta t}(t \\geq 0, \\beta\u003e0) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{1}{\\beta+j \\omega}\\)（即\\(e\\)的次数为实数） \\(e^{-j \\omega_0 t} \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega+\\omega_0)\\)（即\\(e\\)的次数为纯虚数） \\(1 \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega)\\) 单位脉冲函数 \\(\\delta(t+t_0) \\stackrel{\\mathcal{F}}{\\longrightarrow} e^{-j \\omega t_0}\\) \\(\\delta(t) \\stackrel{\\mathcal{F}}{\\longrightarrow} 1\\) \\(E(|t| \\leq \\tau) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{2 E}{\\omega} \\sin \\tau \\omega\\) 其中\\(E\\)在\\(\\left| t \\right|\\leq \\tau\\)时值为\\(E\\)，否则为\\(0\\)。 三角函数 \\(\\sin \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} j \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)-\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) \\(\\cos \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)+\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) 性质 由于傅立叶变换要求函数与\\(e^{-j\\omega t}\\)相乘的积分，如果函数不干净，就不好进行积分，或者可以直接用变换对，但是函数不干净，这时可以利用性质把函数弄干净。 平移（重点） \\(\\mathcal{F}\\left[f\\left(t+t_{0}\\right)\\right]=e^{j \\omega t_{0}} \\mathcal{F}[f(t)]\\) 频率为\\(\\omega\\)分量（傅里叶级数中的项）的平移体现在对应频率项的相移上。最简单的例子就是正弦函数，其平移可以直接表示成相移。 \\(\\mathcal{F}\\left[e^{j \\omega_{0} t} f(t)\\right]=F\\left(\\omega-\\omega_{0}\\right)\\)（与\\(e^{j \\omega_{0} t}\\)相乘） \\(e^{j\\omega_0 t}\\)看作是复平面上绕坐标原点旋转的复数，模长为\\(1\\)，可以看作就是个旋转的单位向量。乘上它后，\\(f(t)\\)中所有分量的频率都会增加\\(\\omega\\)，体现为频域上的平移（左加右减）。 求导 \\(\\mathcal{F}\\left[f^{\\prime}(t)\\right]=j \\omega \\mathcal{F}[f(t)]\\) 对函数求导后，频率\\(\\omega\\)的分量的项相移\\(90^\\circ\\)，并且模长变为\\(\\omega\\)倍。最简单的例子就是正弦函数： \\[(\\sin\\omega t)^\\prime=\\omega\\sin(\\omega t+\\frac{\\pi}{2})=\\omega\\cos\\omega t\\] \\(\\mathcal{F}[t f(t)]=-\\frac{d}{d \\omega} \\mathcal{F}[f(t)]=-F^{\\prime}(\\omega)\\)（与\\(t\\)相乘） 变上限积分 \\[\\mathcal{F}\\left[\\int_{-\\infty}^{t} f(t) d t\\right]=\\frac{1}{j \\omega} \\mathcal{F}[f(t)]\\] 对函数积分后，频率\\(\\omega\\)的分量的项相移\\(-90^\\circ\\)，并且模长变为\\(\\frac{1}{\\omega}\\)倍。最简单的例子就是正弦函数： \\(\\int\\sin\\omega t\\mathrm{d","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:6","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#积分"},{"categories":null,"content":"积分 柯西-古萨基本定理 如果\\(f(z)\\)在曲线\\(c\\)围成的区域内处处解析（没有奇点），则： \\[\\oint_cf(z)\\mathrm{d}z=0\\] 又叫柯西积分定理。 柯西积分公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f(z_0)=\\frac{1}{2\\pi i}\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z\\] 如果柯西积分定理的条件不满足（分母为\\(0\\)导致不解析，但是对于分子解析），可以使用柯西积分公式计算，进行变换得： \\[\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z=2\\pi i f(z_0)\\] 让积分号内部的式子与要积分的式子相同，即可凑出\\(f(z)\\)和\\(z_0\\)，那么等式右边就是个确定的值，即可求出积分。 可以得到，分母在\\(z_0\\)处为\\(0\\)，而\\(f(z)\\)在\\(z_0\\)处不为\\(0\\)，因此右边就用\\(f(z_0)\\)来算，\\(\\frac{f(z)}{z-z_0}\\)这个“解析函数”是虚的，因此要乘上\\(i\\)，去心邻域是圆的，因此要乘上\\(2\\pi\\)。 高阶导数公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f^{(n)}(z_0)=\\frac{n!}{2\\pi i}\\oint \\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm{d}z\\] 作变换可用于求分母为\\(n\\)次方的环路积分： \\[\\oint \\frac{f(z)}{(z-z_0)^{n}}\\mathrm{d}z=\\frac{2\\pi i}{(n-1)!}\\cdot f^{(n-1)}(z_0)\\] 可以看作是柯西积分公式的推广。 从柯西积分公式推导过来记，当\\(n=0\\)时，\\(0! = 1\\)，就是柯西积分公式。或者从留数求积分的方法来推出。 积分变换 小波变换 傅里叶变换无法很好的分析不平稳的信号（频率随着时间变化的信号），即缺乏频率在时间上的信息（什么时候出现什么样的频率）： 而小波变换更换了傅里叶变换的无限长三角函数（\\(e^{j\\omega t}\\)）的作为基，换成了幅值随时间衰减的小波（\\(\\psi\\left(\\frac{t-\\tau}{a}\\right)\\)）作为基： \\[W T(a, \\tau)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{\\infty} f(t) * \\psi\\left(\\frac{t-\\tau}{a}\\right) \\mathrm{d} t\\] 不同于变量只有频率的傅里叶变换，小波变换有两个变量： 尺度（scale）\\(a\\)：控制小波函数在时间轴方向上的伸缩，对应于频率（反比）。 平移量（translation）\\(\\tau\\)：控制小波函数的平移，对应于时刻。 因此小波变换让除突变处的小波系数为\\(0\\)，即可克服吉布斯现象： 不同于傅里叶变换得到频谱，小波变换得到时频谱。 傅里叶变换 傅里叶变换\\(\\mathcal{F}\\)，实现时域到频域的变换： \\[F(\\omega)=\\int_{-\\infty}^{+ \\infty} f(t) e^{-j \\omega t} \\mathrm{d} t=\\mathcal{F}[f(t)]\\] \\(F(\\omega)\\)：傅里叶级数展开式中，频率\\(\\omega\\)的项对应的系数。 \\(f(t)e^{-j\\omega t}\\)：即\\(\\frac{f(t)}{e^{j\\omega t}}\\) 很好地体现出了\\(F(\\omega)\\)作为系数意义 —— 信号变量（复平面上的图形）与三角函数（复平面上转动的点）的相关性： \\(e^{j\\omega t}=\\left( i\\sin\\omega t+\\cos\\omega t\\right)\\) 表示时间为\\(t\\)时，复平面上的一个点。 \\(\\int_{-\\infty}^{+\\infty}\\)：所有的函数值，都对某个频率\\(\\omega\\)作出贡献。 傅里叶变换与傅里叶级数有以下区别： 傅立叶级数对应的是周期信号，而傅立叶变换则对应的是一个时间连续可积信号（不一定是周期信号）。 傅立叶级数要求信号在一个周期内能量有限，而后者则要求在整个区间能量有限。 傅立叶级数的对应\\(\\omega\\)是离散的，而傅立叶变换则对应\\(\\omega\\)是连续的。 傅里叶逆变换\\(\\mathcal{F}^{-1}\\)： \\[f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+ \\infty} F(\\omega) e^{j \\omega t} d t=\\mathcal{F}^{-1}[F(\\omega)]\\] 傅立叶变换和逆变换中的变量分别是\\(\\omega\\)和\\(t\\)，积分变量分别是\\(t\\)和\\(\\omega\\)。复数中的虚数单位\\(i\\)在积分中写成\\(j\\)。 变换对 常见的傅里叶变换对： 指数函数 \\(e^{-\\beta t}(t \\geq 0, \\beta\u003e0) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{1}{\\beta+j \\omega}\\)（即\\(e\\)的次数为实数） \\(e^{-j \\omega_0 t} \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega+\\omega_0)\\)（即\\(e\\)的次数为纯虚数） \\(1 \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega)\\) 单位脉冲函数 \\(\\delta(t+t_0) \\stackrel{\\mathcal{F}}{\\longrightarrow} e^{-j \\omega t_0}\\) \\(\\delta(t) \\stackrel{\\mathcal{F}}{\\longrightarrow} 1\\) \\(E(|t| \\leq \\tau) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{2 E}{\\omega} \\sin \\tau \\omega\\) 其中\\(E\\)在\\(\\left| t \\right|\\leq \\tau\\)时值为\\(E\\)，否则为\\(0\\)。 三角函数 \\(\\sin \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} j \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)-\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) \\(\\cos \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)+\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) 性质 由于傅立叶变换要求函数与\\(e^{-j\\omega t}\\)相乘的积分，如果函数不干净，就不好进行积分，或者可以直接用变换对，但是函数不干净，这时可以利用性质把函数弄干净。 平移（重点） \\(\\mathcal{F}\\left[f\\left(t+t_{0}\\right)\\right]=e^{j \\omega t_{0}} \\mathcal{F}[f(t)]\\) 频率为\\(\\omega\\)分量（傅里叶级数中的项）的平移体现在对应频率项的相移上。最简单的例子就是正弦函数，其平移可以直接表示成相移。 \\(\\mathcal{F}\\left[e^{j \\omega_{0} t} f(t)\\right]=F\\left(\\omega-\\omega_{0}\\right)\\)（与\\(e^{j \\omega_{0} t}\\)相乘） \\(e^{j\\omega_0 t}\\)看作是复平面上绕坐标原点旋转的复数，模长为\\(1\\)，可以看作就是个旋转的单位向量。乘上它后，\\(f(t)\\)中所有分量的频率都会增加\\(\\omega\\)，体现为频域上的平移（左加右减）。 求导 \\(\\mathcal{F}\\left[f^{\\prime}(t)\\right]=j \\omega \\mathcal{F}[f(t)]\\) 对函数求导后，频率\\(\\omega\\)的分量的项相移\\(90^\\circ\\)，并且模长变为\\(\\omega\\)倍。最简单的例子就是正弦函数： \\[(\\sin\\omega t)^\\prime=\\omega\\sin(\\omega t+\\frac{\\pi}{2})=\\omega\\cos\\omega t\\] \\(\\mathcal{F}[t f(t)]=-\\frac{d}{d \\omega} \\mathcal{F}[f(t)]=-F^{\\prime}(\\omega)\\)（与\\(t\\)相乘） 变上限积分 \\[\\mathcal{F}\\left[\\int_{-\\infty}^{t} f(t) d t\\right]=\\frac{1}{j \\omega} \\mathcal{F}[f(t)]\\] 对函数积分后，频率\\(\\omega\\)的分量的项相移\\(-90^\\circ\\)，并且模长变为\\(\\frac{1}{\\omega}\\)倍。最简单的例子就是正弦函数： \\(\\int\\sin\\omega t\\mathrm{d","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:6","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#柯西-古萨基本定理"},{"categories":null,"content":"积分 柯西-古萨基本定理 如果\\(f(z)\\)在曲线\\(c\\)围成的区域内处处解析（没有奇点），则： \\[\\oint_cf(z)\\mathrm{d}z=0\\] 又叫柯西积分定理。 柯西积分公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f(z_0)=\\frac{1}{2\\pi i}\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z\\] 如果柯西积分定理的条件不满足（分母为\\(0\\)导致不解析，但是对于分子解析），可以使用柯西积分公式计算，进行变换得： \\[\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z=2\\pi i f(z_0)\\] 让积分号内部的式子与要积分的式子相同，即可凑出\\(f(z)\\)和\\(z_0\\)，那么等式右边就是个确定的值，即可求出积分。 可以得到，分母在\\(z_0\\)处为\\(0\\)，而\\(f(z)\\)在\\(z_0\\)处不为\\(0\\)，因此右边就用\\(f(z_0)\\)来算，\\(\\frac{f(z)}{z-z_0}\\)这个“解析函数”是虚的，因此要乘上\\(i\\)，去心邻域是圆的，因此要乘上\\(2\\pi\\)。 高阶导数公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f^{(n)}(z_0)=\\frac{n!}{2\\pi i}\\oint \\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm{d}z\\] 作变换可用于求分母为\\(n\\)次方的环路积分： \\[\\oint \\frac{f(z)}{(z-z_0)^{n}}\\mathrm{d}z=\\frac{2\\pi i}{(n-1)!}\\cdot f^{(n-1)}(z_0)\\] 可以看作是柯西积分公式的推广。 从柯西积分公式推导过来记，当\\(n=0\\)时，\\(0! = 1\\)，就是柯西积分公式。或者从留数求积分的方法来推出。 积分变换 小波变换 傅里叶变换无法很好的分析不平稳的信号（频率随着时间变化的信号），即缺乏频率在时间上的信息（什么时候出现什么样的频率）： 而小波变换更换了傅里叶变换的无限长三角函数（\\(e^{j\\omega t}\\)）的作为基，换成了幅值随时间衰减的小波（\\(\\psi\\left(\\frac{t-\\tau}{a}\\right)\\)）作为基： \\[W T(a, \\tau)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{\\infty} f(t) * \\psi\\left(\\frac{t-\\tau}{a}\\right) \\mathrm{d} t\\] 不同于变量只有频率的傅里叶变换，小波变换有两个变量： 尺度（scale）\\(a\\)：控制小波函数在时间轴方向上的伸缩，对应于频率（反比）。 平移量（translation）\\(\\tau\\)：控制小波函数的平移，对应于时刻。 因此小波变换让除突变处的小波系数为\\(0\\)，即可克服吉布斯现象： 不同于傅里叶变换得到频谱，小波变换得到时频谱。 傅里叶变换 傅里叶变换\\(\\mathcal{F}\\)，实现时域到频域的变换： \\[F(\\omega)=\\int_{-\\infty}^{+ \\infty} f(t) e^{-j \\omega t} \\mathrm{d} t=\\mathcal{F}[f(t)]\\] \\(F(\\omega)\\)：傅里叶级数展开式中，频率\\(\\omega\\)的项对应的系数。 \\(f(t)e^{-j\\omega t}\\)：即\\(\\frac{f(t)}{e^{j\\omega t}}\\) 很好地体现出了\\(F(\\omega)\\)作为系数意义 —— 信号变量（复平面上的图形）与三角函数（复平面上转动的点）的相关性： \\(e^{j\\omega t}=\\left( i\\sin\\omega t+\\cos\\omega t\\right)\\) 表示时间为\\(t\\)时，复平面上的一个点。 \\(\\int_{-\\infty}^{+\\infty}\\)：所有的函数值，都对某个频率\\(\\omega\\)作出贡献。 傅里叶变换与傅里叶级数有以下区别： 傅立叶级数对应的是周期信号，而傅立叶变换则对应的是一个时间连续可积信号（不一定是周期信号）。 傅立叶级数要求信号在一个周期内能量有限，而后者则要求在整个区间能量有限。 傅立叶级数的对应\\(\\omega\\)是离散的，而傅立叶变换则对应\\(\\omega\\)是连续的。 傅里叶逆变换\\(\\mathcal{F}^{-1}\\)： \\[f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+ \\infty} F(\\omega) e^{j \\omega t} d t=\\mathcal{F}^{-1}[F(\\omega)]\\] 傅立叶变换和逆变换中的变量分别是\\(\\omega\\)和\\(t\\)，积分变量分别是\\(t\\)和\\(\\omega\\)。复数中的虚数单位\\(i\\)在积分中写成\\(j\\)。 变换对 常见的傅里叶变换对： 指数函数 \\(e^{-\\beta t}(t \\geq 0, \\beta\u003e0) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{1}{\\beta+j \\omega}\\)（即\\(e\\)的次数为实数） \\(e^{-j \\omega_0 t} \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega+\\omega_0)\\)（即\\(e\\)的次数为纯虚数） \\(1 \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega)\\) 单位脉冲函数 \\(\\delta(t+t_0) \\stackrel{\\mathcal{F}}{\\longrightarrow} e^{-j \\omega t_0}\\) \\(\\delta(t) \\stackrel{\\mathcal{F}}{\\longrightarrow} 1\\) \\(E(|t| \\leq \\tau) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{2 E}{\\omega} \\sin \\tau \\omega\\) 其中\\(E\\)在\\(\\left| t \\right|\\leq \\tau\\)时值为\\(E\\)，否则为\\(0\\)。 三角函数 \\(\\sin \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} j \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)-\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) \\(\\cos \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)+\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) 性质 由于傅立叶变换要求函数与\\(e^{-j\\omega t}\\)相乘的积分，如果函数不干净，就不好进行积分，或者可以直接用变换对，但是函数不干净，这时可以利用性质把函数弄干净。 平移（重点） \\(\\mathcal{F}\\left[f\\left(t+t_{0}\\right)\\right]=e^{j \\omega t_{0}} \\mathcal{F}[f(t)]\\) 频率为\\(\\omega\\)分量（傅里叶级数中的项）的平移体现在对应频率项的相移上。最简单的例子就是正弦函数，其平移可以直接表示成相移。 \\(\\mathcal{F}\\left[e^{j \\omega_{0} t} f(t)\\right]=F\\left(\\omega-\\omega_{0}\\right)\\)（与\\(e^{j \\omega_{0} t}\\)相乘） \\(e^{j\\omega_0 t}\\)看作是复平面上绕坐标原点旋转的复数，模长为\\(1\\)，可以看作就是个旋转的单位向量。乘上它后，\\(f(t)\\)中所有分量的频率都会增加\\(\\omega\\)，体现为频域上的平移（左加右减）。 求导 \\(\\mathcal{F}\\left[f^{\\prime}(t)\\right]=j \\omega \\mathcal{F}[f(t)]\\) 对函数求导后，频率\\(\\omega\\)的分量的项相移\\(90^\\circ\\)，并且模长变为\\(\\omega\\)倍。最简单的例子就是正弦函数： \\[(\\sin\\omega t)^\\prime=\\omega\\sin(\\omega t+\\frac{\\pi}{2})=\\omega\\cos\\omega t\\] \\(\\mathcal{F}[t f(t)]=-\\frac{d}{d \\omega} \\mathcal{F}[f(t)]=-F^{\\prime}(\\omega)\\)（与\\(t\\)相乘） 变上限积分 \\[\\mathcal{F}\\left[\\int_{-\\infty}^{t} f(t) d t\\right]=\\frac{1}{j \\omega} \\mathcal{F}[f(t)]\\] 对函数积分后，频率\\(\\omega\\)的分量的项相移\\(-90^\\circ\\)，并且模长变为\\(\\frac{1}{\\omega}\\)倍。最简单的例子就是正弦函数： \\(\\int\\sin\\omega t\\mathrm{d","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:6","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#柯西积分公式"},{"categories":null,"content":"积分 柯西-古萨基本定理 如果\\(f(z)\\)在曲线\\(c\\)围成的区域内处处解析（没有奇点），则： \\[\\oint_cf(z)\\mathrm{d}z=0\\] 又叫柯西积分定理。 柯西积分公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f(z_0)=\\frac{1}{2\\pi i}\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z\\] 如果柯西积分定理的条件不满足（分母为\\(0\\)导致不解析，但是对于分子解析），可以使用柯西积分公式计算，进行变换得： \\[\\oint_c \\frac{f(z)}{z-z_0}\\mathrm{d}z=2\\pi i f(z_0)\\] 让积分号内部的式子与要积分的式子相同，即可凑出\\(f(z)\\)和\\(z_0\\)，那么等式右边就是个确定的值，即可求出积分。 可以得到，分母在\\(z_0\\)处为\\(0\\)，而\\(f(z)\\)在\\(z_0\\)处不为\\(0\\)，因此右边就用\\(f(z_0)\\)来算，\\(\\frac{f(z)}{z-z_0}\\)这个“解析函数”是虚的，因此要乘上\\(i\\)，去心邻域是圆的，因此要乘上\\(2\\pi\\)。 高阶导数公式 若\\(f(z)\\)在曲线\\(c\\)内部解析，\\(z_0\\)在\\(c\\)内部，则： \\[f^{(n)}(z_0)=\\frac{n!}{2\\pi i}\\oint \\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm{d}z\\] 作变换可用于求分母为\\(n\\)次方的环路积分： \\[\\oint \\frac{f(z)}{(z-z_0)^{n}}\\mathrm{d}z=\\frac{2\\pi i}{(n-1)!}\\cdot f^{(n-1)}(z_0)\\] 可以看作是柯西积分公式的推广。 从柯西积分公式推导过来记，当\\(n=0\\)时，\\(0! = 1\\)，就是柯西积分公式。或者从留数求积分的方法来推出。 积分变换 小波变换 傅里叶变换无法很好的分析不平稳的信号（频率随着时间变化的信号），即缺乏频率在时间上的信息（什么时候出现什么样的频率）： 而小波变换更换了傅里叶变换的无限长三角函数（\\(e^{j\\omega t}\\)）的作为基，换成了幅值随时间衰减的小波（\\(\\psi\\left(\\frac{t-\\tau}{a}\\right)\\)）作为基： \\[W T(a, \\tau)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{\\infty} f(t) * \\psi\\left(\\frac{t-\\tau}{a}\\right) \\mathrm{d} t\\] 不同于变量只有频率的傅里叶变换，小波变换有两个变量： 尺度（scale）\\(a\\)：控制小波函数在时间轴方向上的伸缩，对应于频率（反比）。 平移量（translation）\\(\\tau\\)：控制小波函数的平移，对应于时刻。 因此小波变换让除突变处的小波系数为\\(0\\)，即可克服吉布斯现象： 不同于傅里叶变换得到频谱，小波变换得到时频谱。 傅里叶变换 傅里叶变换\\(\\mathcal{F}\\)，实现时域到频域的变换： \\[F(\\omega)=\\int_{-\\infty}^{+ \\infty} f(t) e^{-j \\omega t} \\mathrm{d} t=\\mathcal{F}[f(t)]\\] \\(F(\\omega)\\)：傅里叶级数展开式中，频率\\(\\omega\\)的项对应的系数。 \\(f(t)e^{-j\\omega t}\\)：即\\(\\frac{f(t)}{e^{j\\omega t}}\\) 很好地体现出了\\(F(\\omega)\\)作为系数意义 —— 信号变量（复平面上的图形）与三角函数（复平面上转动的点）的相关性： \\(e^{j\\omega t}=\\left( i\\sin\\omega t+\\cos\\omega t\\right)\\) 表示时间为\\(t\\)时，复平面上的一个点。 \\(\\int_{-\\infty}^{+\\infty}\\)：所有的函数值，都对某个频率\\(\\omega\\)作出贡献。 傅里叶变换与傅里叶级数有以下区别： 傅立叶级数对应的是周期信号，而傅立叶变换则对应的是一个时间连续可积信号（不一定是周期信号）。 傅立叶级数要求信号在一个周期内能量有限，而后者则要求在整个区间能量有限。 傅立叶级数的对应\\(\\omega\\)是离散的，而傅立叶变换则对应\\(\\omega\\)是连续的。 傅里叶逆变换\\(\\mathcal{F}^{-1}\\)： \\[f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+ \\infty} F(\\omega) e^{j \\omega t} d t=\\mathcal{F}^{-1}[F(\\omega)]\\] 傅立叶变换和逆变换中的变量分别是\\(\\omega\\)和\\(t\\)，积分变量分别是\\(t\\)和\\(\\omega\\)。复数中的虚数单位\\(i\\)在积分中写成\\(j\\)。 变换对 常见的傅里叶变换对： 指数函数 \\(e^{-\\beta t}(t \\geq 0, \\beta\u003e0) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{1}{\\beta+j \\omega}\\)（即\\(e\\)的次数为实数） \\(e^{-j \\omega_0 t} \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega+\\omega_0)\\)（即\\(e\\)的次数为纯虚数） \\(1 \\stackrel{\\mathcal{F}}{\\longrightarrow} 2 \\pi \\delta(\\omega)\\) 单位脉冲函数 \\(\\delta(t+t_0) \\stackrel{\\mathcal{F}}{\\longrightarrow} e^{-j \\omega t_0}\\) \\(\\delta(t) \\stackrel{\\mathcal{F}}{\\longrightarrow} 1\\) \\(E(|t| \\leq \\tau) \\stackrel{\\mathcal{F}}{\\longrightarrow} \\frac{2 E}{\\omega} \\sin \\tau \\omega\\) 其中\\(E\\)在\\(\\left| t \\right|\\leq \\tau\\)时值为\\(E\\)，否则为\\(0\\)。 三角函数 \\(\\sin \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} j \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)-\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) \\(\\cos \\omega_{0} t \\stackrel{\\mathcal{F}}{\\longrightarrow} \\pi\\left[\\delta\\left(\\omega+\\omega_{0}\\right)+\\delta\\left(\\omega-\\omega_{0}\\right)\\right]\\) 性质 由于傅立叶变换要求函数与\\(e^{-j\\omega t}\\)相乘的积分，如果函数不干净，就不好进行积分，或者可以直接用变换对，但是函数不干净，这时可以利用性质把函数弄干净。 平移（重点） \\(\\mathcal{F}\\left[f\\left(t+t_{0}\\right)\\right]=e^{j \\omega t_{0}} \\mathcal{F}[f(t)]\\) 频率为\\(\\omega\\)分量（傅里叶级数中的项）的平移体现在对应频率项的相移上。最简单的例子就是正弦函数，其平移可以直接表示成相移。 \\(\\mathcal{F}\\left[e^{j \\omega_{0} t} f(t)\\right]=F\\left(\\omega-\\omega_{0}\\right)\\)（与\\(e^{j \\omega_{0} t}\\)相乘） \\(e^{j\\omega_0 t}\\)看作是复平面上绕坐标原点旋转的复数，模长为\\(1\\)，可以看作就是个旋转的单位向量。乘上它后，\\(f(t)\\)中所有分量的频率都会增加\\(\\omega\\)，体现为频域上的平移（左加右减）。 求导 \\(\\mathcal{F}\\left[f^{\\prime}(t)\\right]=j \\omega \\mathcal{F}[f(t)]\\) 对函数求导后，频率\\(\\omega\\)的分量的项相移\\(90^\\circ\\)，并且模长变为\\(\\omega\\)倍。最简单的例子就是正弦函数： \\[(\\sin\\omega t)^\\prime=\\omega\\sin(\\omega t+\\frac{\\pi}{2})=\\omega\\cos\\omega t\\] \\(\\mathcal{F}[t f(t)]=-\\frac{d}{d \\omega} \\mathcal{F}[f(t)]=-F^{\\prime}(\\omega)\\)（与\\(t\\)相乘） 变上限积分 \\[\\mathcal{F}\\left[\\int_{-\\infty}^{t} f(t) d t\\right]=\\frac{1}{j \\omega} \\mathcal{F}[f(t)]\\] 对函数积分后，频率\\(\\omega\\)的分量的项相移\\(-90^\\circ\\)，并且模长变为\\(\\frac{1}{\\omega}\\)倍。最简单的例子就是正弦函数： \\(\\int\\sin\\omega t\\mathrm{d","date":"2022-03-02","objectID":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/:2:6","series":null,"tags":["数学"],"title":"复变函数与积分变换","uri":"/posts/notes/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2/#积分变换"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:0:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#"},{"categories":null,"content":"函数 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#函数"},{"categories":null,"content":"极限 定义 \\[x\\to x_0 \\Rightarrow \\begin{cases} x \\neq x_0 \\\\ x \\to x_0^+ \\\\ x \\to x_0^- \\\\ \\end{cases}\\] \\[\\lim_{x\\to x_0}f(x)=A\\] 左极限：\\(\\lim_{x\\to x_0^-}f(x)=A\\) 右极限：\\(\\lim_{x\\to x_0^+}f(x)=A\\) 条件 极限存在充要条件： \\[\\lim_{x\\to x_0^-}f(x)=\\lim_{x\\to x_0^+}f(x)\\] 重要极限公式 \\(\\lim_{\\Delta\\to 0}\\frac{\\sin\\Delta}{\\Delta}=1\\) \\(\\lim_{\\Delta\\to\\infty}\\frac{\\sin\\Delta}{\\Delta}=0\\) \\(\\lim_{\\Delta\\to 0}\\left( 1+\\Delta \\right)^{\\frac{1}{\\Delta}}=\\lim_{\\Delta\\to\\infty}\\left( 1+\\frac{1}{\\Delta} \\right)^{\\Delta}=e\\) 无穷小 定义 以 \\(0\\) 为极限的函数称为无穷小。 高阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=0\\] 则\\(\\beta\\)为\\(\\alpha\\)的高阶无穷小。 同阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=k \\left( k\\neq 0 \\right)\\] 则\\(\\beta\\)为\\(\\alpha\\)的同阶无穷小。 等价无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=1\\] 则\\(\\beta\\)为\\(\\alpha\\)的等价无穷小。 代换公式 三角/反三角函数 \\(\\sin x\\sim \\arcsin x\\sim\\tan x\\sim \\arctan x\\sim x\\) 指数/对数 \\(e^x-1\\sim\\ln(x+1)\\sim x\\) 其他 \\(\\left( 1+x \\right)^a-1\\sim ax\\) \\(\\sqrt[n]{1+x}-1\\sim\\frac{x}{n}\\) \\(1-\\cos^a x\\sim\\frac{ax^2}{2}\\) 洛必达法则 若满足以下形式： \\(\\frac{0}{0}\\) 型 \\(\\frac{\\infty}{\\infty}\\) 型 则： \\[\\lim \\frac{f(x)}{g(x)}=\\lim \\frac{f^{\\prime}(x)}{g^{\\prime}(x)}\\] 变式 \\(\\infty-\\infty\\)型：通分 \\(0\\cdot\\infty\\)型：取倒数 \\(1^{\\infty}\\)型：取对数 \\(0^0\\)：取对数 \\(\\infty^0\\)：取对数 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#极限"},{"categories":null,"content":"极限 定义 \\[x\\to x_0 \\Rightarrow \\begin{cases} x \\neq x_0 \\\\ x \\to x_0^+ \\\\ x \\to x_0^- \\\\ \\end{cases}\\] \\[\\lim_{x\\to x_0}f(x)=A\\] 左极限：\\(\\lim_{x\\to x_0^-}f(x)=A\\) 右极限：\\(\\lim_{x\\to x_0^+}f(x)=A\\) 条件 极限存在充要条件： \\[\\lim_{x\\to x_0^-}f(x)=\\lim_{x\\to x_0^+}f(x)\\] 重要极限公式 \\(\\lim_{\\Delta\\to 0}\\frac{\\sin\\Delta}{\\Delta}=1\\) \\(\\lim_{\\Delta\\to\\infty}\\frac{\\sin\\Delta}{\\Delta}=0\\) \\(\\lim_{\\Delta\\to 0}\\left( 1+\\Delta \\right)^{\\frac{1}{\\Delta}}=\\lim_{\\Delta\\to\\infty}\\left( 1+\\frac{1}{\\Delta} \\right)^{\\Delta}=e\\) 无穷小 定义 以 \\(0\\) 为极限的函数称为无穷小。 高阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=0\\] 则\\(\\beta\\)为\\(\\alpha\\)的高阶无穷小。 同阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=k \\left( k\\neq 0 \\right)\\] 则\\(\\beta\\)为\\(\\alpha\\)的同阶无穷小。 等价无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=1\\] 则\\(\\beta\\)为\\(\\alpha\\)的等价无穷小。 代换公式 三角/反三角函数 \\(\\sin x\\sim \\arcsin x\\sim\\tan x\\sim \\arctan x\\sim x\\) 指数/对数 \\(e^x-1\\sim\\ln(x+1)\\sim x\\) 其他 \\(\\left( 1+x \\right)^a-1\\sim ax\\) \\(\\sqrt[n]{1+x}-1\\sim\\frac{x}{n}\\) \\(1-\\cos^a x\\sim\\frac{ax^2}{2}\\) 洛必达法则 若满足以下形式： \\(\\frac{0}{0}\\) 型 \\(\\frac{\\infty}{\\infty}\\) 型 则： \\[\\lim \\frac{f(x)}{g(x)}=\\lim \\frac{f^{\\prime}(x)}{g^{\\prime}(x)}\\] 变式 \\(\\infty-\\infty\\)型：通分 \\(0\\cdot\\infty\\)型：取倒数 \\(1^{\\infty}\\)型：取对数 \\(0^0\\)：取对数 \\(\\infty^0\\)：取对数 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#重要极限公式"},{"categories":null,"content":"极限 定义 \\[x\\to x_0 \\Rightarrow \\begin{cases} x \\neq x_0 \\\\ x \\to x_0^+ \\\\ x \\to x_0^- \\\\ \\end{cases}\\] \\[\\lim_{x\\to x_0}f(x)=A\\] 左极限：\\(\\lim_{x\\to x_0^-}f(x)=A\\) 右极限：\\(\\lim_{x\\to x_0^+}f(x)=A\\) 条件 极限存在充要条件： \\[\\lim_{x\\to x_0^-}f(x)=\\lim_{x\\to x_0^+}f(x)\\] 重要极限公式 \\(\\lim_{\\Delta\\to 0}\\frac{\\sin\\Delta}{\\Delta}=1\\) \\(\\lim_{\\Delta\\to\\infty}\\frac{\\sin\\Delta}{\\Delta}=0\\) \\(\\lim_{\\Delta\\to 0}\\left( 1+\\Delta \\right)^{\\frac{1}{\\Delta}}=\\lim_{\\Delta\\to\\infty}\\left( 1+\\frac{1}{\\Delta} \\right)^{\\Delta}=e\\) 无穷小 定义 以 \\(0\\) 为极限的函数称为无穷小。 高阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=0\\] 则\\(\\beta\\)为\\(\\alpha\\)的高阶无穷小。 同阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=k \\left( k\\neq 0 \\right)\\] 则\\(\\beta\\)为\\(\\alpha\\)的同阶无穷小。 等价无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=1\\] 则\\(\\beta\\)为\\(\\alpha\\)的等价无穷小。 代换公式 三角/反三角函数 \\(\\sin x\\sim \\arcsin x\\sim\\tan x\\sim \\arctan x\\sim x\\) 指数/对数 \\(e^x-1\\sim\\ln(x+1)\\sim x\\) 其他 \\(\\left( 1+x \\right)^a-1\\sim ax\\) \\(\\sqrt[n]{1+x}-1\\sim\\frac{x}{n}\\) \\(1-\\cos^a x\\sim\\frac{ax^2}{2}\\) 洛必达法则 若满足以下形式： \\(\\frac{0}{0}\\) 型 \\(\\frac{\\infty}{\\infty}\\) 型 则： \\[\\lim \\frac{f(x)}{g(x)}=\\lim \\frac{f^{\\prime}(x)}{g^{\\prime}(x)}\\] 变式 \\(\\infty-\\infty\\)型：通分 \\(0\\cdot\\infty\\)型：取倒数 \\(1^{\\infty}\\)型：取对数 \\(0^0\\)：取对数 \\(\\infty^0\\)：取对数 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#无穷小"},{"categories":null,"content":"极限 定义 \\[x\\to x_0 \\Rightarrow \\begin{cases} x \\neq x_0 \\\\ x \\to x_0^+ \\\\ x \\to x_0^- \\\\ \\end{cases}\\] \\[\\lim_{x\\to x_0}f(x)=A\\] 左极限：\\(\\lim_{x\\to x_0^-}f(x)=A\\) 右极限：\\(\\lim_{x\\to x_0^+}f(x)=A\\) 条件 极限存在充要条件： \\[\\lim_{x\\to x_0^-}f(x)=\\lim_{x\\to x_0^+}f(x)\\] 重要极限公式 \\(\\lim_{\\Delta\\to 0}\\frac{\\sin\\Delta}{\\Delta}=1\\) \\(\\lim_{\\Delta\\to\\infty}\\frac{\\sin\\Delta}{\\Delta}=0\\) \\(\\lim_{\\Delta\\to 0}\\left( 1+\\Delta \\right)^{\\frac{1}{\\Delta}}=\\lim_{\\Delta\\to\\infty}\\left( 1+\\frac{1}{\\Delta} \\right)^{\\Delta}=e\\) 无穷小 定义 以 \\(0\\) 为极限的函数称为无穷小。 高阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=0\\] 则\\(\\beta\\)为\\(\\alpha\\)的高阶无穷小。 同阶无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=k \\left( k\\neq 0 \\right)\\] 则\\(\\beta\\)为\\(\\alpha\\)的同阶无穷小。 等价无穷小 \\[\\lim \\frac{\\beta}{\\alpha}=1\\] 则\\(\\beta\\)为\\(\\alpha\\)的等价无穷小。 代换公式 三角/反三角函数 \\(\\sin x\\sim \\arcsin x\\sim\\tan x\\sim \\arctan x\\sim x\\) 指数/对数 \\(e^x-1\\sim\\ln(x+1)\\sim x\\) 其他 \\(\\left( 1+x \\right)^a-1\\sim ax\\) \\(\\sqrt[n]{1+x}-1\\sim\\frac{x}{n}\\) \\(1-\\cos^a x\\sim\\frac{ax^2}{2}\\) 洛必达法则 若满足以下形式： \\(\\frac{0}{0}\\) 型 \\(\\frac{\\infty}{\\infty}\\) 型 则： \\[\\lim \\frac{f(x)}{g(x)}=\\lim \\frac{f^{\\prime}(x)}{g^{\\prime}(x)}\\] 变式 \\(\\infty-\\infty\\)型：通分 \\(0\\cdot\\infty\\)型：取倒数 \\(1^{\\infty}\\)型：取对数 \\(0^0\\)：取对数 \\(\\infty^0\\)：取对数 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#洛必达法则"},{"categories":null,"content":"单调性 极值点 可能存在于： 一阶导数为\\(0\\)的点（驻点） 同时要一阶导数左右异号。 一阶导数不存在的点 驻点 一阶导数为\\(0\\)的点 拐点 可能存在于： 二阶导数为\\(0\\)的点 同时要二阶导数左右异号。 二阶导数不存在的点 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#单调性"},{"categories":null,"content":"单调性 极值点 可能存在于： 一阶导数为\\(0\\)的点（驻点） 同时要一阶导数左右异号。 一阶导数不存在的点 驻点 一阶导数为\\(0\\)的点 拐点 可能存在于： 二阶导数为\\(0\\)的点 同时要二阶导数左右异号。 二阶导数不存在的点 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#极值点"},{"categories":null,"content":"单调性 极值点 可能存在于： 一阶导数为\\(0\\)的点（驻点） 同时要一阶导数左右异号。 一阶导数不存在的点 驻点 一阶导数为\\(0\\)的点 拐点 可能存在于： 二阶导数为\\(0\\)的点 同时要二阶导数左右异号。 二阶导数不存在的点 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#驻点"},{"categories":null,"content":"单调性 极值点 可能存在于： 一阶导数为\\(0\\)的点（驻点） 同时要一阶导数左右异号。 一阶导数不存在的点 驻点 一阶导数为\\(0\\)的点 拐点 可能存在于： 二阶导数为\\(0\\)的点 同时要二阶导数左右异号。 二阶导数不存在的点 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#拐点"},{"categories":null,"content":"凹凸性 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:3","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#凹凸性"},{"categories":null,"content":"连续 \\[\\lim_{x\\to x_0}=f(x_0)\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:4","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#连续"},{"categories":null,"content":"间断点 第一类间断点 可去间断点 \\[\\lim_{x\\to x_0^+}f(x)=\\lim_{x\\to x_o^+}\\neq f(x_o)\\] 跳跃间断点 \\[\\lim_{x\\to x_0^-}f(x)\\neq \\lim_{x\\to x_0^+}f(x)\\] 第二类间断点 \\[\\lim_{x\\to x_0^-}f(x),\\lim_{x\\to x_0^-}f(x)\\text{至少一个不存在}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#间断点"},{"categories":null,"content":"间断点 第一类间断点 可去间断点 \\[\\lim_{x\\to x_0^+}f(x)=\\lim_{x\\to x_o^+}\\neq f(x_o)\\] 跳跃间断点 \\[\\lim_{x\\to x_0^-}f(x)\\neq \\lim_{x\\to x_0^+}f(x)\\] 第二类间断点 \\[\\lim_{x\\to x_0^-}f(x),\\lim_{x\\to x_0^-}f(x)\\text{至少一个不存在}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#第一类间断点"},{"categories":null,"content":"间断点 第一类间断点 可去间断点 \\[\\lim_{x\\to x_0^+}f(x)=\\lim_{x\\to x_o^+}\\neq f(x_o)\\] 跳跃间断点 \\[\\lim_{x\\to x_0^-}f(x)\\neq \\lim_{x\\to x_0^+}f(x)\\] 第二类间断点 \\[\\lim_{x\\to x_0^-}f(x),\\lim_{x\\to x_0^-}f(x)\\text{至少一个不存在}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#第二类间断点"},{"categories":null,"content":"初等函数 定义 在定义域上可以用一个解析式来表示。也就是说\\(\\sum\\limits_{i=1}^n \\frac{1}{n}\\)不属于初等函数。 性质 初等函数、常数经过有限次四则运算依然得到初等函数。 基本初等函数 幂函数：\\(y=x^\\mu\\) 指数函数：\\(y=a^x,(a\u003e0,a\\neq1)\\) 对数函数 \\(y=\\log_ax\\) \\(y=\\ln x\\) 三角函数 \\(y=\\sin x\\) \\(y=\\cos x\\) \\(y=\\tan x\\) \\(y=\\cot x, (x\\in\\mathbb{R}, x\\neq k\\pi(k\\in \\mathbb{Z}))\\) 反三角函数 定义域为\\(x\\in[-1,1]\\)的函数： \\(y=\\arcsin x\\) 反函数为\\(y=\\sin x, x\\in[-\\frac{\\pi}{2},\\frac{\\pi}{2}]\\) \\(y=\\arccos x\\) 反函数为\\(y=\\cos x, x\\in[0,\\pi]\\) 定义域为\\(x\\in(-\\infty,+\\infty)\\)的函数： \\(y=\\arctan x\\) 反函数为\\(y=\\tan x, x\\in(\\frac{\\pi}{2},\\frac{\\pi}{2})\\) \\(y=\\operatorname{arccot} x\\) 反函数为\\(y=\\cot x, x\\in(\\frac{\\pi}{2},\\frac{\\pi}{2})\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:6","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#初等函数"},{"categories":null,"content":"初等函数 定义 在定义域上可以用一个解析式来表示。也就是说\\(\\sum\\limits_{i=1}^n \\frac{1}{n}\\)不属于初等函数。 性质 初等函数、常数经过有限次四则运算依然得到初等函数。 基本初等函数 幂函数：\\(y=x^\\mu\\) 指数函数：\\(y=a^x,(a\u003e0,a\\neq1)\\) 对数函数 \\(y=\\log_ax\\) \\(y=\\ln x\\) 三角函数 \\(y=\\sin x\\) \\(y=\\cos x\\) \\(y=\\tan x\\) \\(y=\\cot x, (x\\in\\mathbb{R}, x\\neq k\\pi(k\\in \\mathbb{Z}))\\) 反三角函数 定义域为\\(x\\in[-1,1]\\)的函数： \\(y=\\arcsin x\\) 反函数为\\(y=\\sin x, x\\in[-\\frac{\\pi}{2},\\frac{\\pi}{2}]\\) \\(y=\\arccos x\\) 反函数为\\(y=\\cos x, x\\in[0,\\pi]\\) 定义域为\\(x\\in(-\\infty,+\\infty)\\)的函数： \\(y=\\arctan x\\) 反函数为\\(y=\\tan x, x\\in(\\frac{\\pi}{2},\\frac{\\pi}{2})\\) \\(y=\\operatorname{arccot} x\\) 反函数为\\(y=\\cot x, x\\in(\\frac{\\pi}{2},\\frac{\\pi}{2})\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:1:6","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#基本初等函数"},{"categories":null,"content":"微分 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:2:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#微分"},{"categories":null,"content":"导数 定义 \\[f^{\\prime}(x_0)=\\lim_{\\Delta x\\to 0}\\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}\\] 左导数：\\(f^{\\prime}_-(x_0)=\\lim_{\\Delta x\\to 0^-}\\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}\\) 右导数：\\(f^{\\prime}_+(x_0)=\\lim_{\\Delta x\\to 0^+}\\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}\\) 条件 函数在\\(x_0\\)可导的充要条件： \\[f^{\\prime}_-f(x_0)=f^{\\prime}_+f(x_0)\\] 即左导数等于右导数。 求法 参数方程 \\[\\begin{cases} \\frac{\\mathrm{d}x}{\\mathrm{d}t} \\\\ \\frac{\\mathrm{d}y}{\\mathrm{d}t} \\\\ \\end{cases} \\Rightarrow \\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{\\frac{\\mathrm{d}y}{\\mathrm{d}t}}{\\frac{\\mathrm{d}x}{\\mathrm{d}t}} \\Rightarrow \\frac{\\mathrm{d}\\left( \\frac{\\mathrm{d}y}{\\mathrm{d}x} \\right)}{\\mathrm{d}t}\\Rightarrow \\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}=\\frac{\\frac{\\mathrm{d}\\left( \\frac{\\mathrm{d}y}{\\mathrm{d}x} \\right)}{\\mathrm{d}t}}{\\frac{\\mathrm{d}x}{\\mathrm{d}t}}\\] 关系 可导\\(\\begin{aligned} \\Rightarrow \\\\ \\Leftarrow \\end{aligned} \\)可微\\(\\begin{aligned} \\Rightarrow \\\\ \\nLeftarrow \\end{aligned} \\)连续 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:2:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#导数"},{"categories":null,"content":"微分形式不变性 法则： \\(\\mathrm d(u\\pm v)=\\mathrm du\\pm \\mathrm dv\\) \\(\\mathrm d(uv)=v\\mathrm du+u\\mathrm dv\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:2:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#微分形式不变性"},{"categories":null,"content":"全微分 全微分形式不变性 \\[z=f(u,v)\\Rightarrow \\mathrm dz=\\frac{\\partial f}{\\partial u}\\mathrm du+\\frac{\\partial f}{\\partial v}\\mathrm dv\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:2:3","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#全微分"},{"categories":null,"content":"全微分 全微分形式不变性 \\[z=f(u,v)\\Rightarrow \\mathrm dz=\\frac{\\partial f}{\\partial u}\\mathrm du+\\frac{\\partial f}{\\partial v}\\mathrm dv\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:2:3","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#全微分形式不变性"},{"categories":null,"content":"积分 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#积分"},{"categories":null,"content":"积分表 \\(\\int k\\mathrm{d}x=k x+C\\) \\(\\int x^{a}\\mathrm{d}x=\\frac{x^{a+1}}{a+1}+C \\quad(a \\neq-1)\\) \\(\\int \\frac{d x}{x}=\\ln |x|+C\\) \\(\\int a^{x}\\mathrm{d}x=\\frac{a^{x}}{\\ln a}+C\\) \\(\\int e^{x}\\mathrm{d}x=e^{x}+C\\) \\(\\int \\sin x\\mathrm{d}x=-\\cos x+C\\) \\(\\int \\cos x\\mathrm{d}x=\\sin x+C\\) \\(\\int \\tan x\\mathrm{d}x=-\\ln |\\cos x|+C\\) \\(\\int \\cot x\\mathrm{d}x=\\ln |\\sin x|+C\\) \\(\\int \\sec x\\mathrm{d}x=\\ln |\\sec x+\\tan x|+C\\) \\(\\int \\csc x\\mathrm{d}x=\\ln |\\csc x-\\cot x|+C\\) \\(\\int \\sec ^{2} x\\mathrm{d}x=\\tan x+C\\) \\(\\int \\csc ^{2} x\\mathrm{d}x=-\\cot x+C\\) \\(\\int \\sec x \\tan x\\mathrm{d}x=\\sec x+C\\) \\(\\int \\csc x \\cot x\\mathrm{d}x=-\\csc x+C\\) \\(\\int \\frac{1}{\\sqrt{1-x^{2}}}\\mathrm{d}x=\\arcsin x+C\\) \\(\\int \\frac{d x}{\\sqrt{a^{2}-x^{2}}}=\\arcsin \\frac{x}{a}+C(a\u003e0)\\) \\(\\int \\frac{1}{1+x^{2}}\\mathrm{d}x=\\arctan x+C\\) \\(\\int \\frac{d x}{a^{2}+x^{2}}=\\frac{1}{a} \\arctan \\frac{x}{a}+C\\) \\(\\int \\frac{d x}{x^{2}-a^{2}}=\\frac{1}{2 a} \\ln \\left|\\frac{x-a}{x+a}\\right|+C\\) \\(\\int \\frac{d x}{\\sqrt{x^{2}+a^{2}}}=\\ln \\left|x+\\sqrt{x^{2}+a^{2}}\\right|+C\\) \\(\\int \\frac{d x}{\\sqrt{x^{2}-a^{2}}}=\\ln \\left|x+\\sqrt{x^{2}-a^{2}}\\right|+C\\) \\(\\int \\frac{d x}{\\sqrt{a^{2}-x^{2}}}=\\frac{a^{2}}{2} \\arcsin \\frac{x}{a}+\\frac{x}{2} \\sqrt{x^{2}-a^{2}}+C\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#积分表"},{"categories":null,"content":"第一换元法 即凑微分法。 定义 也就是把\\(\\mathrm{d}\\)左边的式子写成一个微分的形式： \\[\\int f(x)\\mathrm dx=F(x)+C,\\varphi(x)\\text{可导}\\\\ \\Rightarrow \\int f(\\varphi(x))\\varphi’(x)\\mathrm dx=F(\\varphi(x))+C\\] 步骤 移动微分，使前面的式子正好为\\(\\varphi(x)\\)的可积表达式： \\[\\int f(\\varphi(x))\\varphi^{\\prime}(x)\\mathrm dx \\\\ = \\int f(\\varphi(x))\\frac{\\mathrm d\\varphi(x)}{\\mathrm dx}\\mathrm dx \\\\ = \\int f(\\varphi(x))\\mathrm d\\varphi(x)\\] \\(\\int {f( ax + b){\\rm{d}}x = }\\frac{1}{a}\\int {f(ax+b){\\mathrm{d}}(ax + b)\\;(a \\neq 0)}\\) \\(\\int {f(a{x^{m + 1}} + b){x^m}{\\rm{d}}x} = \\frac{1}{{a(m + 1)}}\\int {f(a{x^{m + 1}} + b){\\rm{d}}(a{x^{m + 1}} + b)}\\) \\(\\int {f\\left( \\frac{1}{x}\\right) \\frac{{{\\rm{d}}x}}{{{x^2}}}\\;} = - \\int {f\\left( \\frac{1}{x}\\right) {\\rm{d}}\\left( \\frac{{\\rm{1}}}{x}\\right) \\;}\\) \\(\\int {f(\\ln x)\\frac{1}{x}} {\\rm{d}}x = \\int {f(\\ln x){\\rm{d(}}\\ln x)}\\) \\(\\int {f({\\mathrm{e}^x})} {\\mathrm{e}^x}{\\rm{d}}x = \\int {f({\\mathrm{e}^x}} ){\\rm{d(}}{\\mathrm{e}^x})\\) \\(\\int {f(\\sqrt x } )\\frac{{{\\rm{d}}x}}{{\\sqrt x }} = 2\\int {f(\\sqrt x } ){\\rm{d}}(\\sqrt x )\\) \\(\\int {f(\\sin x)\\cos x{\\rm{d}}x = } \\int {f(\\sin x){\\rm{d}}\\sin x}\\) \\(\\int {f(\\cos x)\\sin x{\\rm{d}}x = } - \\int {f(\\cos x){\\rm{d}}\\cos x}\\) \\(\\int {f(\\tan x){{\\sec }^2}} x{\\rm{d}}x = \\int {f(\\tan x){\\rm{d}}\\tan x}\\) \\(\\int {f(\\cot x){{\\csc }^2}} x{\\rm{d}}x = - \\int {f(\\cot x){\\rm{d}}\\cot x}\\) \\(\\int {f(\\arcsin x)\\frac{1}{{\\sqrt {1 - {x^2}} }}} {\\rm{d}}x = \\int {f(\\arcsin x){\\rm{d}}\\arcsin x}\\) \\(\\int {f(\\arctan x)\\frac{1}{{1 + {x^2}}}} {\\rm{d}}x = \\int {f(\\arctan x){\\rm{d}}\\arctan x}\\) \\(\\int {\\frac{{f’(x)}}{{f(x)}}} {\\rm{d}}x = \\int {\\frac{{{\\rm{d}}f(x)}}{{f(x)}}} = \\ln \\left| f(x)\\right| + C\\) 技巧 裂项 放一次或常数到\\(\\mathrm{d}\\)后面去，在积分号前面补常数 看上去就一个函数，如： \\(\\int(2x+3)^{10}\\mathrm dx=\\frac{1}{2}\\int(2x+3)^{10}\\mathrm d(2x+3)\\) 只要分母关于\\(\\mathrm{d}\\)后面式子的二次函数，就一定能求出积分 分母配方，\\(\\mathrm{d}\\)后补常数 \\(\\mathrm{d}\\)后的表达式与被积函数的相差常数不影响 \\(\\sin x\\)与\\(\\cos x\\)可通过平方互换 如： \\(\\int \\frac{\\mathrm dx}{\\cos x}\\stackrel{\\text{同乘}\\cos x}=\\int\\frac{\\mathrm d\\sin x}{1-\\sin^2x}=\\frac{1}{2}\\ln|\\frac{\\sin x+1}{\\sin x-1}|\\) 构造无一次项的完全平方 \\(x^\\alpha\\pm\\frac{1}{x^\\alpha}\\) \\(a^x\\pm a^{-x}\\) 凑完全平方 分子凑成分母的导数 用于无法裂项的真分式： \\[\\int\\frac{\\varphi’(x)}{\\varphi(x)}\\mathrm dx=\\int\\frac{\\mathrm d\\varphi(x)}{\\varphi(x)}\\] 易错 移动只能移动因子（和等价无穷小相同） 在构造d中的式子时遇到需要常数项可以随意增减，但非常数项就得往原式里加上一些式子，相应的后面就要减去它们。如果是非因子则须拆成两个式子写两个积分号再移动。 \\(\\mathrm d\\)里原有非\\(x^1\\)因子则不能直接放入 必须考虑d中因子相乘求导后能不能得到原式，如： \\[\\int\\frac{\\sin x\\cos x}{1+\\sin^4x}\\mathrm dx=\\int\\frac{\\sin x}{1+\\sin^4x}\\mathrm d\\sin x=\\frac{1}{2}\\int\\frac{\\mathrm d\\sin^2x}{1+\\sin^4x}\\] 其中\\((\\sin^2 x)’=2\\sin x\\cos x=\\sin 2x\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#第一换元法"},{"categories":null,"content":"第二换元法 \\[\\int f(\\psi(t))\\psi’(t)\\mathrm dt=F(t)+C\\text{且}\\psi\\text{单调可导}, \\psi’\\neq0\\Rightarrow \\int f(x)\\mathrm dx=F(\\psi^{-1}(x))+C\\] 步骤 变量代换 \\(x=\\psi(t)\\) 看上去是把x复杂化了，但是可以消除求积分的障碍。有以下几种情况： 根号 三角变换 这种情况往往根号里有二次。思路是，要把根号去掉，说明要某个函数的平方加上一个常数（可以不是\\(1\\)，换元式子里可以包含这个常数）能得到另一个函数的平方，这个函数就是\\(\\tan x\\)，如： \\(\\int\\frac{\\mathrm dx}{\\sqrt{x^2+a^2}}\\stackrel{x=a\\tan t}=\\int\\frac{a\\sec^2t\\mathrm dt}{a\\sqrt{\\sec^2t}}=\\int\\frac{\\mathrm dt}{\\cos t}=\\frac{1}{2}\\ln|\\frac{\\sin t+1}{\\sin t-1}|+C=\\ln|\\sqrt{\\frac{x^2}{a}+1}+\\frac{x}{a}|+C,(a\u003e0)\\) 最后\\(a\\)可以提出来利用对数函数的性质把因式变成加数最后归入常数 \\(\\sqrt{a^2-x^2}\\mathrm dt=\\frac{a^2}{2}(\\arcsin\\frac{x}{a}+\\frac{x}{a^2}\\sqrt{a^2-x^2})+C,(a\u003e0)\\) 倒变换 取\\(x\\)的倒数变换，这种情况往往根号旁边还有\\(x\\)，如： \\(\\int\\frac{\\mathrm dx}{x\\sqrt{4x^2+2x-1}}\\stackrel{t=\\frac{1}{x}}=\\int\\frac{(-t)^2\\mathrm dt}{t^2\\sqrt{4+2t+t^2}}\\stackrel{\\text{凑完全平方}}=\\dots\\stackrel{\\text{积分表}}=\\dots, (x\u003e0)\\) 利用\\(d \\left( \\frac{1}{t} \\right)\\)的副产物消去不必要的因子。 整体代换 \\(\\int f(x)\\mathrm dx=\\int f(\\psi(t))\\psi’(t)\\mathrm dt\\) 换元后的函数需要可积。 求出原函数：\\(F(t)+C\\) 回代原函数：\\(t=\\psi^{-1}(x)\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:3","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#第二换元法"},{"categories":null,"content":"分部积分法 \\[\\begin{aligned} \u0026(uv)’=u’v+uv’\\Rightarrow uv’=(uv)’-u’v \\\\ \\Rightarrow \u0026\\int uv’\\mathrm dx=uv-\\int u’v\\mathrm dx \\\\ \\Rightarrow \u0026\\int u\\mathrm dv=uv-\\int v\\mathrm du \\end{aligned}\\] 例 简单情况 保证左边积分号后面为纯\\(x\\)，微分号后面为可积的简单式子，这样右边就能把\\(x\\)放在微分号后面： \\[\\int x\\sin x\\mathrm dx=-\\int x\\mathrm d\\cos x\\=-(x\\cos x-\\int\\cos x\\mathrm dx)=\\sin x-x\\cos x+C\\] 再来一次 通常用在指数函数扔进去的情况中，可以降低幂函数的次数： \\[\\int x^2e^x\\mathrm dx=x^2e^x-\\int2xe^x\\mathrm dx\\=x^2e^x-(xe^x-\\int e^x\\mathrm dx)\\] \\(\\ln x\\) \\[\\int x\\ln x\\mathrm dx=\\frac{1}{2}x^2\\ln x-\\frac{1}{2}\\int\\frac{x^2}{x}\\mathrm dx=\\frac{1}{2}x^2\\ln x-\\frac{x^2}{4}+C\\] “1”的代换：\\(x_0=1\\) \\[\\int \\arctan x\\mathrm dx^1=x\\arctan x-\\int\\frac{x}{x^2+1}\\mathrm dx=\\dots\\] 解方程（循环相消） \\[I=\\int e^{2x}\\sin x\\mathrm dx\\stackrel{2\\text{次分部积分}}=\\frac{1}{2}e^{2x}\\sin x-\\frac{1}{4}e^{2x}-\\frac{1}{4}\\int e^{2x}\\sin x\\mathrm dx\\Rightarrow I=\\dots\\] 放部分 部分是积分表里有的： \\[I=\\int \\sec^3x\\mathrm dx\\\\stackrel{(tan x)’=\\sec^2x}=\\int\\sec x\\mathrm d\\tan x=\\sec x\\tan x-\\int\\tan^2x\\sec x\\mathrm dx\\\\stackrel{\\tan^x=\\sec^2x-1}=\\sec x\\tan x-I+\\int\\sec x\\mathrm dx\\\\stackrel{\\int\\sec x\\mathrm dx=\\int\\frac{\\mathrm d\\sin x}{1-\\sin^2x}=\\ln|\\sec x+\\tan x|}\\Longrightarrow I=\\dots\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:4","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#分部积分法"},{"categories":null,"content":"特殊函数的积分 有理函数的积分 \\(\\int\\frac{P(x)}{Q(x)}\\mathrm dx\\) 其中\\(P(x)\\)、\\(Q(x)\\)均为多项式。 步骤 假分式\\(\\rightarrow\\)多项式\\(\\rightarrow\\)真分式 分母\\(\\rightarrow\\)一次式/二次三项式 分式\\(\\rightarrow\\)最简分式之和\\(\\rightarrow\\)逐个积分 情况 \\(\\frac{A}{(x-a)^k}\\) \\(\\frac{Cx+D}{(x^2+px+q)^k}\\) \\(\\int\\frac{Cx+D}{(x^2+px+q)^k}\\mathrm dx=\\frac{C}{2}\\int\\frac{\\mathrm d(x^2+px+q)}{(x^2+px+q)^k}+\\int\\frac{D-\\frac{Cp}{2}}{(x^2+px+q)^k}\\mathrm dx\\) 例 \\(\\frac{x^5-x^3-2x^2+7x}{x^4-x^2-2x+2}\\stackrel{\\text{化为真分式}}=x+\\frac{5x}{x^4-x^2-2x+2}\\stackrel{\\text{因式分解}}=x+\\frac{5x}{(x-1)^2(x^2+2x+2)}\\stackrel{\\text{拆（猜）项}}=x+\\frac{A}{x-1}+\\frac{B}{(x-1)^2}+\\frac{Cx+D}{x^2+2x+2}\\stackrel{\\text{待定系数}}=\\dots\\) 左右均为等式，\\(x\\)取任何值都能使等式成立（前提是形式能猜出来）。 \\(\\int\\frac{x^{11}}{x^8+3x^4+2}\\mathrm dx\\stackrel{\\text{凑}x^4}=\\frac{x^8\\mathrm dx^4}{4(x^8+3x^4+2)}\\stackrel{x^4=u}=\\dots\\) \\(I_k=\\int\\frac{\\mathrm dx}{(x^2+a)^k}\\) 递推式： \\[I_1-aI_2\\stackrel{\\text{凑纯}x^2}=\\int\\frac{x^2+a-a}{(x^2+a)^2}\\mathrm dx\\stackrel{\\text{凑}x^2+a}=\\frac{1}{2}\\int\\frac{x\\mathrm d(x^2+a)}{(x^2+a)^2}\\stackrel{\\text{把分母放到}\\mathrm d\\text{里}}=-\\frac{1}{2}\\int x\\mathrm d{\\frac{1}{x^2+a}}\\stackrel{\\text{分部积分}}=\\frac{1}{2}\\frac{1}{x^2+a}\\mathrm dx-\\frac{x}{2(x^2+a)}=\\frac{I_1}{2}-\\frac{x}{2(x^2+a)}\\] 无理函数的积分 方法 三角变换（第二换元法） 根式整体代换 例 \\(\\int\\frac{\\mathrm dx}{\\sqrt[3]{(x-1)(x+1)^2}}\\stackrel{\\text{简化分式}}=\\int\\frac{1}{x+1}\\sqrt[3]{\\frac{x+1}{x-1}}\\mathrm dx\\xrightarrow{t=\\sqrt[3]{\\frac{x+1}{x-1}}\\Rightarrow x=\\frac{t^3+1}{t^3-1}}-\\int\\frac{3}{t^3-1}\\mathrm dt=-3\\int\\frac{\\mathrm dt}{(t-1)(t^2+t+1)}\\stackrel{\\text{裂项}}=\\dots\\) 三角函数的积分 情况 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的奇数幂 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的幂的和为偶数 原则 尽量用凑微分法（第一换元法） 例 \\(\\int\\sin^2x\\cos^3x\\mathrm dx\\stackrel{\\text{放一个}\\cos x}=\\int\\sin^2x(1-\\sin^2x)\\mathrm d\\sin x=\\dots\\) 谁是奇数次幂，就把谁放一部分到后面去。 \\(\\int\\frac{\\mathrm dx}{\\sin^2x\\cos x}\\stackrel{\\text{同乘}\\cos x}=\\int\\frac{\\mathrm d\\sin x}{\\sin^2x(1-\\sin^2x)}\\stackrel{\\text{拆项}}=\\int(\\frac{1}{\\sin^2x}-\\frac{1}{1-\\sin^2x})\\mathrm dx=\\dots\\) \\(\\int\\frac{\\mathrm dx}{\\sin x\\cos^3x}\\stackrel{\\text{放}\\sec^2x}=\\int\\frac{\\mathrm d\\tan x}{\\sin x\\cos x}\\stackrel{\\text{同除}\\cos^2x}=\\int\\frac{(\\tan^2x+1)\\mathrm d\\tan x}{\\tan x}=\\dots\\) 万能代换公式 将三角函数转化为有理函数： \\[t=\\tan\\frac{x}{2}\\Rightarrow \\mathrm dx=\\frac{2\\mathrm dt}{t^2+1}\\] 万能公式 \\(\\sin\\alpha=2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}=\\frac{2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{2\\tan\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\cos\\alpha=\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}=\\frac{\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{1-\\tan^2\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\tan\\alpha=\\frac{\\sin\\alpha}{\\cos\\alpha}=\\frac{2\\tan\\frac{\\alpha}{2}}{1-\\tan^2\\frac{\\alpha}{2}}\\) 例 \\(\\int\\frac{\\mathrm dx}{4-3\\sin x}\\stackrel{\\text{万能公式}}=\\int\\frac{\\mathrm dt}{2+2t^2-3t}\\stackrel{\\text{配方}}=\\dots\\stackrel{\\frac{1}{x^2+a^2}\\text{的积分}}=\\dots\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#特殊函数的积分"},{"categories":null,"content":"特殊函数的积分 有理函数的积分 \\(\\int\\frac{P(x)}{Q(x)}\\mathrm dx\\) 其中\\(P(x)\\)、\\(Q(x)\\)均为多项式。 步骤 假分式\\(\\rightarrow\\)多项式\\(\\rightarrow\\)真分式 分母\\(\\rightarrow\\)一次式/二次三项式 分式\\(\\rightarrow\\)最简分式之和\\(\\rightarrow\\)逐个积分 情况 \\(\\frac{A}{(x-a)^k}\\) \\(\\frac{Cx+D}{(x^2+px+q)^k}\\) \\(\\int\\frac{Cx+D}{(x^2+px+q)^k}\\mathrm dx=\\frac{C}{2}\\int\\frac{\\mathrm d(x^2+px+q)}{(x^2+px+q)^k}+\\int\\frac{D-\\frac{Cp}{2}}{(x^2+px+q)^k}\\mathrm dx\\) 例 \\(\\frac{x^5-x^3-2x^2+7x}{x^4-x^2-2x+2}\\stackrel{\\text{化为真分式}}=x+\\frac{5x}{x^4-x^2-2x+2}\\stackrel{\\text{因式分解}}=x+\\frac{5x}{(x-1)^2(x^2+2x+2)}\\stackrel{\\text{拆（猜）项}}=x+\\frac{A}{x-1}+\\frac{B}{(x-1)^2}+\\frac{Cx+D}{x^2+2x+2}\\stackrel{\\text{待定系数}}=\\dots\\) 左右均为等式，\\(x\\)取任何值都能使等式成立（前提是形式能猜出来）。 \\(\\int\\frac{x^{11}}{x^8+3x^4+2}\\mathrm dx\\stackrel{\\text{凑}x^4}=\\frac{x^8\\mathrm dx^4}{4(x^8+3x^4+2)}\\stackrel{x^4=u}=\\dots\\) \\(I_k=\\int\\frac{\\mathrm dx}{(x^2+a)^k}\\) 递推式： \\[I_1-aI_2\\stackrel{\\text{凑纯}x^2}=\\int\\frac{x^2+a-a}{(x^2+a)^2}\\mathrm dx\\stackrel{\\text{凑}x^2+a}=\\frac{1}{2}\\int\\frac{x\\mathrm d(x^2+a)}{(x^2+a)^2}\\stackrel{\\text{把分母放到}\\mathrm d\\text{里}}=-\\frac{1}{2}\\int x\\mathrm d{\\frac{1}{x^2+a}}\\stackrel{\\text{分部积分}}=\\frac{1}{2}\\frac{1}{x^2+a}\\mathrm dx-\\frac{x}{2(x^2+a)}=\\frac{I_1}{2}-\\frac{x}{2(x^2+a)}\\] 无理函数的积分 方法 三角变换（第二换元法） 根式整体代换 例 \\(\\int\\frac{\\mathrm dx}{\\sqrt[3]{(x-1)(x+1)^2}}\\stackrel{\\text{简化分式}}=\\int\\frac{1}{x+1}\\sqrt[3]{\\frac{x+1}{x-1}}\\mathrm dx\\xrightarrow{t=\\sqrt[3]{\\frac{x+1}{x-1}}\\Rightarrow x=\\frac{t^3+1}{t^3-1}}-\\int\\frac{3}{t^3-1}\\mathrm dt=-3\\int\\frac{\\mathrm dt}{(t-1)(t^2+t+1)}\\stackrel{\\text{裂项}}=\\dots\\) 三角函数的积分 情况 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的奇数幂 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的幂的和为偶数 原则 尽量用凑微分法（第一换元法） 例 \\(\\int\\sin^2x\\cos^3x\\mathrm dx\\stackrel{\\text{放一个}\\cos x}=\\int\\sin^2x(1-\\sin^2x)\\mathrm d\\sin x=\\dots\\) 谁是奇数次幂，就把谁放一部分到后面去。 \\(\\int\\frac{\\mathrm dx}{\\sin^2x\\cos x}\\stackrel{\\text{同乘}\\cos x}=\\int\\frac{\\mathrm d\\sin x}{\\sin^2x(1-\\sin^2x)}\\stackrel{\\text{拆项}}=\\int(\\frac{1}{\\sin^2x}-\\frac{1}{1-\\sin^2x})\\mathrm dx=\\dots\\) \\(\\int\\frac{\\mathrm dx}{\\sin x\\cos^3x}\\stackrel{\\text{放}\\sec^2x}=\\int\\frac{\\mathrm d\\tan x}{\\sin x\\cos x}\\stackrel{\\text{同除}\\cos^2x}=\\int\\frac{(\\tan^2x+1)\\mathrm d\\tan x}{\\tan x}=\\dots\\) 万能代换公式 将三角函数转化为有理函数： \\[t=\\tan\\frac{x}{2}\\Rightarrow \\mathrm dx=\\frac{2\\mathrm dt}{t^2+1}\\] 万能公式 \\(\\sin\\alpha=2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}=\\frac{2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{2\\tan\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\cos\\alpha=\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}=\\frac{\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{1-\\tan^2\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\tan\\alpha=\\frac{\\sin\\alpha}{\\cos\\alpha}=\\frac{2\\tan\\frac{\\alpha}{2}}{1-\\tan^2\\frac{\\alpha}{2}}\\) 例 \\(\\int\\frac{\\mathrm dx}{4-3\\sin x}\\stackrel{\\text{万能公式}}=\\int\\frac{\\mathrm dt}{2+2t^2-3t}\\stackrel{\\text{配方}}=\\dots\\stackrel{\\frac{1}{x^2+a^2}\\text{的积分}}=\\dots\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#有理函数的积分"},{"categories":null,"content":"特殊函数的积分 有理函数的积分 \\(\\int\\frac{P(x)}{Q(x)}\\mathrm dx\\) 其中\\(P(x)\\)、\\(Q(x)\\)均为多项式。 步骤 假分式\\(\\rightarrow\\)多项式\\(\\rightarrow\\)真分式 分母\\(\\rightarrow\\)一次式/二次三项式 分式\\(\\rightarrow\\)最简分式之和\\(\\rightarrow\\)逐个积分 情况 \\(\\frac{A}{(x-a)^k}\\) \\(\\frac{Cx+D}{(x^2+px+q)^k}\\) \\(\\int\\frac{Cx+D}{(x^2+px+q)^k}\\mathrm dx=\\frac{C}{2}\\int\\frac{\\mathrm d(x^2+px+q)}{(x^2+px+q)^k}+\\int\\frac{D-\\frac{Cp}{2}}{(x^2+px+q)^k}\\mathrm dx\\) 例 \\(\\frac{x^5-x^3-2x^2+7x}{x^4-x^2-2x+2}\\stackrel{\\text{化为真分式}}=x+\\frac{5x}{x^4-x^2-2x+2}\\stackrel{\\text{因式分解}}=x+\\frac{5x}{(x-1)^2(x^2+2x+2)}\\stackrel{\\text{拆（猜）项}}=x+\\frac{A}{x-1}+\\frac{B}{(x-1)^2}+\\frac{Cx+D}{x^2+2x+2}\\stackrel{\\text{待定系数}}=\\dots\\) 左右均为等式，\\(x\\)取任何值都能使等式成立（前提是形式能猜出来）。 \\(\\int\\frac{x^{11}}{x^8+3x^4+2}\\mathrm dx\\stackrel{\\text{凑}x^4}=\\frac{x^8\\mathrm dx^4}{4(x^8+3x^4+2)}\\stackrel{x^4=u}=\\dots\\) \\(I_k=\\int\\frac{\\mathrm dx}{(x^2+a)^k}\\) 递推式： \\[I_1-aI_2\\stackrel{\\text{凑纯}x^2}=\\int\\frac{x^2+a-a}{(x^2+a)^2}\\mathrm dx\\stackrel{\\text{凑}x^2+a}=\\frac{1}{2}\\int\\frac{x\\mathrm d(x^2+a)}{(x^2+a)^2}\\stackrel{\\text{把分母放到}\\mathrm d\\text{里}}=-\\frac{1}{2}\\int x\\mathrm d{\\frac{1}{x^2+a}}\\stackrel{\\text{分部积分}}=\\frac{1}{2}\\frac{1}{x^2+a}\\mathrm dx-\\frac{x}{2(x^2+a)}=\\frac{I_1}{2}-\\frac{x}{2(x^2+a)}\\] 无理函数的积分 方法 三角变换（第二换元法） 根式整体代换 例 \\(\\int\\frac{\\mathrm dx}{\\sqrt[3]{(x-1)(x+1)^2}}\\stackrel{\\text{简化分式}}=\\int\\frac{1}{x+1}\\sqrt[3]{\\frac{x+1}{x-1}}\\mathrm dx\\xrightarrow{t=\\sqrt[3]{\\frac{x+1}{x-1}}\\Rightarrow x=\\frac{t^3+1}{t^3-1}}-\\int\\frac{3}{t^3-1}\\mathrm dt=-3\\int\\frac{\\mathrm dt}{(t-1)(t^2+t+1)}\\stackrel{\\text{裂项}}=\\dots\\) 三角函数的积分 情况 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的奇数幂 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的幂的和为偶数 原则 尽量用凑微分法（第一换元法） 例 \\(\\int\\sin^2x\\cos^3x\\mathrm dx\\stackrel{\\text{放一个}\\cos x}=\\int\\sin^2x(1-\\sin^2x)\\mathrm d\\sin x=\\dots\\) 谁是奇数次幂，就把谁放一部分到后面去。 \\(\\int\\frac{\\mathrm dx}{\\sin^2x\\cos x}\\stackrel{\\text{同乘}\\cos x}=\\int\\frac{\\mathrm d\\sin x}{\\sin^2x(1-\\sin^2x)}\\stackrel{\\text{拆项}}=\\int(\\frac{1}{\\sin^2x}-\\frac{1}{1-\\sin^2x})\\mathrm dx=\\dots\\) \\(\\int\\frac{\\mathrm dx}{\\sin x\\cos^3x}\\stackrel{\\text{放}\\sec^2x}=\\int\\frac{\\mathrm d\\tan x}{\\sin x\\cos x}\\stackrel{\\text{同除}\\cos^2x}=\\int\\frac{(\\tan^2x+1)\\mathrm d\\tan x}{\\tan x}=\\dots\\) 万能代换公式 将三角函数转化为有理函数： \\[t=\\tan\\frac{x}{2}\\Rightarrow \\mathrm dx=\\frac{2\\mathrm dt}{t^2+1}\\] 万能公式 \\(\\sin\\alpha=2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}=\\frac{2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{2\\tan\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\cos\\alpha=\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}=\\frac{\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{1-\\tan^2\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\tan\\alpha=\\frac{\\sin\\alpha}{\\cos\\alpha}=\\frac{2\\tan\\frac{\\alpha}{2}}{1-\\tan^2\\frac{\\alpha}{2}}\\) 例 \\(\\int\\frac{\\mathrm dx}{4-3\\sin x}\\stackrel{\\text{万能公式}}=\\int\\frac{\\mathrm dt}{2+2t^2-3t}\\stackrel{\\text{配方}}=\\dots\\stackrel{\\frac{1}{x^2+a^2}\\text{的积分}}=\\dots\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#无理函数的积分"},{"categories":null,"content":"特殊函数的积分 有理函数的积分 \\(\\int\\frac{P(x)}{Q(x)}\\mathrm dx\\) 其中\\(P(x)\\)、\\(Q(x)\\)均为多项式。 步骤 假分式\\(\\rightarrow\\)多项式\\(\\rightarrow\\)真分式 分母\\(\\rightarrow\\)一次式/二次三项式 分式\\(\\rightarrow\\)最简分式之和\\(\\rightarrow\\)逐个积分 情况 \\(\\frac{A}{(x-a)^k}\\) \\(\\frac{Cx+D}{(x^2+px+q)^k}\\) \\(\\int\\frac{Cx+D}{(x^2+px+q)^k}\\mathrm dx=\\frac{C}{2}\\int\\frac{\\mathrm d(x^2+px+q)}{(x^2+px+q)^k}+\\int\\frac{D-\\frac{Cp}{2}}{(x^2+px+q)^k}\\mathrm dx\\) 例 \\(\\frac{x^5-x^3-2x^2+7x}{x^4-x^2-2x+2}\\stackrel{\\text{化为真分式}}=x+\\frac{5x}{x^4-x^2-2x+2}\\stackrel{\\text{因式分解}}=x+\\frac{5x}{(x-1)^2(x^2+2x+2)}\\stackrel{\\text{拆（猜）项}}=x+\\frac{A}{x-1}+\\frac{B}{(x-1)^2}+\\frac{Cx+D}{x^2+2x+2}\\stackrel{\\text{待定系数}}=\\dots\\) 左右均为等式，\\(x\\)取任何值都能使等式成立（前提是形式能猜出来）。 \\(\\int\\frac{x^{11}}{x^8+3x^4+2}\\mathrm dx\\stackrel{\\text{凑}x^4}=\\frac{x^8\\mathrm dx^4}{4(x^8+3x^4+2)}\\stackrel{x^4=u}=\\dots\\) \\(I_k=\\int\\frac{\\mathrm dx}{(x^2+a)^k}\\) 递推式： \\[I_1-aI_2\\stackrel{\\text{凑纯}x^2}=\\int\\frac{x^2+a-a}{(x^2+a)^2}\\mathrm dx\\stackrel{\\text{凑}x^2+a}=\\frac{1}{2}\\int\\frac{x\\mathrm d(x^2+a)}{(x^2+a)^2}\\stackrel{\\text{把分母放到}\\mathrm d\\text{里}}=-\\frac{1}{2}\\int x\\mathrm d{\\frac{1}{x^2+a}}\\stackrel{\\text{分部积分}}=\\frac{1}{2}\\frac{1}{x^2+a}\\mathrm dx-\\frac{x}{2(x^2+a)}=\\frac{I_1}{2}-\\frac{x}{2(x^2+a)}\\] 无理函数的积分 方法 三角变换（第二换元法） 根式整体代换 例 \\(\\int\\frac{\\mathrm dx}{\\sqrt[3]{(x-1)(x+1)^2}}\\stackrel{\\text{简化分式}}=\\int\\frac{1}{x+1}\\sqrt[3]{\\frac{x+1}{x-1}}\\mathrm dx\\xrightarrow{t=\\sqrt[3]{\\frac{x+1}{x-1}}\\Rightarrow x=\\frac{t^3+1}{t^3-1}}-\\int\\frac{3}{t^3-1}\\mathrm dt=-3\\int\\frac{\\mathrm dt}{(t-1)(t^2+t+1)}\\stackrel{\\text{裂项}}=\\dots\\) 三角函数的积分 情况 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的奇数幂 函数各项含\\(\\sin x\\)、\\(\\cos x\\)的幂的和为偶数 原则 尽量用凑微分法（第一换元法） 例 \\(\\int\\sin^2x\\cos^3x\\mathrm dx\\stackrel{\\text{放一个}\\cos x}=\\int\\sin^2x(1-\\sin^2x)\\mathrm d\\sin x=\\dots\\) 谁是奇数次幂，就把谁放一部分到后面去。 \\(\\int\\frac{\\mathrm dx}{\\sin^2x\\cos x}\\stackrel{\\text{同乘}\\cos x}=\\int\\frac{\\mathrm d\\sin x}{\\sin^2x(1-\\sin^2x)}\\stackrel{\\text{拆项}}=\\int(\\frac{1}{\\sin^2x}-\\frac{1}{1-\\sin^2x})\\mathrm dx=\\dots\\) \\(\\int\\frac{\\mathrm dx}{\\sin x\\cos^3x}\\stackrel{\\text{放}\\sec^2x}=\\int\\frac{\\mathrm d\\tan x}{\\sin x\\cos x}\\stackrel{\\text{同除}\\cos^2x}=\\int\\frac{(\\tan^2x+1)\\mathrm d\\tan x}{\\tan x}=\\dots\\) 万能代换公式 将三角函数转化为有理函数： \\[t=\\tan\\frac{x}{2}\\Rightarrow \\mathrm dx=\\frac{2\\mathrm dt}{t^2+1}\\] 万能公式 \\(\\sin\\alpha=2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}=\\frac{2\\sin\\frac{\\alpha}{2}\\cos\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{2\\tan\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\cos\\alpha=\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}=\\frac{\\cos^2\\frac{\\alpha}{2}-\\sin^2\\frac{\\alpha}{2}}{\\sin^2\\frac{\\alpha}{2}+\\cos^2\\frac{\\alpha}{2}}=\\frac{1-\\tan^2\\frac{\\alpha}{2}}{1+\\tan^2\\frac{\\alpha}{2}}\\) \\(\\tan\\alpha=\\frac{\\sin\\alpha}{\\cos\\alpha}=\\frac{2\\tan\\frac{\\alpha}{2}}{1-\\tan^2\\frac{\\alpha}{2}}\\) 例 \\(\\int\\frac{\\mathrm dx}{4-3\\sin x}\\stackrel{\\text{万能公式}}=\\int\\frac{\\mathrm dt}{2+2t^2-3t}\\stackrel{\\text{配方}}=\\dots\\stackrel{\\frac{1}{x^2+a^2}\\text{的积分}}=\\dots\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:3:5","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#三角函数的积分"},{"categories":null,"content":"级数 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:4:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#级数"},{"categories":null,"content":"和函数 和函数 幂级数 定义域 \\(\\frac{1}{1-x}\\) \\(\\sum_{n=0}^{\\infty} x^{n}=1+x+x^{2}+\\ldots \\ldots+x^{n}\\) \\((-1\u003cx\u003c1)\\) \\(\\frac{1}{1+x}\\) \\(\\sum_{n=0}^{\\infty}(-1)^{n} x^{n}=1-x+x^{2}+\\ldots \\ldots+(-1)^{n} x^{n}\\) \\((-1\u003cx\u003c1)\\) \\(\\ln (1+x)\\) \\(\\sum_{n=0}^{\\infty}(-1)^{n} \\frac{x^{n+1}}{n+1}=x-\\frac{x^{2}}{2}+\\frac{x^{3}}{3}+\\ldots \\ldots+(-1)^{n} \\frac{x^{n+1}}{n+1}\\) \\((-1\u003cx \\leq 1)\\) \\(e^{x}\\) \\(\\sum_{n=0}^{\\infty} \\frac{1}{n !} x^{n}=1+x+\\frac{x^{2}}{2 !}+\\ldots \\ldots+\\frac{x^{n}}{n !}\\) \\((-\\infty\u003cx\u003c+\\infty)\\) \\(\\sin x\\) \\(\\sum_{n=0}^{\\infty}(-1)^{n} \\frac{x^{2 n+1}}{(2 n+1) !}=x-\\frac{x^{3}}{3 !}+\\frac{x^{5}}{5 !} \\ldots \\ldots+(-1)^{n} \\frac{x^{2 n+1}}{(2 n+1) !}\\) \\((-\\infty\u003cx\u003c+\\infty)\\) \\(\\cos x\\) \\(\\sum_{n=0}^{\\infty}(-1)^{n} \\frac{x^{2 n}}{(2 n) !}=1-\\frac{x^{2}}{2}+\\ldots \\ldots+(-1)^{n} \\frac{x^{2 n}}{(2 n) !}\\) \\((-\\infty\u003cx\u003c+\\infty)\\) ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:4:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#和函数"},{"categories":null,"content":"技巧 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:5:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#技巧"},{"categories":null,"content":"裂项 \\[\\frac{k}{a_n\\cdot b_n}=\\frac{k}{b_n-a_n}(\\frac{1}{a_n}-\\frac{1}{b_n})\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:5:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#裂项"},{"categories":null,"content":"杂项 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:6:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#杂项"},{"categories":null,"content":"三角不等式 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:6:1","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#三角不等式"},{"categories":null,"content":"范数 https://zhuanlan.zhihu.com/p/67120415 范数是一种强化了的距离概念（只要满足非负、自反、三角不等式就可以称之为距离），它在定义上比距离多了一条数乘的运算法则。便于理解，可以把范数当作距离来理解。 L-P范数 不是一个范数，而是不同\\(P\\)取值的一组范数： \\[L_{p}=\\|\\mathbf{x}\\|_{p}=\\sqrt[p]{\\sum_{i=1}^{n} x_{i}^{p}}, \\mathbf{x}=\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)\\] 随着\\(P\\)的不同： L0范数 不是一个真正的范数，但可以衡量一个向量里非零元素的个数： \\[\\|\\mathbf{x}\\|_{0}=\\sqrt[0]{\\sum_{i=1}^{n} x_{i}^{0}}\\] 即： \\[\\|x\\|_{0}=\\#\\left(i \\mid x_{i} \\neq 0\\right)\\] L1范数 \\[\\|x\\|_{1}=\\sum_{i=1}^{n}\\left|x_{i}\\right|\\] L2范数 \\[\\|x\\|_{2}=\\sqrt{\\sum_{i=1}^{n}x_{i}^2}\\] Frobenius 范数 \\[\\|A\\|_{F}=\\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n}\\left|a_{i j}\\right|^{2}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:6:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#范数"},{"categories":null,"content":"范数 https://zhuanlan.zhihu.com/p/67120415 范数是一种强化了的距离概念（只要满足非负、自反、三角不等式就可以称之为距离），它在定义上比距离多了一条数乘的运算法则。便于理解，可以把范数当作距离来理解。 L-P范数 不是一个范数，而是不同\\(P\\)取值的一组范数： \\[L_{p}=\\|\\mathbf{x}\\|_{p}=\\sqrt[p]{\\sum_{i=1}^{n} x_{i}^{p}}, \\mathbf{x}=\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)\\] 随着\\(P\\)的不同： L0范数 不是一个真正的范数，但可以衡量一个向量里非零元素的个数： \\[\\|\\mathbf{x}\\|_{0}=\\sqrt[0]{\\sum_{i=1}^{n} x_{i}^{0}}\\] 即： \\[\\|x\\|_{0}=\\#\\left(i \\mid x_{i} \\neq 0\\right)\\] L1范数 \\[\\|x\\|_{1}=\\sum_{i=1}^{n}\\left|x_{i}\\right|\\] L2范数 \\[\\|x\\|_{2}=\\sqrt{\\sum_{i=1}^{n}x_{i}^2}\\] Frobenius 范数 \\[\\|A\\|_{F}=\\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n}\\left|a_{i j}\\right|^{2}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:6:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#l-p范数"},{"categories":null,"content":"范数 https://zhuanlan.zhihu.com/p/67120415 范数是一种强化了的距离概念（只要满足非负、自反、三角不等式就可以称之为距离），它在定义上比距离多了一条数乘的运算法则。便于理解，可以把范数当作距离来理解。 L-P范数 不是一个范数，而是不同\\(P\\)取值的一组范数： \\[L_{p}=\\|\\mathbf{x}\\|_{p}=\\sqrt[p]{\\sum_{i=1}^{n} x_{i}^{p}}, \\mathbf{x}=\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)\\] 随着\\(P\\)的不同： L0范数 不是一个真正的范数，但可以衡量一个向量里非零元素的个数： \\[\\|\\mathbf{x}\\|_{0}=\\sqrt[0]{\\sum_{i=1}^{n} x_{i}^{0}}\\] 即： \\[\\|x\\|_{0}=\\#\\left(i \\mid x_{i} \\neq 0\\right)\\] L1范数 \\[\\|x\\|_{1}=\\sum_{i=1}^{n}\\left|x_{i}\\right|\\] L2范数 \\[\\|x\\|_{2}=\\sqrt{\\sum_{i=1}^{n}x_{i}^2}\\] Frobenius 范数 \\[\\|A\\|_{F}=\\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n}\\left|a_{i j}\\right|^{2}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:6:2","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#frobenius-范数"},{"categories":null,"content":"正态分布 \\[N(\\mu,\\sigma^2)\\] \\(\\mu\\)：平均值/期望 \\(\\sigma^2\\)：方差 ","date":"2022-03-02","objectID":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/:7:0","series":null,"tags":["数学"],"title":"高等数学","uri":"/posts/notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/#正态分布"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:0:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#"},{"categories":null,"content":"限幅滤波法（判断滤波法） 设置一个阈值，当一次数据与上次数据的偏差小于这个阈值时才算入测量的数据，否则使用上一次测量的数据。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#限幅滤波法-判断滤波法"},{"categories":null,"content":"优点 避免偶然因素引起的干扰。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:1:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 无法克服周期性的干扰。 平滑度差。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:1:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"中位值滤波法 连续采样N次，取中位数作为本次测量结果。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:2:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#中位值滤波法"},{"categories":null,"content":"优点 能有效克服因偶然因素引起的波动干扰。 对温度、液位等 变化缓慢的被测参数 有良好的滤波效果。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:2:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 不适合用于流量、速度等快速变化的参数。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:2:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"算术平均滤波法 连续采样N次，取平均数作为本次测量结果。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:3:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#算术平均滤波法"},{"categories":null,"content":"优点 适合用于随机干扰信号的滤波。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:3:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 测量速度慢。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:3:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"递推平均滤波法（滑动平均滤波法） 维护一个采样数据的队列，取队列中的平均值。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:4:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#递推平均滤波法-滑动平均滤波法"},{"categories":null,"content":"优点 能比较好地抑制周期性干扰。 平滑度高。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:4:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 灵敏度低，不好抑制偶然的脉冲性干扰 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:4:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"中位值平均滤波法（防脉冲干扰平均滤波法） 连续采样N次，取消最大值和最小值后，剩下的数据求平均作为测量结果。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:5:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#中位值平均滤波法-防脉冲干扰平均滤波法"},{"categories":null,"content":"优点 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:5:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:5:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"限幅平均滤波法 把所有测量数据先进行限幅滤波，再进行递推平均滤波。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:6:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#限幅平均滤波法"},{"categories":null,"content":"优点 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:6:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:6:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"一阶滞后滤波法 取\\(k\\in[0,1]\\)，设采样值为\\(a_n\\)，测量结果\\(f(n)=k\\cdot a_n+(1-k)f(n-1)\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:7:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#一阶滞后滤波法"},{"categories":null,"content":"优点 能比较好地抑制周期性干扰。 适用于波动频率高的场合。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:7:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 相位滞后，灵敏度低。 无法消除频率高于采样频率\\(\\frac{1}{2}\\)的信号。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:7:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"加权递推平均滤波法 在递推平均的基础上，对不同的数据采用不同的权，越早的数据权越小。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:8:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#加权递推平均滤波法"},{"categories":null,"content":"优点 适用于有较大纯滞后时间常数的对象，和采样周期较短的系统。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:8:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 不适用于对于纯滞后时间常数较小、采样周期较长、变化缓慢的信号。 灵敏度低。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:8:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"消抖滤波法 counter = 0 counter_size = 10 result = 0 last_x = 0 def filter(x): if x == last_x: counter = 0 result = x else: counter = (counter + 1) % counter_size if counter == 0: result = x last_x = x ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:9:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#消抖滤波法"},{"categories":null,"content":"优点 对于变化缓慢的被测参数有较好的滤波效果。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:9:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 不适用于快速变化的参数。 计数器溢出的那一刻可能将干扰值作为有效值输入。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:9:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"限幅消抖滤波法 先使用限幅滤波，再使消抖滤波。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:10:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#限幅消抖滤波法"},{"categories":null,"content":"优点 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:10:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#优点"},{"categories":null,"content":"缺点 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:10:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#缺点"},{"categories":null,"content":"卡尔曼滤波 目标：从获取的多个不精确的数据中尽可能地获得有用信息。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:11:0","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#卡尔曼滤波"},{"categories":null,"content":"例子 - 速度与位置的关系 基本量 \\(\\hat{\\mathbf x_k}=\\begin{bmatrix}p_k\\\\v_k\\end{bmatrix}=\\begin{bmatrix}\\text{position}\\\\text{velocity}\\end{bmatrix}\\) 在k时刻物体的位置和速度组成的向量 变化 基本变化 \\(\\begin{array}{rlr}p_{k} \u0026 = p_{k-1}+\u0026 \\Delta t v_{k-1} \\\\v_{k} \u0026 = \u0026v_{k-1}\\end{array}\\Rightarrow\\begin{aligned} \\hat{\\mathbf{x}}_{k} \u0026=\\left[\\begin{array}{cc} 1 \u0026 \\Delta t \\\\ 0 \u0026 1 \\end{array}\\right] \\hat{\\mathbf{x}}_{k-1} \\\\ \u0026=\\mathbf{F}_{k} \\hat{\\mathbf{x}}_{k-1} \\end{aligned}\\) 外部影响 \\(\\begin{aligned} p_{k} \u0026 = p_{k-1}+\\Delta t v_{k-1}+\\frac{1}{2} a \\Delta t^{2} \\\\ v_{k} \u0026=\\quad v_{k-1}+a \\Delta t \\end{aligned}\\Rightarrow \\begin{aligned} \\hat{\\mathbf{x}}_{k} \u0026=\\mathbf{F}_{k} \\hat{\\mathbf{x}}_{k-1}+\\left[\\begin{array}{c} \\frac{\\Delta t^{2}}{2} \\\\ \\Delta t \\end{array}\\right] a \\\\ \u0026=\\mathbf{F}_{k} \\hat{\\mathbf{x}}_{k-1}+\\mathbf{B}_{k} \\overrightarrow{\\mathbf{u}}_{k} \\end{aligned}\\) \\(a\\)：已知加速度假设已经知道外部因素（比如风力、物体本身的动力）改变了物体的加速度 \\(B_k\\)：控制矩阵 \\(\\vec u_k\\)：控制向量 最佳的状态预测 是基于 直接由上一个状态得到预测 和 已知的外部影响 得到的预测 \\(\\mathbf P_k=\\begin{bmatrix}\\Sigma_{pp}\u0026\\Sigma_{pv}\\\\Sigma_{vp}\u0026\\Sigma_{vv}\\end{bmatrix}\\) 速度和位置的协方差矩阵 元素 \\(\\Sigma\\)：什么和什么的协方差 \\(p\\): 位置 \\(v\\): 速度 变化 基本变化 \\(\\begin{aligned} \\hat{\\mathbf{x}}_{k} \u0026=\\mathbf{F}_{k} \\hat{\\mathbf{x}}_{k-1} \\\\ \\mathbf{P}_{k} \u0026=\\mathbf{F}_{\\mathbf{k}} \\mathbf{P}_{k-1} \\mathbf{F}_{k}^{T} \\end{aligned}\\Leftarrow \\begin{aligned} \\operatorname{Cov}(x) \u0026=\\Sigma \\\\ \\operatorname{Cov}(\\mathbf{A} x) \u0026=\\mathbf{A} \\Sigma \\mathbf{A}^{T} \\end{aligned} \\) 外部影响 \\(\\begin{aligned} \\hat{\\mathbf{x}}_{k} \u0026=\\mathbf{F}_{k} \\hat{\\mathbf{x}}_{k-1}+\\mathbf{B}_{k} \\overrightarrow{\\mathbf{u}_{k}} \\\\ \\mathbf{P}_{k} \u0026=\\mathbf{F}_{\\mathbf{k}} \\mathbf{P}_{k-1} \\mathbf{F}_{k}^{T}+\\mathbf{Q}_{k} \\end{aligned}\\) \\(Q_k\\)：表示方差为\\(Q_k\\)的高斯噪声，作为不确定性因素把上一个分布用于预测的每一个点都移动到预测后符合方差为\\(Q_K\\)的高斯分布里： 产生一个新的高斯分布： 新的不确定性 是基于 由上一个状态得到的不确定性 和 外部环境的不确定性 得到的预测 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:11:1","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#例子-速度与位置的关系"},{"categories":null,"content":"应用 - 传感器读数的噪声 在一个时间点，有两种 独立 的方式获得测量数据的分布： 推测 \\(\\begin{aligned} \\vec{\\mu}_{\\text {expected }} \u0026=\\mathbf{H}_{k} \\hat{\\mathbf{x}}_{k} \\\\ \\mathbf{\\Sigma}_{\\text {expected }} \u0026=\\mathbf{H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T} \\end{aligned}\\) \\(\\mu\\)：读数均值 \\(\\mathbf\\Sigma\\)：协方差矩阵 \\(\\hat{\\mathbf x_b}\\)： 推测的状态值 \\(\\mathbf H_k\\)：传感器建模矩阵（传感器测量范围和单位的可能和主机所使用的不一致，所以需要一个矩阵把当前主机的状态值变换为传感器读取的值） 观测 \\(\\bar z_k\\)：读数的平均值 \\(R_k\\)：读数的方差 如果有两个相互独立的获取系统状态的方式，并且得到两者都准确的概率值，只需要将两者相乘 相乘后得到新的均值和协方差 使用高斯乘法得到新的分布 \\[\\mathcal{N}\\left(x, \\mu_{0}, \\sigma_{0}\\right) \\cdot \\mathcal{N}\\left(x, \\mu_{1}, \\sigma_{1}\\right) \\stackrel{?}{ = } \\mathcal{N}\\left(x, \\mu^{\\prime}, \\sigma^{\\prime}\\right)\\] 其中 \\[\\mathcal{N}(x, \\mu, \\sigma)=\\frac{1}{\\sigma \\sqrt{2 \\pi}} e^{-\\frac{(x-\\mu)^{2}}{2 \\sigma^{2}}}\\] 相乘后的结果 \\[\\begin{aligned} μ′ \u0026=μ0+\\frac{σ02\\left(μ1-μ0\\right)}{σ02+σ12} σ′ 2 \u0026=σ02-\\frac{σ04}{σ02+σ12} \\end{aligned}\\] 提取\\(\\mu^\\prime\\)和\\({\\sigma^\\prime}^2\\)的公共部分\\(\\mathbf k\\) \\[\\begin{aligned} \\mathbf{k} \u0026=\\frac{\\sigma_{0}^{2}}{\\sigma_{0}^{2}+\\sigma_{1}^{2}} \\\\ \\mu^{\\prime} \u0026=\\mu_{0}+\\mathbf{k}\\left(\\mu_{1}-\\mu_{0}\\right) \\\\ \\sigma^{\\prime 2} \u0026=\\sigma_{0}^{2}-\\mathbf{k} \\sigma_{0}^{2} \\end{aligned}\\] 上述过程针对的是一维高斯分布的相乘，推广到多维，将上述式子表示为矩阵和向量的形式 \\[\\begin{aligned} \\mathbf{K}\u0026=\\Sigma_{0}\\left(\\Sigma_{0}+\\Sigma_{1}\\right)^{-1} \\\\ \\vec{\\mu}^{\\prime}\u0026=\\overrightarrow{\\mu_{0}}+\\mathbf{K}\\left(\\overrightarrow{\\mu_{1}}-\\overrightarrow{\\mu_{0}}\\right) \\\\ \\Sigma^{\\prime}\u0026=\\Sigma_{0}-\\mathbf{K} \\Sigma_{0} \\end{aligned}\\] 其中\\(K\\)被称为卡尔曼增益将\\(\\left(\\mu_{0}, \\Sigma_{0}\\right)=\\left(\\mathbf{H}_{k} \\hat{\\mathbf{x}}_{k}, \\mathbf{H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T}\\right)\\)和\\(\\left(\\mu_{1}, \\Sigma_{1}\\right)=\\left(\\mathbf{z}_{k}^{\\prime}, \\mathbf{R}_{k}\\right)\\)代入上述式子可得 \\[\\begin{aligned} \\mathbf{K}\u0026=\\mathbf{H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T}\\left(\\mathbf{H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T}+\\mathbf{R}_{k}\\right)^{-1}\\\\ \\mathbf{H}_{k} \\hat{\\mathbf{x}}_{k}^{\\prime} \u0026=\\mathbf{H}_{k} \\hat{\\mathbf{x}}_{k}+\\mathbf{K}\\left(\\overrightarrow{\\mathbf{z}_{k}}-\\mathbf{H}_{k} \\hat{\\mathbf{x}}_{k}\\right) \\\\ \\mathbf{H}_{k} \\mathbf{P}_{k}^{\\prime} \\mathbf{H}_{k}^{T} \u0026=\\mathbf{H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T}-\\mathbf{K H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T} \\end{aligned}\\] 移项化简得 \\[\\begin{aligned} \\mathbf{K}^{\\prime}\u0026=\\mathbf{P}_{k} \\mathbf{H}_{k}^{T}\\left(\\mathbf{H}_{k} \\mathbf{P}_{k} \\mathbf{H}_{k}^{T}+\\mathbf{R}_{k}\\right)^{-1}\\\\ \\hat{\\mathbf{x}}_{k}^{\\prime} \u0026=\\hat{\\mathbf{x}}_{k}+\\mathbf{K}^{\\prime}\\left(\\overrightarrow{\\mathbf{z}_{k}}-\\mathbf{H}_{k} \\hat{\\mathbf{x}}_{k}\\right) \\\\ \\mathbf{P}_{k}^{\\prime} \u0026=\\mathbf{P}_{k}-\\mathbf{K}^{\\prime} \\mathbf{H}_{k} \\mathbf{P}_{k} \\end{aligned}\\] 其中 \\(\\hat{\\mathbf x_k}^\\prime\\)为本次更新的最佳预测值。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/:11:2","series":null,"tags":["嵌入式"],"title":"滤波算法","uri":"/posts/notes/%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/#应用-传感器读数的噪声"},{"categories":null,"content":"下标说明： 下标 含义 \\(I_B\\) 直流 \\(i_B\\) 既有直流又有交流 \\(i_b\\) 交流 \\(\\dot I_b\\) 正弦交流的相量 \\(I_b\\) 正弦交流的有效值 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:0:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#"},{"categories":null,"content":"半导体 N型半导体和P型半导体都是不带电的，在PN结中当多数载流子扩散后自然形成电场，阻碍多子扩散的继续。外加电场可以削弱这个电场，使得多子继续扩散，PN结就具有了单向导电性。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#半导体"},{"categories":null,"content":"本征激发 外部能量（温度）激发产生电子、空穴的过程，形成少数载流子。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#本征激发"},{"categories":null,"content":"禁带宽度 摆脱共价键的约束，价电子获得的最小能量。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#禁带宽度"},{"categories":null,"content":"载流子 自由电子（负电）和空穴（正电）。 多数载流子 掺杂元素带来的载流子。 少数载流子 本征激发产生的载流子。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#载流子"},{"categories":null,"content":"载流子 自由电子（负电）和空穴（正电）。 多数载流子 掺杂元素带来的载流子。 少数载流子 本征激发产生的载流子。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#多数载流子"},{"categories":null,"content":"载流子 自由电子（负电）和空穴（正电）。 多数载流子 掺杂元素带来的载流子。 少数载流子 本征激发产生的载流子。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#少数载流子"},{"categories":null,"content":"N型半导体 掺杂少量五价元素。原子处在晶格中，能连接的键是有限的，因此有自由电子。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#n型半导体"},{"categories":null,"content":"P型半导体 掺杂少量三价元素，存在空穴。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#p型半导体"},{"categories":null,"content":"漂移电流 载流子在外电场的作用下定向运动。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:6","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#漂移电流"},{"categories":null,"content":"扩散电流 两种载流子浓度不均匀，高浓度向低浓度扩散产生的电流。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:7","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#扩散电流"},{"categories":null,"content":"PN结 一边是P型半导体，一边是N型半导体。 伏安特性 正向特性外部正向加上电压，将很容易抵消并强于内部的垒势电压使得多数载流子的扩散运动增强。 反向特性外部反向加上电压，加强内部的垒势电压，使得少数载流子的漂移运动增强。 正偏 P接正，N接负。 反偏 P接负，N接正。 反向饱和电流 少数载流子由本征激发产生，数量较少且恒定。因此在外部加上反向电压时，形成的反向电流很容易饱和。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:8","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#pn结"},{"categories":null,"content":"PN结 一边是P型半导体，一边是N型半导体。 伏安特性 正向特性外部正向加上电压，将很容易抵消并强于内部的垒势电压使得多数载流子的扩散运动增强。 反向特性外部反向加上电压，加强内部的垒势电压，使得少数载流子的漂移运动增强。 正偏 P接正，N接负。 反偏 P接负，N接正。 反向饱和电流 少数载流子由本征激发产生，数量较少且恒定。因此在外部加上反向电压时，形成的反向电流很容易饱和。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:8","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#正偏"},{"categories":null,"content":"PN结 一边是P型半导体，一边是N型半导体。 伏安特性 正向特性外部正向加上电压，将很容易抵消并强于内部的垒势电压使得多数载流子的扩散运动增强。 反向特性外部反向加上电压，加强内部的垒势电压，使得少数载流子的漂移运动增强。 正偏 P接正，N接负。 反偏 P接负，N接正。 反向饱和电流 少数载流子由本征激发产生，数量较少且恒定。因此在外部加上反向电压时，形成的反向电流很容易饱和。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:8","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#反偏"},{"categories":null,"content":"空间电荷区 扩散电流导致PN结交界处的空穴和自由电子复合。空间电荷区会形成电场，因为原来原子是电中性的，电子和空穴移动后会就不再是电中性了。这将有利于少数载流子的漂移运动产生漂移电流，与扩散电流形成动态平衡。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:9","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#空间电荷区"},{"categories":null,"content":"垒势电压 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:10","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#垒势电压"},{"categories":null,"content":"微变等效电路 小信号变化下，二极管的非线性特性可以忽略不计，等效于一个电阻。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:11","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#微变等效电路"},{"categories":null,"content":"二极管 主要参数： 最大整流电流 \\(I_F\\)：二极管长期运行最大正向平均电流。 反向击穿电压 \\(V_{RM}\\)：击穿时反向电流剧增，导致二极管烧坏。 最高工作频率 \\(f_m\\)：因为PN结有结电容效应，过高的频率会导致二极管的单向导通特性失效。 特性： PN结电流方程： \\[i_D=I_S\\left(e^{\\frac{u_D}{U_T}}-1\\right)\\] \\(I_S\\)：（反向）饱和电流 \\(U_T=\\frac{kT}{q}\\)：等效电压（常温下为\\(26\\text{mV}\\)） \\(k\\)：波尔兹曼常数 \\(q\\)：电子的电量 \\(u_D\\)：PN结两端的电压 \\(i_D\\)：PN结的电流 工作状态： 判断方法： 假设导通：假设一个二极管导通，然后其他二极管的导通情况，看看有没有可能成立（因为二极管的导通压降是一定的，多个二极管同时导通可能使得一个节点的电压不一致产生冲突）。 开路电压：假设所有二极管都开路，求每个二极管的两端的开路电压，压差大的导通优先级高。 稳压二极管 调整二极管的击穿电压低于导致烧毁的电压。反向击穿后无论电流怎么变化，电压基本不变，并且一定范围内的反向击穿是可恢复的。稳压二极管在使用时必须并联限流电阻。 稳压原理 当负载两端的电压有减小趋势的时候，稳压管会减小流过自身的电流以减小限流电阻的分压，相当于增大自身的电阻；当负载两端的电压有增大趋势的时候，稳压管会增大流过自身的电流以增大限流电阻的分压，相当于减小自身的电阻； 符号 等效电路 伏安特性 稳定电压\\(U_\\mathrm{Z}\\) 稳压管的击穿电压。 稳定电流\\(I_\\mathrm{Z}\\) 使稳压管工作在稳压状态的最小电流。 最大稳压电流\\(I_\\mathrm{ZM}\\) 稳压管不至于损坏的最大电流。 最大耗散功率\\(P_\\mathrm{ZM}\\) 允许的最大功率： \\[P_\\mathrm{ZM}=I_\\mathrm{ZM}U_\\mathrm{Z}\\] 动态电阻\\(r_\\mathrm{Z}\\) 工作在稳定状态时，\\(r_\\mathrm{Z}=\\frac{\\Delta U}{\\Delta I}\\)。 发光二极管 导通电压比普通二极管要大，并且随着电流的增加，发出的光强也增加。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:12","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#二极管"},{"categories":null,"content":"二极管 主要参数： 最大整流电流 \\(I_F\\)：二极管长期运行最大正向平均电流。 反向击穿电压 \\(V_{RM}\\)：击穿时反向电流剧增，导致二极管烧坏。 最高工作频率 \\(f_m\\)：因为PN结有结电容效应，过高的频率会导致二极管的单向导通特性失效。 特性： PN结电流方程： \\[i_D=I_S\\left(e^{\\frac{u_D}{U_T}}-1\\right)\\] \\(I_S\\)：（反向）饱和电流 \\(U_T=\\frac{kT}{q}\\)：等效电压（常温下为\\(26\\text{mV}\\)） \\(k\\)：波尔兹曼常数 \\(q\\)：电子的电量 \\(u_D\\)：PN结两端的电压 \\(i_D\\)：PN结的电流 工作状态： 判断方法： 假设导通：假设一个二极管导通，然后其他二极管的导通情况，看看有没有可能成立（因为二极管的导通压降是一定的，多个二极管同时导通可能使得一个节点的电压不一致产生冲突）。 开路电压：假设所有二极管都开路，求每个二极管的两端的开路电压，压差大的导通优先级高。 稳压二极管 调整二极管的击穿电压低于导致烧毁的电压。反向击穿后无论电流怎么变化，电压基本不变，并且一定范围内的反向击穿是可恢复的。稳压二极管在使用时必须并联限流电阻。 稳压原理 当负载两端的电压有减小趋势的时候，稳压管会减小流过自身的电流以减小限流电阻的分压，相当于增大自身的电阻；当负载两端的电压有增大趋势的时候，稳压管会增大流过自身的电流以增大限流电阻的分压，相当于减小自身的电阻； 符号 等效电路 伏安特性 稳定电压\\(U_\\mathrm{Z}\\) 稳压管的击穿电压。 稳定电流\\(I_\\mathrm{Z}\\) 使稳压管工作在稳压状态的最小电流。 最大稳压电流\\(I_\\mathrm{ZM}\\) 稳压管不至于损坏的最大电流。 最大耗散功率\\(P_\\mathrm{ZM}\\) 允许的最大功率： \\[P_\\mathrm{ZM}=I_\\mathrm{ZM}U_\\mathrm{Z}\\] 动态电阻\\(r_\\mathrm{Z}\\) 工作在稳定状态时，\\(r_\\mathrm{Z}=\\frac{\\Delta U}{\\Delta I}\\)。 发光二极管 导通电压比普通二极管要大，并且随着电流的增加，发出的光强也增加。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:12","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#稳压二极管"},{"categories":null,"content":"二极管 主要参数： 最大整流电流 \\(I_F\\)：二极管长期运行最大正向平均电流。 反向击穿电压 \\(V_{RM}\\)：击穿时反向电流剧增，导致二极管烧坏。 最高工作频率 \\(f_m\\)：因为PN结有结电容效应，过高的频率会导致二极管的单向导通特性失效。 特性： PN结电流方程： \\[i_D=I_S\\left(e^{\\frac{u_D}{U_T}}-1\\right)\\] \\(I_S\\)：（反向）饱和电流 \\(U_T=\\frac{kT}{q}\\)：等效电压（常温下为\\(26\\text{mV}\\)） \\(k\\)：波尔兹曼常数 \\(q\\)：电子的电量 \\(u_D\\)：PN结两端的电压 \\(i_D\\)：PN结的电流 工作状态： 判断方法： 假设导通：假设一个二极管导通，然后其他二极管的导通情况，看看有没有可能成立（因为二极管的导通压降是一定的，多个二极管同时导通可能使得一个节点的电压不一致产生冲突）。 开路电压：假设所有二极管都开路，求每个二极管的两端的开路电压，压差大的导通优先级高。 稳压二极管 调整二极管的击穿电压低于导致烧毁的电压。反向击穿后无论电流怎么变化，电压基本不变，并且一定范围内的反向击穿是可恢复的。稳压二极管在使用时必须并联限流电阻。 稳压原理 当负载两端的电压有减小趋势的时候，稳压管会减小流过自身的电流以减小限流电阻的分压，相当于增大自身的电阻；当负载两端的电压有增大趋势的时候，稳压管会增大流过自身的电流以增大限流电阻的分压，相当于减小自身的电阻； 符号 等效电路 伏安特性 稳定电压\\(U_\\mathrm{Z}\\) 稳压管的击穿电压。 稳定电流\\(I_\\mathrm{Z}\\) 使稳压管工作在稳压状态的最小电流。 最大稳压电流\\(I_\\mathrm{ZM}\\) 稳压管不至于损坏的最大电流。 最大耗散功率\\(P_\\mathrm{ZM}\\) 允许的最大功率： \\[P_\\mathrm{ZM}=I_\\mathrm{ZM}U_\\mathrm{Z}\\] 动态电阻\\(r_\\mathrm{Z}\\) 工作在稳定状态时，\\(r_\\mathrm{Z}=\\frac{\\Delta U}{\\Delta I}\\)。 发光二极管 导通电压比普通二极管要大，并且随着电流的增加，发出的光强也增加。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:12","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#发光二极管"},{"categories":null,"content":"三极管 结构： 基区：薄且掺杂浓度低。 发射区：掺杂浓度很高。 集电区：空间大。 主要参数（共射）： 放大倍数：非理想三极管的放大倍数在工作区中不是处处相等的。 直流参数：\\(I_c=\\bar\\beta I_B +(1 + \\bar\\beta)I_{CBO}=\\bar\\beta I_B + I_{CEO}\\Rightarrow \\bar\\beta = \\frac{I_C}{I_B}\\) \\(I_{CBO}\\) 穿透电流\\(I_{CEO}\\)：理想状态下，基极无电流时，C、E极间加上工作电压，CE极间电流电压=0。实际上有微弱电流通过，这就是穿透电流。穿透电流大小与管子性能有关，但一般可以小到可以忽略不计。 \\(\\bar\\beta\\)：直流电流放大系数 交流参数 \\(\\beta = \\frac{\\Delta I_C}{\\Delta I_B}\\)：交流放大倍数 \\(f_T\\)：使\\(\\beta=1\\)的信号频率 对变化量的具有放大作用。 极限参数 \\(I_{CM}\\)：最大集电极电流 \\(P_{CM}=i_C u_{CE}\\)：最大集电极耗散功率 \\(U_{(BR)CEO}\\)：c-e间的击穿电压（处于反偏的结超过一定电压后就会被击穿） 放大作用 原理 发射极电流的形成：因发射区多子浓度高使大量电子从发射区扩散到基区形成扩散电流。 基极电流的形成：发射极中的电子和基区的空穴产生的复合电流。由于基区很薄，扩散过来的少子不会在此储存，而是复合或漂移到集电区。由于基区薄且多子（空穴）浓度低，该电流很小。可以理解为基极的电压只是为了降低能量壁垒，电子只要能克服这个能量壁垒即可快速迁移到集电区，与基极空穴复合的电子与漂移的电子是成比例的。基区空穴浓度很小，使得复合的电子远小于漂移的电子。 集电极电流的形成：载流子的集电区面积大，在外电场作用下，大部分扩散到基区的电子漂移到集电区。由于基区掺杂浓度很低，扩散到基区的少子浓度多于基区多子浓度，在外电场的作用下，可以漂移到集电区。 条件： 发射结正偏：\\(u_{BE}\u003eU_\\text{on}\\) 集电结反偏：\\(u_{CE}\\geq 0\\)，即\\(u_\\text{CE}\\geq u_\\text{BE}\\) 特性： 共射输入特性： \\(i_B=f(u_{BE})\\Large|_{U_{CE}}\\)的特性曲线（不同曲线的\\(U_{CE}\\)不同）： \\(U_{CE}\\)增大曲线右移：当\\(U_{CE}\\)增大的时候，集电区的电场强度增强，集电极收集电子的能力也增强， \\(I_C\\)增大，导致\\(I_B\\)减小。也就是说集电极的电压较高的情况下，基极加较小的电压也能达到相同的电流。当\\(U_{CE}\\)足够大，把电子几乎都收集完之后，再升高\\(U_{CE}\\)，收集电子的数目不会发生明显变化，因此\\(U_{CE}\\)再升高，曲线右移幅度也很小。对于小功率晶体管而言，可以近似地用一条\\(U_{CE}\u003e1V\\)的曲线来代替之后所有\\(U_{CE}\\)的曲线。也就是说集电极电压升高到一定程度后，基极电流和基极电压的关系就比较确定了，放大倍数一定的情况下，集电极电流和基极电压的关系也可以确定。 输出特性： \\(i_C=f(u_{CE})\\Large|_{I_B}\\) 三极管的三个工作区： 状态 \\(u_{BE}\\)（是否导通） \\(i_C\\) \\(u_{CE}\\)（管压降） 截止 \\(\\leq U_\\text{on}\\) \\(I_{CEO}\\approx 0\\) \\(\\approx V_{CC}\\) 放大 \\(\u003eU_\\text{on}\\) \\(\\beta i_B\\) \\(\\geq u_{BE}\\) 饱和 \\(\u003eU_\\text{on}\\) \\(\u003c\\beta i_B\\) \\(\u003cu_{BE}\\) 放大区：三极管工作在放大区时，集电极电流几乎仅由基极电流决定。可将输出回路等效为电流\\(i_B\\)控制的电流源\\(i_C\\)。 饱和区：此时基极电流改变时，集电极电流变化没有达到放大倍数。 截止区：晶体管没有放大能力。 判断方法：先看\\(u_{BE}\\)是否达到导通电压，再判断\\(u_{CE}\\)与\\(u_{BE}\\)的关系。此外，也可以通过外电路计算出\\(i_{c\\max}\\)，然后与\\(\\beta i_B\\)进行比较来判断是否饱和。 电压传输特性 \\(u_o=f(u_i)\\)： 三极管工作在放大区时，电压传输特性几乎是线性变化的。 温度特性 温度升高： 穿透电流\\(I_{CEO}\\)增大 放大倍数\\(\\beta\\)增大 基极电压\\(u_{BE}\\)不变时，基极电流\\(i_B\\)增大。 三极管的接法 共射接法 基极和发射极共地。电流电压都是实际存在的 共基接法 理想三极管 \\(\\beta=\\bar\\beta\\)且为常量，穿透电流为0。 光电三极管 符号 输出特性 入射光线控制集电极电流。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:13","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#三极管"},{"categories":null,"content":"三极管 结构： 基区：薄且掺杂浓度低。 发射区：掺杂浓度很高。 集电区：空间大。 主要参数（共射）： 放大倍数：非理想三极管的放大倍数在工作区中不是处处相等的。 直流参数：\\(I_c=\\bar\\beta I_B +(1 + \\bar\\beta)I_{CBO}=\\bar\\beta I_B + I_{CEO}\\Rightarrow \\bar\\beta = \\frac{I_C}{I_B}\\) \\(I_{CBO}\\) 穿透电流\\(I_{CEO}\\)：理想状态下，基极无电流时，C、E极间加上工作电压，CE极间电流电压=0。实际上有微弱电流通过，这就是穿透电流。穿透电流大小与管子性能有关，但一般可以小到可以忽略不计。 \\(\\bar\\beta\\)：直流电流放大系数 交流参数 \\(\\beta = \\frac{\\Delta I_C}{\\Delta I_B}\\)：交流放大倍数 \\(f_T\\)：使\\(\\beta=1\\)的信号频率 对变化量的具有放大作用。 极限参数 \\(I_{CM}\\)：最大集电极电流 \\(P_{CM}=i_C u_{CE}\\)：最大集电极耗散功率 \\(U_{(BR)CEO}\\)：c-e间的击穿电压（处于反偏的结超过一定电压后就会被击穿） 放大作用 原理 发射极电流的形成：因发射区多子浓度高使大量电子从发射区扩散到基区形成扩散电流。 基极电流的形成：发射极中的电子和基区的空穴产生的复合电流。由于基区很薄，扩散过来的少子不会在此储存，而是复合或漂移到集电区。由于基区薄且多子（空穴）浓度低，该电流很小。可以理解为基极的电压只是为了降低能量壁垒，电子只要能克服这个能量壁垒即可快速迁移到集电区，与基极空穴复合的电子与漂移的电子是成比例的。基区空穴浓度很小，使得复合的电子远小于漂移的电子。 集电极电流的形成：载流子的集电区面积大，在外电场作用下，大部分扩散到基区的电子漂移到集电区。由于基区掺杂浓度很低，扩散到基区的少子浓度多于基区多子浓度，在外电场的作用下，可以漂移到集电区。 条件： 发射结正偏：\\(u_{BE}\u003eU_\\text{on}\\) 集电结反偏：\\(u_{CE}\\geq 0\\)，即\\(u_\\text{CE}\\geq u_\\text{BE}\\) 特性： 共射输入特性： \\(i_B=f(u_{BE})\\Large|_{U_{CE}}\\)的特性曲线（不同曲线的\\(U_{CE}\\)不同）： \\(U_{CE}\\)增大曲线右移：当\\(U_{CE}\\)增大的时候，集电区的电场强度增强，集电极收集电子的能力也增强， \\(I_C\\)增大，导致\\(I_B\\)减小。也就是说集电极的电压较高的情况下，基极加较小的电压也能达到相同的电流。当\\(U_{CE}\\)足够大，把电子几乎都收集完之后，再升高\\(U_{CE}\\)，收集电子的数目不会发生明显变化，因此\\(U_{CE}\\)再升高，曲线右移幅度也很小。对于小功率晶体管而言，可以近似地用一条\\(U_{CE}\u003e1V\\)的曲线来代替之后所有\\(U_{CE}\\)的曲线。也就是说集电极电压升高到一定程度后，基极电流和基极电压的关系就比较确定了，放大倍数一定的情况下，集电极电流和基极电压的关系也可以确定。 输出特性： \\(i_C=f(u_{CE})\\Large|_{I_B}\\) 三极管的三个工作区： 状态 \\(u_{BE}\\)（是否导通） \\(i_C\\) \\(u_{CE}\\)（管压降） 截止 \\(\\leq U_\\text{on}\\) \\(I_{CEO}\\approx 0\\) \\(\\approx V_{CC}\\) 放大 \\(\u003eU_\\text{on}\\) \\(\\beta i_B\\) \\(\\geq u_{BE}\\) 饱和 \\(\u003eU_\\text{on}\\) \\(\u003c\\beta i_B\\) \\(","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:13","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#三极管的接法"},{"categories":null,"content":"三极管 结构： 基区：薄且掺杂浓度低。 发射区：掺杂浓度很高。 集电区：空间大。 主要参数（共射）： 放大倍数：非理想三极管的放大倍数在工作区中不是处处相等的。 直流参数：\\(I_c=\\bar\\beta I_B +(1 + \\bar\\beta)I_{CBO}=\\bar\\beta I_B + I_{CEO}\\Rightarrow \\bar\\beta = \\frac{I_C}{I_B}\\) \\(I_{CBO}\\) 穿透电流\\(I_{CEO}\\)：理想状态下，基极无电流时，C、E极间加上工作电压，CE极间电流电压=0。实际上有微弱电流通过，这就是穿透电流。穿透电流大小与管子性能有关，但一般可以小到可以忽略不计。 \\(\\bar\\beta\\)：直流电流放大系数 交流参数 \\(\\beta = \\frac{\\Delta I_C}{\\Delta I_B}\\)：交流放大倍数 \\(f_T\\)：使\\(\\beta=1\\)的信号频率 对变化量的具有放大作用。 极限参数 \\(I_{CM}\\)：最大集电极电流 \\(P_{CM}=i_C u_{CE}\\)：最大集电极耗散功率 \\(U_{(BR)CEO}\\)：c-e间的击穿电压（处于反偏的结超过一定电压后就会被击穿） 放大作用 原理 发射极电流的形成：因发射区多子浓度高使大量电子从发射区扩散到基区形成扩散电流。 基极电流的形成：发射极中的电子和基区的空穴产生的复合电流。由于基区很薄，扩散过来的少子不会在此储存，而是复合或漂移到集电区。由于基区薄且多子（空穴）浓度低，该电流很小。可以理解为基极的电压只是为了降低能量壁垒，电子只要能克服这个能量壁垒即可快速迁移到集电区，与基极空穴复合的电子与漂移的电子是成比例的。基区空穴浓度很小，使得复合的电子远小于漂移的电子。 集电极电流的形成：载流子的集电区面积大，在外电场作用下，大部分扩散到基区的电子漂移到集电区。由于基区掺杂浓度很低，扩散到基区的少子浓度多于基区多子浓度，在外电场的作用下，可以漂移到集电区。 条件： 发射结正偏：\\(u_{BE}\u003eU_\\text{on}\\) 集电结反偏：\\(u_{CE}\\geq 0\\)，即\\(u_\\text{CE}\\geq u_\\text{BE}\\) 特性： 共射输入特性： \\(i_B=f(u_{BE})\\Large|_{U_{CE}}\\)的特性曲线（不同曲线的\\(U_{CE}\\)不同）： \\(U_{CE}\\)增大曲线右移：当\\(U_{CE}\\)增大的时候，集电区的电场强度增强，集电极收集电子的能力也增强， \\(I_C\\)增大，导致\\(I_B\\)减小。也就是说集电极的电压较高的情况下，基极加较小的电压也能达到相同的电流。当\\(U_{CE}\\)足够大，把电子几乎都收集完之后，再升高\\(U_{CE}\\)，收集电子的数目不会发生明显变化，因此\\(U_{CE}\\)再升高，曲线右移幅度也很小。对于小功率晶体管而言，可以近似地用一条\\(U_{CE}\u003e1V\\)的曲线来代替之后所有\\(U_{CE}\\)的曲线。也就是说集电极电压升高到一定程度后，基极电流和基极电压的关系就比较确定了，放大倍数一定的情况下，集电极电流和基极电压的关系也可以确定。 输出特性： \\(i_C=f(u_{CE})\\Large|_{I_B}\\) 三极管的三个工作区： 状态 \\(u_{BE}\\)（是否导通） \\(i_C\\) \\(u_{CE}\\)（管压降） 截止 \\(\\leq U_\\text{on}\\) \\(I_{CEO}\\approx 0\\) \\(\\approx V_{CC}\\) 放大 \\(\u003eU_\\text{on}\\) \\(\\beta i_B\\) \\(\\geq u_{BE}\\) 饱和 \\(\u003eU_\\text{on}\\) \\(\u003c\\beta i_B\\) \\(","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:13","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#理想三极管"},{"categories":null,"content":"三极管 结构： 基区：薄且掺杂浓度低。 发射区：掺杂浓度很高。 集电区：空间大。 主要参数（共射）： 放大倍数：非理想三极管的放大倍数在工作区中不是处处相等的。 直流参数：\\(I_c=\\bar\\beta I_B +(1 + \\bar\\beta)I_{CBO}=\\bar\\beta I_B + I_{CEO}\\Rightarrow \\bar\\beta = \\frac{I_C}{I_B}\\) \\(I_{CBO}\\) 穿透电流\\(I_{CEO}\\)：理想状态下，基极无电流时，C、E极间加上工作电压，CE极间电流电压=0。实际上有微弱电流通过，这就是穿透电流。穿透电流大小与管子性能有关，但一般可以小到可以忽略不计。 \\(\\bar\\beta\\)：直流电流放大系数 交流参数 \\(\\beta = \\frac{\\Delta I_C}{\\Delta I_B}\\)：交流放大倍数 \\(f_T\\)：使\\(\\beta=1\\)的信号频率 对变化量的具有放大作用。 极限参数 \\(I_{CM}\\)：最大集电极电流 \\(P_{CM}=i_C u_{CE}\\)：最大集电极耗散功率 \\(U_{(BR)CEO}\\)：c-e间的击穿电压（处于反偏的结超过一定电压后就会被击穿） 放大作用 原理 发射极电流的形成：因发射区多子浓度高使大量电子从发射区扩散到基区形成扩散电流。 基极电流的形成：发射极中的电子和基区的空穴产生的复合电流。由于基区很薄，扩散过来的少子不会在此储存，而是复合或漂移到集电区。由于基区薄且多子（空穴）浓度低，该电流很小。可以理解为基极的电压只是为了降低能量壁垒，电子只要能克服这个能量壁垒即可快速迁移到集电区，与基极空穴复合的电子与漂移的电子是成比例的。基区空穴浓度很小，使得复合的电子远小于漂移的电子。 集电极电流的形成：载流子的集电区面积大，在外电场作用下，大部分扩散到基区的电子漂移到集电区。由于基区掺杂浓度很低，扩散到基区的少子浓度多于基区多子浓度，在外电场的作用下，可以漂移到集电区。 条件： 发射结正偏：\\(u_{BE}\u003eU_\\text{on}\\) 集电结反偏：\\(u_{CE}\\geq 0\\)，即\\(u_\\text{CE}\\geq u_\\text{BE}\\) 特性： 共射输入特性： \\(i_B=f(u_{BE})\\Large|_{U_{CE}}\\)的特性曲线（不同曲线的\\(U_{CE}\\)不同）： \\(U_{CE}\\)增大曲线右移：当\\(U_{CE}\\)增大的时候，集电区的电场强度增强，集电极收集电子的能力也增强， \\(I_C\\)增大，导致\\(I_B\\)减小。也就是说集电极的电压较高的情况下，基极加较小的电压也能达到相同的电流。当\\(U_{CE}\\)足够大，把电子几乎都收集完之后，再升高\\(U_{CE}\\)，收集电子的数目不会发生明显变化，因此\\(U_{CE}\\)再升高，曲线右移幅度也很小。对于小功率晶体管而言，可以近似地用一条\\(U_{CE}\u003e1V\\)的曲线来代替之后所有\\(U_{CE}\\)的曲线。也就是说集电极电压升高到一定程度后，基极电流和基极电压的关系就比较确定了，放大倍数一定的情况下，集电极电流和基极电压的关系也可以确定。 输出特性： \\(i_C=f(u_{CE})\\Large|_{I_B}\\) 三极管的三个工作区： 状态 \\(u_{BE}\\)（是否导通） \\(i_C\\) \\(u_{CE}\\)（管压降） 截止 \\(\\leq U_\\text{on}\\) \\(I_{CEO}\\approx 0\\) \\(\\approx V_{CC}\\) 放大 \\(\u003eU_\\text{on}\\) \\(\\beta i_B\\) \\(\\geq u_{BE}\\) 饱和 \\(\u003eU_\\text{on}\\) \\(\u003c\\beta i_B\\) \\(","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:13","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#光电三极管"},{"categories":null,"content":"光电耦合器 内部有发光二极管和光电三极管。 输出特性 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:14","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#光电耦合器"},{"categories":null,"content":"场效应管 信号比较小的时候，需要让输入电阻趋于无穷。 特点 场效应管是单极型管，内部只有一种载流子在运动： 噪声小 三极管有两种载流子运动，因此噪声很大。 抗辐射能力强 低电压工作 输入回路的等效电阻很大 极 源极（s）（类比发射极） 栅极（g）（类比基极） 漏极（d）（类比集电极） 工作区域 截止区 恒流区（放大区） 可变电阻区（饱和区） 结型场效应管 转移特性： \\[i_D=I_D\\cdot\\left(\\frac{U_{\\mathrm{gs}}}{U_{\\mathrm{gs(th)}}}-1\\right)\\] N沟道结型场效应管 结构 从结构可以看出，源极和漏极之间就是电子的定向移动，形成导电沟道，当栅极和源极的电压\\(u_{GS}=0\\)时，漏极和源极之间加电压就形成漏极电流，并且这个电流不像三极管那样，只能是单向的，而是可以双向的，因此漏极和源极可以互换使用。PN结必须反偏，因此栅源之间的电压可以大于夹断电压，但不能大于0。 工作原理 栅-源电压对导电沟道宽度的控制作用 假设此时源极和漏极是连接在一起的。 \\(u_{GS}=0\\) 沟道宽度最宽。 \\(u_{GS}\u003c0\\) 导电沟道变窄。 为什么要加反向电压？ 如果加上正向电压，就会导致耗尽层变窄，导致扩散运动的增强，此时的结型场效应管也失去了输入电阻大的特性。要使结型场效应管正常工作，就要让栅极PN结反偏。 \\(u_{GS}=u_{GS\\text{(off)}}\\)（夹断电压） 栅极和源极加上足够大的电压，沟道消失。 漏-源电压对漏极电流的影响 在\\(u_{GS}\u003eu_{GS\\text{(off)}}\\)（负数）且不变的前提下，改变\\(u_{GD}\\)。 \\(u_{GD}\u003eu_{GS\\text{(off)}}\\) \\(i_D\\)随着\\(V_{DD}\\)的增大几乎线性增大，此时源极和漏极之间相当于一个电阻。 \\(u_{GD}=u_{GS\\text{(off)}}\\) 漏极变为预夹断状态，耗尽层开始阻碍电子运动。 \\(u_{GD}\u003cu_{GS\\text{(off)}}\\) 当\\(u_{GD}\\)的增大，几乎全部用来克服沟道的电阻，此时的\\(i_D\\)就几乎不变，且只取决于\\(u_{GS}\\)，晶体管工作在恒流区，此时结型场效应管具有放大作用。 特性 转移特性 \\[i_D=\\left.f(u_{GS})\\right|_{u_{DS}}\\] \\(u_{GS\\text{(off)}}\\)：夹断电压 \\(i_{DSS}\\)：漏极饱和电流（最大电流） 不同型号的晶体管，这两个参数也不一样。要工作在恒流区，需\\(u_{GS}\u003eu_{GS\\text{(off)}}\\)。通过半导体物理分析，此时有： \\[i_{\\mathrm{D}}=I_{\\mathrm{DSS}}\\left(1-\\frac{u_{\\mathrm{GS}}}{U_{\\mathrm{GS(off})}}\\right)^{2}\\] 输出特性 \\[i_D=\\left.f(u_{DS})\\right|_{u_{GS}}\\] 可变电阻：栅极-源极电压控制漏极-源极电阻的等效电阻，可做压控电阻。 恒流：在恒流区，图像呈平行线，此时的\\(i_D\\)只取决于\\(u_{GS}\\)。描述这种电压对电流控制作用的参数，叫做低频跨导： \\[g_m=\\left.\\frac{\\Delta i_D}{\\Delta u_{GS}}\\right|_{u_{DS}}\\] 预夹断轨迹：可变电阻区和恒流区的交界线。 P沟道结型场效应管 绝缘栅型场效应管 绝缘栅型场效应管（IGFET，Insulated Gate Field Effect Transister），也称金属氧化物半导体场效应管（Metal Oxide Semiconductor FET，简写为MOSFET）。 增强型绝缘栅型场效应管 N沟道增强型绝缘栅型场效应管 也称为增强型MOS管。 符号 箭头指向是PN结的方向（P指向N），因此衬底是P，沟道是N，图中为N沟道绝缘栅型场效应管。 工作原理 导电沟道 \\(0\u003cu_{GS}\u003cu_{GS\\text{(th)}}\\) 在电场作用下，空穴开始向下运动，留下自由电子。 绝缘层：使得栅极的输入电阻更大。 反型层：由于P型半导体的多数载流子是空穴，而在电场作用下在耗尽层和绝缘层之前产生自由电子的层，叫做反型层。 \\(u_{GS}\u003eu_{GS\\text{(th)}}\\)（开启电压） \\(u_{GS}\\)增大到一定数值，反型层形成导电沟道。 漏极-源极的电压对漏极电流的影响 \\(0\u003cu_{DS}\u003cu_{GS}\\) \\(i_D\\)随\\(u_{DS}\\)的增大而增大，此时晶体管处在可变电阻区。 \\(u_{DS}=u_{GS\\text{(th)}}\\) 出现预夹断。有两种理解： 漏极电位升高，与漏极的电势差减小，电场强度降低，反型层变窄。 电子大多直接流入漏极，而不是留在漏极附近，漏极附近的自由电子减少。 \\(u_{DS}\u003eu_{GS}\\) \\(u_{DS}\\)的增大几乎全部用来克服夹断区的电阻，此时晶体管处在恒流区。 特性 转移特性 假设场效应管工作在恒流区（\\(u_{ds}\\)足够大）： 和三极管的输入特性很像，但是开启电压较高。曲线上的切线，就是该点的\\(g_m\\)。 输出特性 \\[i_\\mathrm{D}=\\frac{\\mu_n C_{ox}}{2}\\cdot \\frac{W}{L}\\cdot \\left( u_\\mathrm{GS}-U_\\mathrm{GS(th)} \\right)^2\\cdot \\left( 1+\\lambda u_\\mathrm{DS} \\right)\\] 其中： \\(\\lambda=\\frac{1}{U_A}\\)：沟道长度调制系数（近似于\\(0\\)） 并且： \\[g_m=2\\sqrt{\\frac{\\mu_n C_{ox}}{2}\\cdot \\frac{W}{L}\\cdot I_\\mathrm{D}}\\] P沟道增强型绝缘栅型场效应管 耗尽型绝缘栅型场效应管 N沟道耗尽型绝缘栅型场效应管 符号 工作原理 由于在绝缘层中添加了正离子，使得在\\(u_{GS}=0\\)时就存在导电沟道，并且保证无论\\(u_{GS}\\)是正还是负，具有大的输入电阻，并且都可以使其工作在恒流区，只有在\\(u_{GS}\\)小到一定数值后才会夹断。 特性 转移特性 与结型场效应管一样： \\[i_D=I_{DO}\\left(\\frac{u_{GS}}{u_{GS\\text{(th)}}}-1\\right)^2\\] 其中\\(I_{DO}=\\left.i_D\\right|_{u_{GS}=2u_{GS\\text{(th)}}}\\) 输出特性 P沟道耗尽型绝缘栅型场效应管 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:15","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#场效应管"},{"categories":null,"content":"场效应管 信号比较小的时候，需要让输入电阻趋于无穷。 特点 场效应管是单极型管，内部只有一种载流子在运动： 噪声小 三极管有两种载流子运动，因此噪声很大。 抗辐射能力强 低电压工作 输入回路的等效电阻很大 极 源极（s）（类比发射极） 栅极（g）（类比基极） 漏极（d）（类比集电极） 工作区域 截止区 恒流区（放大区） 可变电阻区（饱和区） 结型场效应管 转移特性： \\[i_D=I_D\\cdot\\left(\\frac{U_{\\mathrm{gs}}}{U_{\\mathrm{gs(th)}}}-1\\right)\\] N沟道结型场效应管 结构 从结构可以看出，源极和漏极之间就是电子的定向移动，形成导电沟道，当栅极和源极的电压\\(u_{GS}=0\\)时，漏极和源极之间加电压就形成漏极电流，并且这个电流不像三极管那样，只能是单向的，而是可以双向的，因此漏极和源极可以互换使用。PN结必须反偏，因此栅源之间的电压可以大于夹断电压，但不能大于0。 工作原理 栅-源电压对导电沟道宽度的控制作用 假设此时源极和漏极是连接在一起的。 \\(u_{GS}=0\\) 沟道宽度最宽。 \\(u_{GS}\u003c0\\) 导电沟道变窄。 为什么要加反向电压？ 如果加上正向电压，就会导致耗尽层变窄，导致扩散运动的增强，此时的结型场效应管也失去了输入电阻大的特性。要使结型场效应管正常工作，就要让栅极PN结反偏。 \\(u_{GS}=u_{GS\\text{(off)}}\\)（夹断电压） 栅极和源极加上足够大的电压，沟道消失。 漏-源电压对漏极电流的影响 在\\(u_{GS}\u003eu_{GS\\text{(off)}}\\)（负数）且不变的前提下，改变\\(u_{GD}\\)。 \\(u_{GD}\u003eu_{GS\\text{(off)}}\\) \\(i_D\\)随着\\(V_{DD}\\)的增大几乎线性增大，此时源极和漏极之间相当于一个电阻。 \\(u_{GD}=u_{GS\\text{(off)}}\\) 漏极变为预夹断状态，耗尽层开始阻碍电子运动。 \\(u_{GD}u_{GS\\text{(off)}}\\)。通过半导体物理分析，此时有： \\[i_{\\mathrm{D}}=I_{\\mathrm{DSS}}\\left(1-\\frac{u_{\\mathrm{GS}}}{U_{\\mathrm{GS(off})}}\\right)^{2}\\] 输出特性 \\[i_D=\\left.f(u_{DS})\\right|_{u_{GS}}\\] 可变电阻：栅极-源极电压控制漏极-源极电阻的等效电阻，可做压控电阻。 恒流：在恒流区，图像呈平行线，此时的\\(i_D\\)只取决于\\(u_{GS}\\)。描述这种电压对电流控制作用的参数，叫做低频跨导： \\[g_m=\\left.\\frac{\\Delta i_D}{\\Delta u_{GS}}\\right|_{u_{DS}}\\] 预夹断轨迹：可变电阻区和恒流区的交界线。 P沟道结型场效应管 绝缘栅型场效应管 绝缘栅型场效应管（IGFET，Insulated Gate Field Effect Transister），也称金属氧化物半导体场效应管（Metal Oxide Semiconductor FET，简写为MOSFET）。 增强型绝缘栅型场效应管 N沟道增强型绝缘栅型场效应管 也称为增强型MOS管。 符号 箭头指向是PN结的方向（P指向N），因此衬底是P，沟道是N，图中为N沟道绝缘栅型场效应管。 工作原理 导电沟道 \\(0","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:15","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#结型场效应管"},{"categories":null,"content":"场效应管 信号比较小的时候，需要让输入电阻趋于无穷。 特点 场效应管是单极型管，内部只有一种载流子在运动： 噪声小 三极管有两种载流子运动，因此噪声很大。 抗辐射能力强 低电压工作 输入回路的等效电阻很大 极 源极（s）（类比发射极） 栅极（g）（类比基极） 漏极（d）（类比集电极） 工作区域 截止区 恒流区（放大区） 可变电阻区（饱和区） 结型场效应管 转移特性： \\[i_D=I_D\\cdot\\left(\\frac{U_{\\mathrm{gs}}}{U_{\\mathrm{gs(th)}}}-1\\right)\\] N沟道结型场效应管 结构 从结构可以看出，源极和漏极之间就是电子的定向移动，形成导电沟道，当栅极和源极的电压\\(u_{GS}=0\\)时，漏极和源极之间加电压就形成漏极电流，并且这个电流不像三极管那样，只能是单向的，而是可以双向的，因此漏极和源极可以互换使用。PN结必须反偏，因此栅源之间的电压可以大于夹断电压，但不能大于0。 工作原理 栅-源电压对导电沟道宽度的控制作用 假设此时源极和漏极是连接在一起的。 \\(u_{GS}=0\\) 沟道宽度最宽。 \\(u_{GS}\u003c0\\) 导电沟道变窄。 为什么要加反向电压？ 如果加上正向电压，就会导致耗尽层变窄，导致扩散运动的增强，此时的结型场效应管也失去了输入电阻大的特性。要使结型场效应管正常工作，就要让栅极PN结反偏。 \\(u_{GS}=u_{GS\\text{(off)}}\\)（夹断电压） 栅极和源极加上足够大的电压，沟道消失。 漏-源电压对漏极电流的影响 在\\(u_{GS}\u003eu_{GS\\text{(off)}}\\)（负数）且不变的前提下，改变\\(u_{GD}\\)。 \\(u_{GD}\u003eu_{GS\\text{(off)}}\\) \\(i_D\\)随着\\(V_{DD}\\)的增大几乎线性增大，此时源极和漏极之间相当于一个电阻。 \\(u_{GD}=u_{GS\\text{(off)}}\\) 漏极变为预夹断状态，耗尽层开始阻碍电子运动。 \\(u_{GD}u_{GS\\text{(off)}}\\)。通过半导体物理分析，此时有： \\[i_{\\mathrm{D}}=I_{\\mathrm{DSS}}\\left(1-\\frac{u_{\\mathrm{GS}}}{U_{\\mathrm{GS(off})}}\\right)^{2}\\] 输出特性 \\[i_D=\\left.f(u_{DS})\\right|_{u_{GS}}\\] 可变电阻：栅极-源极电压控制漏极-源极电阻的等效电阻，可做压控电阻。 恒流：在恒流区，图像呈平行线，此时的\\(i_D\\)只取决于\\(u_{GS}\\)。描述这种电压对电流控制作用的参数，叫做低频跨导： \\[g_m=\\left.\\frac{\\Delta i_D}{\\Delta u_{GS}}\\right|_{u_{DS}}\\] 预夹断轨迹：可变电阻区和恒流区的交界线。 P沟道结型场效应管 绝缘栅型场效应管 绝缘栅型场效应管（IGFET，Insulated Gate Field Effect Transister），也称金属氧化物半导体场效应管（Metal Oxide Semiconductor FET，简写为MOSFET）。 增强型绝缘栅型场效应管 N沟道增强型绝缘栅型场效应管 也称为增强型MOS管。 符号 箭头指向是PN结的方向（P指向N），因此衬底是P，沟道是N，图中为N沟道绝缘栅型场效应管。 工作原理 导电沟道 \\(0","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:1:15","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#绝缘栅型场效应管"},{"categories":null,"content":"放大电路 对象：变化量（常用正弦波做测试信号） 本质：能量的控制和转换，利用有源元件实现 特征：功率放大——判断电路能否放大的基本出发点 基本要求：不失真——放大的前提 性能指标（研究的是动态性能）： 放大倍数（复数）： 电压放大倍数（最常用）：\\(\\dot{A}_{u u}=\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}\\) 求法 画出交流通路。 从定义（电压之比）出发，把分子和分母使用电流和电阻表示。 电流放大倍数：\\(\\dot{A}_{i i}=\\dot{A}_{i}=\\frac{\\dot{I}_{0}}{\\dot{I}_{i}}\\) 互阻放大倍数：\\(\\dot{A}_{u i}=\\frac{\\dot{U}_{0}}{\\dot{I}_{\\mathrm{i}}}\\) 互导放大倍数：\\(\\dot{A}_{i u}=\\frac{\\dot{I}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{i}}}\\) 输入电阻：从输入端看进去的等效电阻 输出电阻：将输出等效成有内阻的电压源，内阻就是输出电阻 通频带：衡量放大电路对不同频率信号的适应能力。由于电容、电感及半导体元件的电容效应，使放大电路在信号频率较低和较高时电压放大倍数数值下降，并产生相移。 上限频率 低频段的最高频率（使得放大倍数在\\(0.707|\\dot{A_m}|\\)的最低频率） 下限频率 高频段的最低频率（使得放大倍数在\\(0.707|\\dot{A_m}|\\)的最高频率） 最大不失真输出电压\\(U_\\text{om}\\)：交流有效值 最大输出功率和效率 组成原则： 静态工作点合适 负载上无直流分量 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#放大电路"},{"categories":null,"content":"基本共射放大电路 结构： \\(T\\)：有源元件，能够控制能量的元件。 \\(V_{BB}、R_b\\)：使\\(U_{BE}\u003eU_\\text{on}\\)，且有合适的IB。 \\(V_{CC}\\)：使\\(U_{CE}\\geq U_{BE}\\)，同时作为负载的能源。 \\(R_c\\)：将\\(\\Delta i_C\\)转换成\\(u_{CE}(u_o)\\) 。 输入： 动态信号： \\(\\Delta u_{1} \\rightarrow \\Delta i_{\\mathrm{B}} \\rightarrow \\Delta i_{\\mathrm{C}} \\rightarrow \\Delta u_{R_{\\mathrm{c}}} \\rightarrow \\Delta u_{\\mathrm{CE}}\\left(u_{\\mathrm{o}}\\right)\\) 输入电压\\(u_i\\)为0（由于有\\(V_{BB}\\)，基极电压不为0）：此时管压降称为静态工作点Q，所有量的下标后面都加上Q。 问题： 使用了两个电源 信号源与放大电路不“共地” 静态工作点 为了让晶体管工作在放大区。静态工作点的几种情况： 没有：必然失真 设置过高：饱和失真 设置过低：截止失真 饱和失真 因晶体管工作在饱和区产生的失真。 截止失真 因晶体管工作在截止区产生的失真。 顶部失真 底部失真 有源元件 能够控制能量的元件。 基本共射放大电路的动态分析 首先先用h参数等效模型来简化三极管，得到： 列写输入电压与输出电压方程（注意受控源的方向）： \\[\\begin{cases}\\dot U_i=\\dot I_i(R_b+r_{be})=\\dot I_b(R_b+r_{be})\\\\ \\dot U_o=-\\dot I_CR_C\\end{cases}\\] 可以得到电压放大倍数和输入电阻： \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=-\\frac{\\beta R_{\\mathrm{c}}}{R_{\\mathrm{b}}+r_{\\mathrm{be}}}\\] \\[R_{\\mathrm{i}}=\\frac{U_{\\mathrm{i}}}{I_{\\mathrm{i}}}=R_{\\mathrm{b}}+r_{\\mathrm{be}}\\] 可见\\(r_{be}\\)的影响有利有弊： 增大了输入阻抗 减小了放大倍数 对输出端进行电源等效变换： 得到输出电阻： \\[R_{\\mathrm {o}}=R_C\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本共射放大电路"},{"categories":null,"content":"基本共射放大电路 结构： \\(T\\)：有源元件，能够控制能量的元件。 \\(V_{BB}、R_b\\)：使\\(U_{BE}\u003eU_\\text{on}\\)，且有合适的IB。 \\(V_{CC}\\)：使\\(U_{CE}\\geq U_{BE}\\)，同时作为负载的能源。 \\(R_c\\)：将\\(\\Delta i_C\\)转换成\\(u_{CE}(u_o)\\) 。 输入： 动态信号： \\(\\Delta u_{1} \\rightarrow \\Delta i_{\\mathrm{B}} \\rightarrow \\Delta i_{\\mathrm{C}} \\rightarrow \\Delta u_{R_{\\mathrm{c}}} \\rightarrow \\Delta u_{\\mathrm{CE}}\\left(u_{\\mathrm{o}}\\right)\\) 输入电压\\(u_i\\)为0（由于有\\(V_{BB}\\)，基极电压不为0）：此时管压降称为静态工作点Q，所有量的下标后面都加上Q。 问题： 使用了两个电源 信号源与放大电路不“共地” 静态工作点 为了让晶体管工作在放大区。静态工作点的几种情况： 没有：必然失真 设置过高：饱和失真 设置过低：截止失真 饱和失真 因晶体管工作在饱和区产生的失真。 截止失真 因晶体管工作在截止区产生的失真。 顶部失真 底部失真 有源元件 能够控制能量的元件。 基本共射放大电路的动态分析 首先先用h参数等效模型来简化三极管，得到： 列写输入电压与输出电压方程（注意受控源的方向）： \\[\\begin{cases}\\dot U_i=\\dot I_i(R_b+r_{be})=\\dot I_b(R_b+r_{be})\\\\ \\dot U_o=-\\dot I_CR_C\\end{cases}\\] 可以得到电压放大倍数和输入电阻： \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=-\\frac{\\beta R_{\\mathrm{c}}}{R_{\\mathrm{b}}+r_{\\mathrm{be}}}\\] \\[R_{\\mathrm{i}}=\\frac{U_{\\mathrm{i}}}{I_{\\mathrm{i}}}=R_{\\mathrm{b}}+r_{\\mathrm{be}}\\] 可见\\(r_{be}\\)的影响有利有弊： 增大了输入阻抗 减小了放大倍数 对输出端进行电源等效变换： 得到输出电阻： \\[R_{\\mathrm {o}}=R_C\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#静态工作点"},{"categories":null,"content":"基本共射放大电路 结构： \\(T\\)：有源元件，能够控制能量的元件。 \\(V_{BB}、R_b\\)：使\\(U_{BE}\u003eU_\\text{on}\\)，且有合适的IB。 \\(V_{CC}\\)：使\\(U_{CE}\\geq U_{BE}\\)，同时作为负载的能源。 \\(R_c\\)：将\\(\\Delta i_C\\)转换成\\(u_{CE}(u_o)\\) 。 输入： 动态信号： \\(\\Delta u_{1} \\rightarrow \\Delta i_{\\mathrm{B}} \\rightarrow \\Delta i_{\\mathrm{C}} \\rightarrow \\Delta u_{R_{\\mathrm{c}}} \\rightarrow \\Delta u_{\\mathrm{CE}}\\left(u_{\\mathrm{o}}\\right)\\) 输入电压\\(u_i\\)为0（由于有\\(V_{BB}\\)，基极电压不为0）：此时管压降称为静态工作点Q，所有量的下标后面都加上Q。 问题： 使用了两个电源 信号源与放大电路不“共地” 静态工作点 为了让晶体管工作在放大区。静态工作点的几种情况： 没有：必然失真 设置过高：饱和失真 设置过低：截止失真 饱和失真 因晶体管工作在饱和区产生的失真。 截止失真 因晶体管工作在截止区产生的失真。 顶部失真 底部失真 有源元件 能够控制能量的元件。 基本共射放大电路的动态分析 首先先用h参数等效模型来简化三极管，得到： 列写输入电压与输出电压方程（注意受控源的方向）： \\[\\begin{cases}\\dot U_i=\\dot I_i(R_b+r_{be})=\\dot I_b(R_b+r_{be})\\\\ \\dot U_o=-\\dot I_CR_C\\end{cases}\\] 可以得到电压放大倍数和输入电阻： \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=-\\frac{\\beta R_{\\mathrm{c}}}{R_{\\mathrm{b}}+r_{\\mathrm{be}}}\\] \\[R_{\\mathrm{i}}=\\frac{U_{\\mathrm{i}}}{I_{\\mathrm{i}}}=R_{\\mathrm{b}}+r_{\\mathrm{be}}\\] 可见\\(r_{be}\\)的影响有利有弊： 增大了输入阻抗 减小了放大倍数 对输出端进行电源等效变换： 得到输出电阻： \\[R_{\\mathrm {o}}=R_C\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本共射放大电路的动态分析"},{"categories":null,"content":"CMOS 电路 结电容是由于两个MOS管同时导通造成的。要用x非门是由于CMOS反相器就是反相的，门太多或者输入太多性能就不好。 \\[P_D=P_C+P_T=\\left(C_{L}+C_{PD}\\right)V_{DD}^2\\cdot f\\] 分析技巧：只看对地的MOS管的结构，因为输入的是正的信号，可以直接控制对地MOS的导通，只看MOS是串联还是并联，确定与或关系，然后取非。真值表中使输出不为1的输入以相反的逻辑接到VCC上。衬底相连是保证两个MOS同开同关。开漏就是MOS管的漏极开路，栅极控制漏-源对地的导通，因此在外部给栅极加上串联电阻的电源既可以控制电平的高低，并且这个电源电压可以是比较大的。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#cmos-电路"},{"categories":null,"content":"放大电路的分析方法 直流通路和交流通路 用于分析放大电路的一种方法。 使用直流通路估算静态工作点：列晶体管输入、输出回路方程，将\\(U_{BEQ}\\)作为已知条件，令\\(I_{CQ}=\\beta I_{BQ}\\)，可估算出静态工作点。 \\[\\begin{cases} I_{\\mathrm{BQ}}=\\frac{V_{\\mathrm{BB}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{b}}}\\\\ I_{\\mathrm{CQ}}=\\beta I_{\\mathrm{BQ}} \\\\ U_{\\mathrm{CEQ}}=V_{\\mathrm{CC}}-I_{\\mathrm{CQ}} R_{\\mathrm{c}} \\end{cases}\\] 直流通路 令\\(U_s=0\\)，保留\\(R_s\\) 电容开路； 电感相当于短路（线圈电阻近似为0）。 交流通路 大容量电容相当于短路； 直流电源相当于短路（内阻为0）。也就是\\(V_{CC}\\)可以和地直接相连。 等效电路法 等效模型 直流等效模型 用于分析静态工作点。 交流等效模型 用于分析： 电压放大倍数 输入/输出电阻 h参数等效模型 从三极管的输入特性曲线和三极管的输出特性可以看出，\\(u_{BE},i_C\\)都可以表示为二元函数。 \\[\\begin{cases}u_{BE}=f(i_B,u_{CE})\\\\i_C=f(i_B,u_{CE})\\end{cases}\\] 对两边取全微分，得： \\[\\left\\{\\begin{array}{l} \\mathrm{d} u_{\\mathrm{BE}}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}} \\\\ \\mathrm{d} i_{\\mathrm{C}}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}}\\end{array}\\right.\\] 简化式子，得： \\[\\left\\{\\begin{array}{l} \\Delta u_{\\mathrm{BE}}=h_{11} \\Delta i_{\\mathrm{B}}+h_{12} \\Delta u_{\\mathrm{CE}} \\\\ \\Delta i_{\\mathrm{C}}=h_{21} \\Delta i_{\\mathrm{B}}+h_{22} \\Delta u_{\\mathrm{CE}}\\end{array}\\right.\\] \\(h_{11}\\)：表示一个电阻 \\(h_{22}\\)：表示一个电导 \\(h_{12}\\)、\\(h_{21}\\)：无量纲 用复数可以表示为： \\[\\left\\{\\begin{array}{c} \\dot{U}_{\\text {be }}=h_{11} \\dot{I}_{\\mathrm{b}}+h_{12} \\dot{U}_{\\text {ce}} \\\\ \\dot{I}_{\\mathrm{c}}=h_{21} \\dot{I}_{\\mathrm{b}}+h_{22} \\dot{U}_{\\text {ce}} \\end{array}\\right.\\] 分析式子可以构造等效电路图： 输入：\\(\\dot U_{be}\\)可以看作是电阻\\(h_{11}\\)的分压和一个受控电压源的电压相加。也就是一个电阻串联上一个受控电压源。 \\(h_{11}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：也就是一条三极管的输入特性曲线的斜率倒数，即动态电阻。 \\(h_{12}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：也就是在\\(i_B\\)不变时，\\(\\Delta u_{BE}\\)和\\(\\Delta u_{CE}\\)比例。也就是\\(u_{CE}\\)变化对\\(u_{BE}\\)的影响大小。\\(u_{CE}\\)在一定范围内才会对\\(u_{BE}\\)产生影响。该参数也被称为内反馈系数。 输出：\\(\\dot I_c\\)可以看作是一个受控电流源的电流相加和电导\\(h_{22}\\)的分流。也就是一个电阻并联上一个受控电流源。 \\(h_{21}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：就是电流放大系数。 \\(h_{22}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：\\(u_{CE}\\)变化对\\(i_C\\)的影响大小，也就是c-e之间的电导。当输出特性曲线在放大区呈平行线时，电导为0，相当于这个并联的电阻无穷大。 近似分析时可忽略的参数： \\(h_{12}\\)：当\\(u_{CE}\\)大到一定程度即可忽略。 \\(h_{22}\\)：理想三极管的输出特性曲线在放大区呈平行线。于是得到下面简化的电路模型： \\(r_{be}\\)：其内部结构如下： \\(r_{bb^\\prime}\\)：基区体电阻。由于基区很薄，载流子浓度很低，所以该电阻往往不能忽略。该参数可通过查阅手册获得。 \\(r_{b^\\prime e^\\prime}\\)：发射结电阻。需要列PN结电流方程求解： \\[r_{\\text {be }}=\\frac{U_{\\text {be }}}{I_{b}}=r_{b b^{\\prime}}+r_{\\text {b’e }} \\approx r_{b b^{\\prime}}+(1+\\beta) \\frac{U_{T}}{I_{\\text {EQ }}}\\] \\(\\beta\\)：可通过测量得到。 \\(U_T\\)：常温下为\\(26\\text{mV}\\)。 \\(I_{EQ}\\)：发射极静态电流，可近似为集电极静态电流。 \\(r_{e^\\prime}\\)：发射区体电阻。发射区多数载流子浓度高，该电阻往往可以忽略。 混合\\(\\Pi\\)模型 在低频等效模型的基础上，考虑极间电容后，可以得到： \\(C_\\pi\\)：发射结的结电容 \\(C_\\mu\\)：集电结的结电容 \\(g_m\\) 在场效应管放大电路里见到的跨导。当信号具有高频特性时，电流会产生超前和时候，因此电流放大倍数\\(\\beta\\)是个会变化的值，而电压和阻抗不会发生变化，用跨导表示输出电流和输入电压的关系的更加合适。 这里的\\(C_\\mu\\)连接了输入回路和输出回路，不方便分析。由于\\(\\frac{\\dot U_\\mathrm{ce}}{\\dot U_\\mathrm{b^\\prime e}}=-g_mR^{\\prime}_L\\)可以看作定值，因此可以使用密勒定理对\\(C_\\mu\\)进行拆分： 拆分后必须保证输入回路流入\\(C_\\mu^\\prime\\)的电流等于拆分前流入\\(C_\\mu\\)的电流： \\[\\dot{I}_{C \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}-\\dot{U}_{\\mathrm{ce}}}{X_{C_{\\mu}}}=(1-k) \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{X_{C \\mu}}\\] 其中： \\[k\\approx-g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}\\] \\(g_m\\)是输出电流和输入电压的比值，乘上负载电阻就相当于电压放大倍数。\\(1-k\\)就是放大前后电压的差值，也就是原来\\(C_\\mu\\)两端的电压，除以阻抗得到原来流过\\(C_\\mu\\)的电流，也就是要流过\\(C_\\mu^\\prime\\)的电流，并且\\(C_\\mu^\\prime\\)的电压就是输入电压，得到\\(C_\\mu^\\prime\\)的阻抗： \\[X_{C^{\\prime} \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{I}_{C \\mu}} \\approx \\frac{X_{C \\mu}}{1+g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}}\\] 由容抗的公式\\(X_C=\\frac{1}{\\omega C}\\)可得，电容和容抗是反比例关系，得到\\(C_\\mu^\\prime\\)电容的表达式： \\[C_{\\mu}^{\\prime","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#放大电路的分析方法"},{"categories":null,"content":"放大电路的分析方法 直流通路和交流通路 用于分析放大电路的一种方法。 使用直流通路估算静态工作点：列晶体管输入、输出回路方程，将\\(U_{BEQ}\\)作为已知条件，令\\(I_{CQ}=\\beta I_{BQ}\\)，可估算出静态工作点。 \\[\\begin{cases} I_{\\mathrm{BQ}}=\\frac{V_{\\mathrm{BB}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{b}}}\\\\ I_{\\mathrm{CQ}}=\\beta I_{\\mathrm{BQ}} \\\\ U_{\\mathrm{CEQ}}=V_{\\mathrm{CC}}-I_{\\mathrm{CQ}} R_{\\mathrm{c}} \\end{cases}\\] 直流通路 令\\(U_s=0\\)，保留\\(R_s\\) 电容开路； 电感相当于短路（线圈电阻近似为0）。 交流通路 大容量电容相当于短路； 直流电源相当于短路（内阻为0）。也就是\\(V_{CC}\\)可以和地直接相连。 等效电路法 等效模型 直流等效模型 用于分析静态工作点。 交流等效模型 用于分析： 电压放大倍数 输入/输出电阻 h参数等效模型 从三极管的输入特性曲线和三极管的输出特性可以看出，\\(u_{BE},i_C\\)都可以表示为二元函数。 \\[\\begin{cases}u_{BE}=f(i_B,u_{CE})\\\\i_C=f(i_B,u_{CE})\\end{cases}\\] 对两边取全微分，得： \\[\\left\\{\\begin{array}{l} \\mathrm{d} u_{\\mathrm{BE}}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}} \\\\ \\mathrm{d} i_{\\mathrm{C}}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}}\\end{array}\\right.\\] 简化式子，得： \\[\\left\\{\\begin{array}{l} \\Delta u_{\\mathrm{BE}}=h_{11} \\Delta i_{\\mathrm{B}}+h_{12} \\Delta u_{\\mathrm{CE}} \\\\ \\Delta i_{\\mathrm{C}}=h_{21} \\Delta i_{\\mathrm{B}}+h_{22} \\Delta u_{\\mathrm{CE}}\\end{array}\\right.\\] \\(h_{11}\\)：表示一个电阻 \\(h_{22}\\)：表示一个电导 \\(h_{12}\\)、\\(h_{21}\\)：无量纲 用复数可以表示为： \\[\\left\\{\\begin{array}{c} \\dot{U}_{\\text {be }}=h_{11} \\dot{I}_{\\mathrm{b}}+h_{12} \\dot{U}_{\\text {ce}} \\\\ \\dot{I}_{\\mathrm{c}}=h_{21} \\dot{I}_{\\mathrm{b}}+h_{22} \\dot{U}_{\\text {ce}} \\end{array}\\right.\\] 分析式子可以构造等效电路图： 输入：\\(\\dot U_{be}\\)可以看作是电阻\\(h_{11}\\)的分压和一个受控电压源的电压相加。也就是一个电阻串联上一个受控电压源。 \\(h_{11}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：也就是一条三极管的输入特性曲线的斜率倒数，即动态电阻。 \\(h_{12}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：也就是在\\(i_B\\)不变时，\\(\\Delta u_{BE}\\)和\\(\\Delta u_{CE}\\)比例。也就是\\(u_{CE}\\)变化对\\(u_{BE}\\)的影响大小。\\(u_{CE}\\)在一定范围内才会对\\(u_{BE}\\)产生影响。该参数也被称为内反馈系数。 输出：\\(\\dot I_c\\)可以看作是一个受控电流源的电流相加和电导\\(h_{22}\\)的分流。也就是一个电阻并联上一个受控电流源。 \\(h_{21}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：就是电流放大系数。 \\(h_{22}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：\\(u_{CE}\\)变化对\\(i_C\\)的影响大小，也就是c-e之间的电导。当输出特性曲线在放大区呈平行线时，电导为0，相当于这个并联的电阻无穷大。 近似分析时可忽略的参数： \\(h_{12}\\)：当\\(u_{CE}\\)大到一定程度即可忽略。 \\(h_{22}\\)：理想三极管的输出特性曲线在放大区呈平行线。于是得到下面简化的电路模型： \\(r_{be}\\)：其内部结构如下： \\(r_{bb^\\prime}\\)：基区体电阻。由于基区很薄，载流子浓度很低，所以该电阻往往不能忽略。该参数可通过查阅手册获得。 \\(r_{b^\\prime e^\\prime}\\)：发射结电阻。需要列PN结电流方程求解： \\[r_{\\text {be }}=\\frac{U_{\\text {be }}}{I_{b}}=r_{b b^{\\prime}}+r_{\\text {b’e }} \\approx r_{b b^{\\prime}}+(1+\\beta) \\frac{U_{T}}{I_{\\text {EQ }}}\\] \\(\\beta\\)：可通过测量得到。 \\(U_T\\)：常温下为\\(26\\text{mV}\\)。 \\(I_{EQ}\\)：发射极静态电流，可近似为集电极静态电流。 \\(r_{e^\\prime}\\)：发射区体电阻。发射区多数载流子浓度高，该电阻往往可以忽略。 混合\\(\\Pi\\)模型 在低频等效模型的基础上，考虑极间电容后，可以得到： \\(C_\\pi\\)：发射结的结电容 \\(C_\\mu\\)：集电结的结电容 \\(g_m\\) 在场效应管放大电路里见到的跨导。当信号具有高频特性时，电流会产生超前和时候，因此电流放大倍数\\(\\beta\\)是个会变化的值，而电压和阻抗不会发生变化，用跨导表示输出电流和输入电压的关系的更加合适。 这里的\\(C_\\mu\\)连接了输入回路和输出回路，不方便分析。由于\\(\\frac{\\dot U_\\mathrm{ce}}{\\dot U_\\mathrm{b^\\prime e}}=-g_mR^{\\prime}_L\\)可以看作定值，因此可以使用密勒定理对\\(C_\\mu\\)进行拆分： 拆分后必须保证输入回路流入\\(C_\\mu^\\prime\\)的电流等于拆分前流入\\(C_\\mu\\)的电流： \\[\\dot{I}_{C \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}-\\dot{U}_{\\mathrm{ce}}}{X_{C_{\\mu}}}=(1-k) \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{X_{C \\mu}}\\] 其中： \\[k\\approx-g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}\\] \\(g_m\\)是输出电流和输入电压的比值，乘上负载电阻就相当于电压放大倍数。\\(1-k\\)就是放大前后电压的差值，也就是原来\\(C_\\mu\\)两端的电压，除以阻抗得到原来流过\\(C_\\mu\\)的电流，也就是要流过\\(C_\\mu^\\prime\\)的电流，并且\\(C_\\mu^\\prime\\)的电压就是输入电压，得到\\(C_\\mu^\\prime\\)的阻抗： \\[X_{C^{\\prime} \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{I}_{C \\mu}} \\approx \\frac{X_{C \\mu}}{1+g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}}\\] 由容抗的公式\\(X_C=\\frac{1}{\\omega C}\\)可得，电容和容抗是反比例关系，得到\\(C_\\mu^\\prime\\)电容的表达式： \\[C_{\\mu}^{\\prime","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#直流通路和交流通路"},{"categories":null,"content":"放大电路的分析方法 直流通路和交流通路 用于分析放大电路的一种方法。 使用直流通路估算静态工作点：列晶体管输入、输出回路方程，将\\(U_{BEQ}\\)作为已知条件，令\\(I_{CQ}=\\beta I_{BQ}\\)，可估算出静态工作点。 \\[\\begin{cases} I_{\\mathrm{BQ}}=\\frac{V_{\\mathrm{BB}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{b}}}\\\\ I_{\\mathrm{CQ}}=\\beta I_{\\mathrm{BQ}} \\\\ U_{\\mathrm{CEQ}}=V_{\\mathrm{CC}}-I_{\\mathrm{CQ}} R_{\\mathrm{c}} \\end{cases}\\] 直流通路 令\\(U_s=0\\)，保留\\(R_s\\) 电容开路； 电感相当于短路（线圈电阻近似为0）。 交流通路 大容量电容相当于短路； 直流电源相当于短路（内阻为0）。也就是\\(V_{CC}\\)可以和地直接相连。 等效电路法 等效模型 直流等效模型 用于分析静态工作点。 交流等效模型 用于分析： 电压放大倍数 输入/输出电阻 h参数等效模型 从三极管的输入特性曲线和三极管的输出特性可以看出，\\(u_{BE},i_C\\)都可以表示为二元函数。 \\[\\begin{cases}u_{BE}=f(i_B,u_{CE})\\\\i_C=f(i_B,u_{CE})\\end{cases}\\] 对两边取全微分，得： \\[\\left\\{\\begin{array}{l} \\mathrm{d} u_{\\mathrm{BE}}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}} \\\\ \\mathrm{d} i_{\\mathrm{C}}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}}\\end{array}\\right.\\] 简化式子，得： \\[\\left\\{\\begin{array}{l} \\Delta u_{\\mathrm{BE}}=h_{11} \\Delta i_{\\mathrm{B}}+h_{12} \\Delta u_{\\mathrm{CE}} \\\\ \\Delta i_{\\mathrm{C}}=h_{21} \\Delta i_{\\mathrm{B}}+h_{22} \\Delta u_{\\mathrm{CE}}\\end{array}\\right.\\] \\(h_{11}\\)：表示一个电阻 \\(h_{22}\\)：表示一个电导 \\(h_{12}\\)、\\(h_{21}\\)：无量纲 用复数可以表示为： \\[\\left\\{\\begin{array}{c} \\dot{U}_{\\text {be }}=h_{11} \\dot{I}_{\\mathrm{b}}+h_{12} \\dot{U}_{\\text {ce}} \\\\ \\dot{I}_{\\mathrm{c}}=h_{21} \\dot{I}_{\\mathrm{b}}+h_{22} \\dot{U}_{\\text {ce}} \\end{array}\\right.\\] 分析式子可以构造等效电路图： 输入：\\(\\dot U_{be}\\)可以看作是电阻\\(h_{11}\\)的分压和一个受控电压源的电压相加。也就是一个电阻串联上一个受控电压源。 \\(h_{11}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：也就是一条三极管的输入特性曲线的斜率倒数，即动态电阻。 \\(h_{12}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：也就是在\\(i_B\\)不变时，\\(\\Delta u_{BE}\\)和\\(\\Delta u_{CE}\\)比例。也就是\\(u_{CE}\\)变化对\\(u_{BE}\\)的影响大小。\\(u_{CE}\\)在一定范围内才会对\\(u_{BE}\\)产生影响。该参数也被称为内反馈系数。 输出：\\(\\dot I_c\\)可以看作是一个受控电流源的电流相加和电导\\(h_{22}\\)的分流。也就是一个电阻并联上一个受控电流源。 \\(h_{21}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：就是电流放大系数。 \\(h_{22}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：\\(u_{CE}\\)变化对\\(i_C\\)的影响大小，也就是c-e之间的电导。当输出特性曲线在放大区呈平行线时，电导为0，相当于这个并联的电阻无穷大。 近似分析时可忽略的参数： \\(h_{12}\\)：当\\(u_{CE}\\)大到一定程度即可忽略。 \\(h_{22}\\)：理想三极管的输出特性曲线在放大区呈平行线。于是得到下面简化的电路模型： \\(r_{be}\\)：其内部结构如下： \\(r_{bb^\\prime}\\)：基区体电阻。由于基区很薄，载流子浓度很低，所以该电阻往往不能忽略。该参数可通过查阅手册获得。 \\(r_{b^\\prime e^\\prime}\\)：发射结电阻。需要列PN结电流方程求解： \\[r_{\\text {be }}=\\frac{U_{\\text {be }}}{I_{b}}=r_{b b^{\\prime}}+r_{\\text {b’e }} \\approx r_{b b^{\\prime}}+(1+\\beta) \\frac{U_{T}}{I_{\\text {EQ }}}\\] \\(\\beta\\)：可通过测量得到。 \\(U_T\\)：常温下为\\(26\\text{mV}\\)。 \\(I_{EQ}\\)：发射极静态电流，可近似为集电极静态电流。 \\(r_{e^\\prime}\\)：发射区体电阻。发射区多数载流子浓度高，该电阻往往可以忽略。 混合\\(\\Pi\\)模型 在低频等效模型的基础上，考虑极间电容后，可以得到： \\(C_\\pi\\)：发射结的结电容 \\(C_\\mu\\)：集电结的结电容 \\(g_m\\) 在场效应管放大电路里见到的跨导。当信号具有高频特性时，电流会产生超前和时候，因此电流放大倍数\\(\\beta\\)是个会变化的值，而电压和阻抗不会发生变化，用跨导表示输出电流和输入电压的关系的更加合适。 这里的\\(C_\\mu\\)连接了输入回路和输出回路，不方便分析。由于\\(\\frac{\\dot U_\\mathrm{ce}}{\\dot U_\\mathrm{b^\\prime e}}=-g_mR^{\\prime}_L\\)可以看作定值，因此可以使用密勒定理对\\(C_\\mu\\)进行拆分： 拆分后必须保证输入回路流入\\(C_\\mu^\\prime\\)的电流等于拆分前流入\\(C_\\mu\\)的电流： \\[\\dot{I}_{C \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}-\\dot{U}_{\\mathrm{ce}}}{X_{C_{\\mu}}}=(1-k) \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{X_{C \\mu}}\\] 其中： \\[k\\approx-g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}\\] \\(g_m\\)是输出电流和输入电压的比值，乘上负载电阻就相当于电压放大倍数。\\(1-k\\)就是放大前后电压的差值，也就是原来\\(C_\\mu\\)两端的电压，除以阻抗得到原来流过\\(C_\\mu\\)的电流，也就是要流过\\(C_\\mu^\\prime\\)的电流，并且\\(C_\\mu^\\prime\\)的电压就是输入电压，得到\\(C_\\mu^\\prime\\)的阻抗： \\[X_{C^{\\prime} \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{I}_{C \\mu}} \\approx \\frac{X_{C \\mu}}{1+g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}}\\] 由容抗的公式\\(X_C=\\frac{1}{\\omega C}\\)可得，电容和容抗是反比例关系，得到\\(C_\\mu^\\prime\\)电容的表达式： \\[C_{\\mu}^{\\prime","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#等效电路法"},{"categories":null,"content":"放大电路的分析方法 直流通路和交流通路 用于分析放大电路的一种方法。 使用直流通路估算静态工作点：列晶体管输入、输出回路方程，将\\(U_{BEQ}\\)作为已知条件，令\\(I_{CQ}=\\beta I_{BQ}\\)，可估算出静态工作点。 \\[\\begin{cases} I_{\\mathrm{BQ}}=\\frac{V_{\\mathrm{BB}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{b}}}\\\\ I_{\\mathrm{CQ}}=\\beta I_{\\mathrm{BQ}} \\\\ U_{\\mathrm{CEQ}}=V_{\\mathrm{CC}}-I_{\\mathrm{CQ}} R_{\\mathrm{c}} \\end{cases}\\] 直流通路 令\\(U_s=0\\)，保留\\(R_s\\) 电容开路； 电感相当于短路（线圈电阻近似为0）。 交流通路 大容量电容相当于短路； 直流电源相当于短路（内阻为0）。也就是\\(V_{CC}\\)可以和地直接相连。 等效电路法 等效模型 直流等效模型 用于分析静态工作点。 交流等效模型 用于分析： 电压放大倍数 输入/输出电阻 h参数等效模型 从三极管的输入特性曲线和三极管的输出特性可以看出，\\(u_{BE},i_C\\)都可以表示为二元函数。 \\[\\begin{cases}u_{BE}=f(i_B,u_{CE})\\\\i_C=f(i_B,u_{CE})\\end{cases}\\] 对两边取全微分，得： \\[\\left\\{\\begin{array}{l} \\mathrm{d} u_{\\mathrm{BE}}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}} \\\\ \\mathrm{d} i_{\\mathrm{C}}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}} \\mathrm{d} i_{\\mathrm{B}}+\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}} \\mathrm{d} u_{\\mathrm{CE}}\\end{array}\\right.\\] 简化式子，得： \\[\\left\\{\\begin{array}{l} \\Delta u_{\\mathrm{BE}}=h_{11} \\Delta i_{\\mathrm{B}}+h_{12} \\Delta u_{\\mathrm{CE}} \\\\ \\Delta i_{\\mathrm{C}}=h_{21} \\Delta i_{\\mathrm{B}}+h_{22} \\Delta u_{\\mathrm{CE}}\\end{array}\\right.\\] \\(h_{11}\\)：表示一个电阻 \\(h_{22}\\)：表示一个电导 \\(h_{12}\\)、\\(h_{21}\\)：无量纲 用复数可以表示为： \\[\\left\\{\\begin{array}{c} \\dot{U}_{\\text {be }}=h_{11} \\dot{I}_{\\mathrm{b}}+h_{12} \\dot{U}_{\\text {ce}} \\\\ \\dot{I}_{\\mathrm{c}}=h_{21} \\dot{I}_{\\mathrm{b}}+h_{22} \\dot{U}_{\\text {ce}} \\end{array}\\right.\\] 分析式子可以构造等效电路图： 输入：\\(\\dot U_{be}\\)可以看作是电阻\\(h_{11}\\)的分压和一个受控电压源的电压相加。也就是一个电阻串联上一个受控电压源。 \\(h_{11}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：也就是一条三极管的输入特性曲线的斜率倒数，即动态电阻。 \\(h_{12}=\\left.\\frac{\\partial u_{\\mathrm{BE}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：也就是在\\(i_B\\)不变时，\\(\\Delta u_{BE}\\)和\\(\\Delta u_{CE}\\)比例。也就是\\(u_{CE}\\)变化对\\(u_{BE}\\)的影响大小。\\(u_{CE}\\)在一定范围内才会对\\(u_{BE}\\)产生影响。该参数也被称为内反馈系数。 输出：\\(\\dot I_c\\)可以看作是一个受控电流源的电流相加和电导\\(h_{22}\\)的分流。也就是一个电阻并联上一个受控电流源。 \\(h_{21}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial i_{\\mathrm{B}}}\\right|_{U_{\\mathrm{CE}}}\\)：就是电流放大系数。 \\(h_{22}=\\left.\\frac{\\partial i_{\\mathrm{C}}}{\\partial u_{\\mathrm{CE}}}\\right|_{I_{\\mathrm{B}}}\\)：\\(u_{CE}\\)变化对\\(i_C\\)的影响大小，也就是c-e之间的电导。当输出特性曲线在放大区呈平行线时，电导为0，相当于这个并联的电阻无穷大。 近似分析时可忽略的参数： \\(h_{12}\\)：当\\(u_{CE}\\)大到一定程度即可忽略。 \\(h_{22}\\)：理想三极管的输出特性曲线在放大区呈平行线。于是得到下面简化的电路模型： \\(r_{be}\\)：其内部结构如下： \\(r_{bb^\\prime}\\)：基区体电阻。由于基区很薄，载流子浓度很低，所以该电阻往往不能忽略。该参数可通过查阅手册获得。 \\(r_{b^\\prime e^\\prime}\\)：发射结电阻。需要列PN结电流方程求解： \\[r_{\\text {be }}=\\frac{U_{\\text {be }}}{I_{b}}=r_{b b^{\\prime}}+r_{\\text {b’e }} \\approx r_{b b^{\\prime}}+(1+\\beta) \\frac{U_{T}}{I_{\\text {EQ }}}\\] \\(\\beta\\)：可通过测量得到。 \\(U_T\\)：常温下为\\(26\\text{mV}\\)。 \\(I_{EQ}\\)：发射极静态电流，可近似为集电极静态电流。 \\(r_{e^\\prime}\\)：发射区体电阻。发射区多数载流子浓度高，该电阻往往可以忽略。 混合\\(\\Pi\\)模型 在低频等效模型的基础上，考虑极间电容后，可以得到： \\(C_\\pi\\)：发射结的结电容 \\(C_\\mu\\)：集电结的结电容 \\(g_m\\) 在场效应管放大电路里见到的跨导。当信号具有高频特性时，电流会产生超前和时候，因此电流放大倍数\\(\\beta\\)是个会变化的值，而电压和阻抗不会发生变化，用跨导表示输出电流和输入电压的关系的更加合适。 这里的\\(C_\\mu\\)连接了输入回路和输出回路，不方便分析。由于\\(\\frac{\\dot U_\\mathrm{ce}}{\\dot U_\\mathrm{b^\\prime e}}=-g_mR^{\\prime}_L\\)可以看作定值，因此可以使用密勒定理对\\(C_\\mu\\)进行拆分： 拆分后必须保证输入回路流入\\(C_\\mu^\\prime\\)的电流等于拆分前流入\\(C_\\mu\\)的电流： \\[\\dot{I}_{C \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}-\\dot{U}_{\\mathrm{ce}}}{X_{C_{\\mu}}}=(1-k) \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{X_{C \\mu}}\\] 其中： \\[k\\approx-g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}\\] \\(g_m\\)是输出电流和输入电压的比值，乘上负载电阻就相当于电压放大倍数。\\(1-k\\)就是放大前后电压的差值，也就是原来\\(C_\\mu\\)两端的电压，除以阻抗得到原来流过\\(C_\\mu\\)的电流，也就是要流过\\(C_\\mu^\\prime\\)的电流，并且\\(C_\\mu^\\prime\\)的电压就是输入电压，得到\\(C_\\mu^\\prime\\)的阻抗： \\[X_{C^{\\prime} \\mu}=\\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{I}_{C \\mu}} \\approx \\frac{X_{C \\mu}}{1+g_{\\mathrm{m}} R_{\\mathrm{L}}^{\\prime}}\\] 由容抗的公式\\(X_C=\\frac{1}{\\omega C}\\)可得，电容和容抗是反比例关系，得到\\(C_\\mu^\\prime\\)电容的表达式： \\[C_{\\mu}^{\\prime","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#图解法"},{"categories":null,"content":"基本共集放大电路 也叫做射极输出器。没有电压放大能力，但是有电流放大能力。 分析： 静态分析： \\[\\begin{array}{l} V_{\\mathrm{BB}}=I_{\\mathrm{BQ}} R_{\\mathrm{b}}+U_{\\mathrm{BEQ}}+I_{\\mathrm{EQ}} R_{\\mathrm{e}} \\\\ V_{\\mathrm{CC}}=U_{\\mathrm{CEQ}}+I_{\\mathrm{EQ}} R_{\\mathrm{e}} \\\\ I_{\\mathrm{BQ}}=\\frac{V_{\\mathrm{BB}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{b}}+(1+\\beta) R_{\\mathrm{e}}} \\\\ \\\\ I_{\\mathrm{EQ}}=(1+\\beta) I_{\\mathrm{BQ}} \\\\ U_{\\mathrm{CEQ}}=V_{\\mathrm{CC}}-I_{\\mathrm{EQ}} R_{\\mathrm{e}} \\end{array}\\] 动态分析：简化交流通路，得到： 由于电流总是从电位高的地方流向电位低的地方，所以\\(U_o\u003cU_i\\)，所以共集放大电路没有电压放大作用，只有电流放大作用。 电压放大倍数： \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=\\frac{\\dot{I}_{\\mathrm{e}} R_{\\mathrm{e}}}{\\dot{I}_{\\mathrm{b}}\\left(R_{\\mathrm{b}}+r_{\\mathrm{be}}\\right)+\\dot{I}_{\\mathrm{e}} R_{\\mathrm{e}}}=\\frac{(1+\\beta) R_{\\mathrm{e}}}{R_{\\mathrm{b}}+r_{\\mathrm{be}}+(1+\\beta) R_{\\mathrm{e}}}\\] 若\\((1+\\beta)R_e\\gg R_b+r_{be}\\)，则\\(\\dot A_u\\approx 1\\)，即\\(U_o\\approx U_i\\)。因此共集放大电路在一定条件下可称之为射极跟随器，具有电压跟随作用。 输入电阻：不接负载的情况下，输入电阻的表达式为： \\[R_{\\mathrm{i}}=\\frac{U_{\\mathrm{i}}}{I_{\\mathrm{i}}}=\\frac{I_{\\mathrm{b}}\\left[R_{\\mathrm{b}}+r_{\\mathrm{be}}+(1+\\beta) R_{\\mathrm{e}}\\right]}{I_{\\mathrm{b}}}=R_{\\mathrm{b}}+r_{\\mathrm{be}}+(1+\\beta) R_{\\mathrm{e}}\\] 带负载的话需要把\\(R_e\\)替换成\\(R_e\\|R_L\\)： \\[R_{\\mathrm{i}}=R_{\\mathrm{b}}+r_{\\mathrm{be}}+(1+\\beta)\\left(R_{\\mathrm{e}} \\| R_{\\mathrm{L}}\\right)\\] 可见基本共集放大电路的输入电阻与负载有关，并且从基极（输入）看发射极（输出）的电阻被放大了\\((1+\\beta)\\)倍。 输出电阻：由于把输入源置零了，电源等效变换也没什么用了，所以使用加压求流法，在输出端加上电压\\(\\dot U_o\\)： 可以得到输出电阻的表达式为： \\[R_{\\mathrm{o}}=\\frac{U_{\\mathrm{o}}}{I_{\\mathrm{o}}}=\\frac{U_{\\mathrm{o}}}{I_{R_{\\mathrm{e}}}+I_{\\mathrm{e}}}=\\frac{U_{\\mathrm{o}}}{\\frac{U_{\\mathrm{o}}}{R_{\\mathrm{e}}}+(1+\\beta) \\frac{U_{\\mathrm{o}}}{R_{\\mathrm{b}}+r_{\\mathrm{be}}}}=R_{\\mathrm{e}} \\| \\frac{R_{\\mathrm{b}}+r_{\\mathrm{be}}}{1+\\beta}\\] 可见输出电阻与信号源的内阻有关，并且从射极（输出）看基极（输入）回路电阻被减小到\\((1+\\beta)\\)倍。 射极跟随器。 特点： 输入电阻大，输出电阻小 只放大电流，不放大电压 在一定条件下有电压跟随作用 用途：可以用作复杂放大电路的前级或者后级。 输入极：输入电阻大，可以尽可能地让电压降落在它的两端。 输出极：输出电阻小，在不损失放大倍数的前提下，提高带负载能力。 中间：使两个电路相互的影响尽可能得小。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本共集放大电路"},{"categories":null,"content":"基本共基放大电路 静态分析： 注意： 虽然基极被接地了，但不代表发射结或集电结压降为0。 在NPN管下，输入源只是吸收功率，控制其两端的压降，而不是发出功率，提供电压。 根据电压关系，可以得到： \\[\\left\\{\\begin{array}{l} U_{\\mathrm{BEQ}}+I_{\\mathrm{EQ}} R_{\\mathrm{e}}=V_{\\mathrm{BB}} \\\\ I_{\\mathrm{CQ}} R_{\\mathrm{e}}+U_{\\mathrm{CEQ}}-U_{\\mathrm{BEQ}}=V_{\\mathrm{CC}} \\end{array}\\right.\\] 得到静态工作参数： \\[\\begin{aligned} I_{\\mathrm{EQ}}\u0026=\\frac{V_{\\mathrm{BB}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{e}}} \\\\ I_{\\mathrm{BQ}}\u0026=\\frac{I_{\\mathrm{EQ}}}{1+\\beta} \\\\ U_{\\mathrm{CEQ}}\u0026 \\approx V_{\\mathrm{CC}}-I_{\\mathrm{EQ}} R_{\\mathrm{c}}+U_{\\mathrm{BEQ}} \\end{aligned}\\] 动态分析：画出交流通路的简化电路： 注意此处的电流流向，虽然电路的真实流向与之相反，但此电路中动态信号的微小正向电流，相当于是真实电流的微小减弱。假设的正向电流与与假设的输出电压方向是相同的，也就是共基放大电路的输出与输入是同相的。由于这里的动态电流的关系为\\(i_e=i_b+i_c\\)，输出的电流永远是小于输入电流的，所以该放大电路没有电流放大能力。一定条件下，具有电流跟随能力。用动态小电流的思路，很容易获得该放大电路的动态参数为： \\[\\begin{aligned} \\dot{A}_{u}\u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=\\frac{\\dot{I}_{\\mathrm{c}} R_{\\mathrm{c}}}{\\dot{I}_{\\mathrm{e}} R_{\\mathrm{e}}+\\dot{I}_{\\mathrm{b}} r_{\\mathrm{be}}}=\\frac{\\beta R_{\\mathrm{c}}}{r_{\\mathrm{be}}+(1+\\beta) R_{\\mathrm{e}}} \\\\ R_{\\mathrm{i}}\u0026=R_{\\mathrm{e}}+\\frac{r_{\\mathrm{be}}}{1+\\beta} \\\\ R_{\\mathrm{o}}\u0026=R_{\\mathrm{c}} \\end{aligned}\\] 如果采用阻容耦合电路，\\(\\dot A_u\\)分母中的\\(\\beta\\)就不存在了，此时电压放大倍数可以与共射放大电路相比。 特点： 输入电阻小 频带宽 只放大电压，不放大电流 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本共基放大电路"},{"categories":null,"content":"静态工作点的稳定 静态工作点的稳定： 也称为分压式电流负反馈工作点稳定电路： Q点稳定，是指\\(I_{CQ}\\)和\\(U_{CEQ}\\)在温度变化时基本不变，这是靠\\(I_{BQ}\\)的变化得来的。 第一个电路是直接耦合，第二个电路是阻容耦合，并且增加了电容\\(C_e\\)，称为旁路电容。上面两个电路的直流通路均为： 为了稳定\\(U_{BQ}\\)点（\\(R_{b1}\\)的作用），则要求\\(I_1\\gg I_B\\)，以保证\\(I_1\\approx I_2\\)，得到： \\[U_{\\text {вQ }} \\approx \\frac{R_{\\mathrm{b} 1}}{R_{\\mathrm{b} 1}+R_{\\mathrm{b} 2}} \\cdot V_{\\mathrm{CC}}\\] \\[I_{\\mathrm{EQ}}=\\frac{U_{\\mathrm{BQ}}-U_{\\mathrm{BEQ}}}{R_{\\mathrm{e}}}\\] 同时： \\[I_{EQ}=(1+\\beta)I_{BQ}=(1+\\beta)\\frac{U_{BEQ}}{r_{be}}\\] \\(R_e\\)的作用：温度升高→\\(I_B,\\beta\\)增大→\\(I_C\\)增大→\\(U_E\\)增大（\\(R_e\\)分压）→\\(U_{BE}\\)减小→\\(I_B\\)减小→\\(I_C\\)减小。即提供直流负反馈。显然，\\(R_e\\)越大分得的电压越多，反馈力度越大，但是\\(R_e\\)也影响静态工作点，并不是越大越好。 \\[U_{\\text {CEQ }}=V_{\\text {CC }}-I_{\\text {сQ }} R_{\\mathrm{c}}-I_{\\mathrm{EQ}} R_{\\mathrm{e}} \\approx V_{\\text {CC }}-I_{\\text {ЕQ }}\\left(R_{\\mathrm{c}}+R_{\\mathrm{e}}\\right)\\] 像这种两个电阻\\(R_{b1},R_{b2}\\)串联分压产生的电压源，可以利用戴维南定理，把它等效成一个理想源\\(V_{BB}\\)和一个电阻\\(R_b\\)串联： \\[R_b=R_{b1}\\|R_{b2}\\] 由于\\(R_{b1}\\|R_{b2}\\gg(1+\\beta)R_e\\)，电阻\\(R_b\\)上的分压可以忽略不计： \\[U_{BQ}\\approx V_{BB}=V_{CC}\\cdot\\frac{R_{b1}}{R_{b1}+R_{b2}}\\] 旁路电容\\(C_e\\)的作用： 对第二个电路进行动态分析，得到交流通路为： 可以得到放大倍数为： \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=-\\frac{\\beta R_{\\mathrm{L}}^{\\prime}}{r_{\\mathrm{be}}}\\] 输入电阻和输出电阻为： \\[\\begin{aligned} R_i \u0026=R_{b1}\\|R_{b2}\\|r_{be} \\\\ R_o \u0026=R_c \\end{aligned}\\] 然后假设把电路从P点断开，得到新的交流通路： 输入电阻变为： \\[R_i=R_{b1}\\|R_{b2}\\|[r_{be}+(1+\\beta)R_e]\\] 注意这里所有的\\(R_e\\)始终要跟在\\((1+\\beta)\\)的后面，因为从输入端看， 受控电流源的电流与输入的电流有关，这个受控源可以等效为一个电阻，所以不能视为开路。 受控电流源和一个电阻并联，可以通过电源等效变换把它变成电阻和一个受控电压源串联，再把电压源置零，即可得到\\((1+\\beta)R_e\\)。因此以后看共射放大电路的输入电阻就可以直接看了，接在基极上的电阻和\\(r_{be}\\)串联，然后再和乘上\\(1+\\beta\\)倍的接在发射极的电阻串联。计算输出电阻也是一样，先计算发射极的电阻，然后与除以\\(1+\\beta\\)后的基极电阻串联。 得到新的放大倍数为： \\[\\begin{aligned} \\dot{A}_{u} \u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{i}}} \\\\ \u0026=\\frac{-\\beta \\dot{I}_{\\mathrm{b}}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)}{\\dot{I}_{\\mathrm{b}} r_{\\mathrm{be}}+\\dot{I}_{\\mathrm{e}} R_{\\mathrm{e}}}=-\\frac{\\beta R_{\\mathrm{L}}^{\\prime}}{r_{\\mathrm{be}}+(1+\\beta) R_{\\mathrm{e}}} \\end{aligned}\\] 若\\((1+\\beta)R_e\\gg r_{be}\\)，则\\(\\dot A_u\\approx -\\frac{R_L^\\prime}{R_e}\\)。可见没有旁路电容的情况下，放大倍数基本不再和晶体管的本身参数相关了，自然也不怎么会受到温度影响，但是放大倍数大大下降。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:6","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#静态工作点的稳定"},{"categories":null,"content":"基本共源放大电路 静态分析 根据场效应管工作在恒流区的条件，有： \\[\\begin{aligned} U_{\\mathrm{GSQ}}\u0026=V_{\\mathrm{BB}} \\\\ I_{\\mathrm{DQ}}\u0026=I_{\\mathrm{DO}}\\left(\\frac{V_{\\mathrm{BB}}}{U_{\\mathrm{GS}(\\mathrm{th)}}}-1\\right)^{2} \\\\ U_{\\mathrm{DSQ}}\u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}} R_{\\mathrm{d}} \\end{aligned}\\] 动态分析 \\[\\begin{aligned} \\dot{A}_{u}\u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=\\frac{-\\dot{I}_{\\mathrm{d}} R_{\\mathrm{d}}}{\\dot{U}_{\\mathrm{gs}}}=-g_{\\mathrm{m}} R_{\\mathrm{d}} \\\\ R_{\\mathrm{i}}\u0026=\\infty \\\\ R_{0}\u0026=R_{\\mathrm{d}} \\end{aligned}\\] 自给偏压电路 像结型场效应管和耗尽型绝缘栅型场效应管都需要栅极和源极之间有负的偏压，在没有负电源的情况下，可以通过电路自身电位设置得到： \\[\\begin{aligned} U_{\\mathrm{GQ}} \u0026=0 \\\\ U_{\\mathrm{sQ}} \u0026=I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ U_{\\mathrm{GSQ}} \u0026=U_{\\mathrm{GQ}}-U_{\\mathrm{sQ}}=-I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ I_{\\mathrm{DQ}} \u0026=I_{\\mathrm{Dss}}\\left(1-\\frac{U_{\\mathrm{GSQ}}}{U_{\\mathrm{GS}(\\mathrm{off})}}\\right)^{2} \\\\ U_{\\mathrm{DSQ}} \u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}}\\left(R_{\\mathrm{d}}+R_{\\mathrm{s}}\\right) \\end{aligned}\\] 由正电源获得负偏压称为自给偏压。 分压式偏置电路 也就是场效应管中的Q点稳定电路。可以给栅极和源极之间提供正偏压： \\[\\begin{aligned} U_{\\mathrm{GQ}}\u0026=U_{\\mathrm{AQ}}=\\frac{R_{\\mathrm{g} 1}}{R_{\\mathrm{g} 1}+R_{\\mathrm{g} 2}} \\cdot V_{\\mathrm{DD}} \\\\ U_{\\mathrm{SQ}}\u0026=I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ I_{\\mathrm{DQ}}\u0026=I_{\\mathrm{DO}}\\left(\\frac{U_{\\mathrm{GSQ}}}{U_{\\mathrm{GS}(\\mathrm{th})}}-1\\right)^{2} \\\\ U_{\\mathrm{DSQ}}\u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}}\\left(R_{\\mathrm{d}}+R_{\\mathrm{s}}\\right) \\end{aligned}\\] \\(R_{g3}\\)的作用 由于场效应管的栅极输入电阻很大，加入这个电阻可以确保在交流通路中，输入电阻不会因为分压电路而减小得过多。但该电阻也不能取的太大，否则会引入噪声（电阻越大，越容易产生噪声）。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:7","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本共源放大电路"},{"categories":null,"content":"基本共源放大电路 静态分析 根据场效应管工作在恒流区的条件，有： \\[\\begin{aligned} U_{\\mathrm{GSQ}}\u0026=V_{\\mathrm{BB}} \\\\ I_{\\mathrm{DQ}}\u0026=I_{\\mathrm{DO}}\\left(\\frac{V_{\\mathrm{BB}}}{U_{\\mathrm{GS}(\\mathrm{th)}}}-1\\right)^{2} \\\\ U_{\\mathrm{DSQ}}\u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}} R_{\\mathrm{d}} \\end{aligned}\\] 动态分析 \\[\\begin{aligned} \\dot{A}_{u}\u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=\\frac{-\\dot{I}_{\\mathrm{d}} R_{\\mathrm{d}}}{\\dot{U}_{\\mathrm{gs}}}=-g_{\\mathrm{m}} R_{\\mathrm{d}} \\\\ R_{\\mathrm{i}}\u0026=\\infty \\\\ R_{0}\u0026=R_{\\mathrm{d}} \\end{aligned}\\] 自给偏压电路 像结型场效应管和耗尽型绝缘栅型场效应管都需要栅极和源极之间有负的偏压，在没有负电源的情况下，可以通过电路自身电位设置得到： \\[\\begin{aligned} U_{\\mathrm{GQ}} \u0026=0 \\\\ U_{\\mathrm{sQ}} \u0026=I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ U_{\\mathrm{GSQ}} \u0026=U_{\\mathrm{GQ}}-U_{\\mathrm{sQ}}=-I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ I_{\\mathrm{DQ}} \u0026=I_{\\mathrm{Dss}}\\left(1-\\frac{U_{\\mathrm{GSQ}}}{U_{\\mathrm{GS}(\\mathrm{off})}}\\right)^{2} \\\\ U_{\\mathrm{DSQ}} \u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}}\\left(R_{\\mathrm{d}}+R_{\\mathrm{s}}\\right) \\end{aligned}\\] 由正电源获得负偏压称为自给偏压。 分压式偏置电路 也就是场效应管中的Q点稳定电路。可以给栅极和源极之间提供正偏压： \\[\\begin{aligned} U_{\\mathrm{GQ}}\u0026=U_{\\mathrm{AQ}}=\\frac{R_{\\mathrm{g} 1}}{R_{\\mathrm{g} 1}+R_{\\mathrm{g} 2}} \\cdot V_{\\mathrm{DD}} \\\\ U_{\\mathrm{SQ}}\u0026=I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ I_{\\mathrm{DQ}}\u0026=I_{\\mathrm{DO}}\\left(\\frac{U_{\\mathrm{GSQ}}}{U_{\\mathrm{GS}(\\mathrm{th})}}-1\\right)^{2} \\\\ U_{\\mathrm{DSQ}}\u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}}\\left(R_{\\mathrm{d}}+R_{\\mathrm{s}}\\right) \\end{aligned}\\] \\(R_{g3}\\)的作用 由于场效应管的栅极输入电阻很大，加入这个电阻可以确保在交流通路中，输入电阻不会因为分压电路而减小得过多。但该电阻也不能取的太大，否则会引入噪声（电阻越大，越容易产生噪声）。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:7","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#自给偏压电路"},{"categories":null,"content":"基本共源放大电路 静态分析 根据场效应管工作在恒流区的条件，有： \\[\\begin{aligned} U_{\\mathrm{GSQ}}\u0026=V_{\\mathrm{BB}} \\\\ I_{\\mathrm{DQ}}\u0026=I_{\\mathrm{DO}}\\left(\\frac{V_{\\mathrm{BB}}}{U_{\\mathrm{GS}(\\mathrm{th)}}}-1\\right)^{2} \\\\ U_{\\mathrm{DSQ}}\u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}} R_{\\mathrm{d}} \\end{aligned}\\] 动态分析 \\[\\begin{aligned} \\dot{A}_{u}\u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=\\frac{-\\dot{I}_{\\mathrm{d}} R_{\\mathrm{d}}}{\\dot{U}_{\\mathrm{gs}}}=-g_{\\mathrm{m}} R_{\\mathrm{d}} \\\\ R_{\\mathrm{i}}\u0026=\\infty \\\\ R_{0}\u0026=R_{\\mathrm{d}} \\end{aligned}\\] 自给偏压电路 像结型场效应管和耗尽型绝缘栅型场效应管都需要栅极和源极之间有负的偏压，在没有负电源的情况下，可以通过电路自身电位设置得到： \\[\\begin{aligned} U_{\\mathrm{GQ}} \u0026=0 \\\\ U_{\\mathrm{sQ}} \u0026=I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ U_{\\mathrm{GSQ}} \u0026=U_{\\mathrm{GQ}}-U_{\\mathrm{sQ}}=-I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ I_{\\mathrm{DQ}} \u0026=I_{\\mathrm{Dss}}\\left(1-\\frac{U_{\\mathrm{GSQ}}}{U_{\\mathrm{GS}(\\mathrm{off})}}\\right)^{2} \\\\ U_{\\mathrm{DSQ}} \u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}}\\left(R_{\\mathrm{d}}+R_{\\mathrm{s}}\\right) \\end{aligned}\\] 由正电源获得负偏压称为自给偏压。 分压式偏置电路 也就是场效应管中的Q点稳定电路。可以给栅极和源极之间提供正偏压： \\[\\begin{aligned} U_{\\mathrm{GQ}}\u0026=U_{\\mathrm{AQ}}=\\frac{R_{\\mathrm{g} 1}}{R_{\\mathrm{g} 1}+R_{\\mathrm{g} 2}} \\cdot V_{\\mathrm{DD}} \\\\ U_{\\mathrm{SQ}}\u0026=I_{\\mathrm{DQ}} R_{\\mathrm{s}} \\\\ I_{\\mathrm{DQ}}\u0026=I_{\\mathrm{DO}}\\left(\\frac{U_{\\mathrm{GSQ}}}{U_{\\mathrm{GS}(\\mathrm{th})}}-1\\right)^{2} \\\\ U_{\\mathrm{DSQ}}\u0026=V_{\\mathrm{DD}}-I_{\\mathrm{DQ}}\\left(R_{\\mathrm{d}}+R_{\\mathrm{s}}\\right) \\end{aligned}\\] \\(R_{g3}\\)的作用 由于场效应管的栅极输入电阻很大，加入这个电阻可以确保在交流通路中，输入电阻不会因为分压电路而减小得过多。但该电阻也不能取的太大，否则会引入噪声（电阻越大，越容易产生噪声）。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:7","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#分压式偏置电路"},{"categories":null,"content":"基本共漏放大电路 动态分析 \\[\\begin{aligned} \\dot{A}_{u} \u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{i}}}=\\frac{\\dot{I}_{\\mathrm{d}} R_{\\mathrm{s}}}{\\dot{U}_{\\mathrm{gs}}+\\dot{I}_{\\mathrm{d}} R_{\\mathrm{s}}}=\\frac{g_{\\mathrm{m}} R_{\\mathrm{s}}}{1+g_{\\mathrm{m}} R_{\\mathrm{s}}} \\\\ R_{\\mathrm{i}}\u0026=\\infty \\end{aligned}\\] 输出电阻采用加压求流的方式分析： 得到输出电阻： \\[R_{\\mathrm{o}}=\\frac{U_{\\mathrm{o}}}{I_{\\mathrm{o}}}=\\frac{U_{\\mathrm{o}}}{\\frac{U_{\\mathrm{o}}}{R_{\\mathrm{s}}}+g_{\\mathrm{m}} U_{\\mathrm{o}}}=R_{\\mathrm{s}} / / \\frac{1}{g_{\\mathrm{m}}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:8","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本共漏放大电路"},{"categories":null,"content":"共射放大电路 单管共射放大电路的频率响应 适用于信号频率从\\(0\\sim\\infty\\)的交流等效电路： 中频段 把\\(C\\)看作短路，把\\(C_\\pi\\)开路： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usm}} \u0026=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{i}}} \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{b}^{\\prime}}} \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left[-g_{\\mathrm{m}}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)\\right] \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{\\beta_{0}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)}{r_{\\mathrm{be}}} \\end{aligned}\\] 其中： \\(g_{\\mathrm{m}} =\\frac{\\beta_{0}}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}\\) \\(r_{be}=r_{bb^\\prime}+r_{b^\\prime e}\\) 并且在空载时： \\[\\dot{A}_{\\mathrm{usmo}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\] 低频段 可以把\\(\\dot U_s,R_s\\)看作输入，把\\(C,R_L\\)看作输出，中间看作一个二端口网络： 由于输出回路是一个高通电路，\\(\\dot I_O\\)超前\\(\\dot U_O\\)，因此\\(\\dot U_O\\)超前\\(\\dot U_{OO}\\)： 得到在低频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usl}}\u0026=\\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{U_{\\mathrm{oo}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{oo}}}=\\dot{A}_{u \\mathrm{smo}} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{j \\omega C}+R_{\\mathrm{L}}}\\\\ \u0026=\\dot{A}_{u s m o} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{\\mathrm{j} \\omega C}+R_{\\mathrm{L}}} \\cdot \\frac{R_{\\mathrm{c}}+R_{\\mathrm{L}}}{R_{\\mathrm{c}}+R_{\\mathrm{L}}}=\\frac{\\dot{A}_{u \\mathrm{sm}}}{1+\\frac{1}{\\mathrm{j} \\omega\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}}\\\\ \u0026=\\dot{A}_{u s m} \\cdot \\frac{1}{1+f_{\\mathrm{L}} /(\\mathrm{j} f)}=\\dot{A}_{\\mathrm{usm}} \\cdot \\frac{j f / f_{\\mathrm{L}}}{1+j f / f_{\\mathrm{L}}} \\end{aligned}\\Rightarrow \\left\\{\\begin{array}{l} 20 \\lg \\left|\\dot{A}_{u s \\mid}\\right|=20 \\lg \\left|\\dot{A}_{u s m}\\right|-20 \\lg \\sqrt{1+\\left(\\frac{f_{\\mathrm{L}}}{f}\\right)^{2}} \\\\ \\varphi=-180^{\\circ}+\\left(90^{\\circ}-\\arctan \\frac{f}{f_{\\mathrm{L}}}\\right) \\\\ \\end{array}\\right.\\] 其中： \\(\\frac{R_C+R_L}{R_C+R_L}\\) 与\\(R_L\\)相乘凑出\\(R_C\\|R_L\\)，也就是\\(\\dot A_{usm}\\)的一部分。 \\(A_{\\text { usmo }}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\) \\(f_{\\mathrm{L}}=\\frac{1}{2 \\pi\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}\\) \\((R_C+R_L)C\\)其实就是输出回路的时间常数，因此求低频段下的电压放大倍数就可以改为求中频段下的电压放大倍数和\\(f_L\\)，而\\(f_L\\)可以通过时间常数求出，求时间常数就要知道电容所在回路的电阻，因此就可以简化低频段电压放大倍数的求解。 \\(\\varphi\\)：可以得出，在\\(f\u003ef_L\\)的情况下，单管放大电路的相移最多为\\(45^\\circ\\)。 \\(\\omega=2\\pi f\\) \\(f\\gg f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left|\\dot{A}_{u s m}\\right|\\)。 \\(f=f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right|\\)下降\\(3\\text{dB}\\)且\\(\\varphi=-135^\\circ\\)。 \\(f\\ll f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left(\\dot{A}_{u s m} \\frac{f}{f_{\\mathrm{L}}}\\right)\\)。 \\(f\\to 0\\)：\\(\\left|\\dot A_{us}\\right|\\to 0\\)且\\(\\varphi\\to -90^\\circ\\)。 高频段 把\\(b,e\\)以左的电路进行戴维南等效变换后看作输入，\\(R_L\\)看作输出，中间看成一个二端口网络： \\(\\dot U_s^\\prime\\) 也就是变换前\\(b,e\\)的开路电压： \\[\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime}}}{\\dot{U}_{\\mathrm{i}}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime}}}{r_{\\mathrm{be}}}\\] \\(R=r_{\\mathrm{b}^{\\prime} \\mathrm{e}} / /\\left(r_{\\mathrm{bb}}+R_{\\mathrm{b}} / / R_{\\mathrm{s}}\\right)\\) 由于二端口网络的输入端内部是一个电容，因此该电路是一个低通电路\\(\\dot I_S\\)超前导致\\(\\dot U_R\\)超前，而 \\(\\dot U_R,\\dot U_{C_\\pi}^\\prime,\\dot U_S^\\prime\\)满足平行四边形法则，\\(\\dot U_{C_\\pi}^\\prime\\)滞后： 得到在高频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{u s h} \u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{C}_{\\pi}^{\\prime}}}{\\dot{U}_{\\mathrm{s}}^","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:9","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#共射放大电路"},{"categories":null,"content":"共射放大电路 单管共射放大电路的频率响应 适用于信号频率从\\(0\\sim\\infty\\)的交流等效电路： 中频段 把\\(C\\)看作短路，把\\(C_\\pi\\)开路： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usm}} \u0026=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{i}}} \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{b}^{\\prime}}} \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left[-g_{\\mathrm{m}}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)\\right] \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{\\beta_{0}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)}{r_{\\mathrm{be}}} \\end{aligned}\\] 其中： \\(g_{\\mathrm{m}} =\\frac{\\beta_{0}}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}\\) \\(r_{be}=r_{bb^\\prime}+r_{b^\\prime e}\\) 并且在空载时： \\[\\dot{A}_{\\mathrm{usmo}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\] 低频段 可以把\\(\\dot U_s,R_s\\)看作输入，把\\(C,R_L\\)看作输出，中间看作一个二端口网络： 由于输出回路是一个高通电路，\\(\\dot I_O\\)超前\\(\\dot U_O\\)，因此\\(\\dot U_O\\)超前\\(\\dot U_{OO}\\)： 得到在低频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usl}}\u0026=\\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{U_{\\mathrm{oo}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{oo}}}=\\dot{A}_{u \\mathrm{smo}} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{j \\omega C}+R_{\\mathrm{L}}}\\\\ \u0026=\\dot{A}_{u s m o} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{\\mathrm{j} \\omega C}+R_{\\mathrm{L}}} \\cdot \\frac{R_{\\mathrm{c}}+R_{\\mathrm{L}}}{R_{\\mathrm{c}}+R_{\\mathrm{L}}}=\\frac{\\dot{A}_{u \\mathrm{sm}}}{1+\\frac{1}{\\mathrm{j} \\omega\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}}\\\\ \u0026=\\dot{A}_{u s m} \\cdot \\frac{1}{1+f_{\\mathrm{L}} /(\\mathrm{j} f)}=\\dot{A}_{\\mathrm{usm}} \\cdot \\frac{j f / f_{\\mathrm{L}}}{1+j f / f_{\\mathrm{L}}} \\end{aligned}\\Rightarrow \\left\\{\\begin{array}{l} 20 \\lg \\left|\\dot{A}_{u s \\mid}\\right|=20 \\lg \\left|\\dot{A}_{u s m}\\right|-20 \\lg \\sqrt{1+\\left(\\frac{f_{\\mathrm{L}}}{f}\\right)^{2}} \\\\ \\varphi=-180^{\\circ}+\\left(90^{\\circ}-\\arctan \\frac{f}{f_{\\mathrm{L}}}\\right) \\\\ \\end{array}\\right.\\] 其中： \\(\\frac{R_C+R_L}{R_C+R_L}\\) 与\\(R_L\\)相乘凑出\\(R_C\\|R_L\\)，也就是\\(\\dot A_{usm}\\)的一部分。 \\(A_{\\text { usmo }}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\) \\(f_{\\mathrm{L}}=\\frac{1}{2 \\pi\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}\\) \\((R_C+R_L)C\\)其实就是输出回路的时间常数，因此求低频段下的电压放大倍数就可以改为求中频段下的电压放大倍数和\\(f_L\\)，而\\(f_L\\)可以通过时间常数求出，求时间常数就要知道电容所在回路的电阻，因此就可以简化低频段电压放大倍数的求解。 \\(\\varphi\\)：可以得出，在\\(f\u003ef_L\\)的情况下，单管放大电路的相移最多为\\(45^\\circ\\)。 \\(\\omega=2\\pi f\\) \\(f\\gg f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left|\\dot{A}_{u s m}\\right|\\)。 \\(f=f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right|\\)下降\\(3\\text{dB}\\)且\\(\\varphi=-135^\\circ\\)。 \\(f\\ll f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left(\\dot{A}_{u s m} \\frac{f}{f_{\\mathrm{L}}}\\right)\\)。 \\(f\\to 0\\)：\\(\\left|\\dot A_{us}\\right|\\to 0\\)且\\(\\varphi\\to -90^\\circ\\)。 高频段 把\\(b,e\\)以左的电路进行戴维南等效变换后看作输入，\\(R_L\\)看作输出，中间看成一个二端口网络： \\(\\dot U_s^\\prime\\) 也就是变换前\\(b,e\\)的开路电压： \\[\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime}}}{\\dot{U}_{\\mathrm{i}}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime}}}{r_{\\mathrm{be}}}\\] \\(R=r_{\\mathrm{b}^{\\prime} \\mathrm{e}} / /\\left(r_{\\mathrm{bb}}+R_{\\mathrm{b}} / / R_{\\mathrm{s}}\\right)\\) 由于二端口网络的输入端内部是一个电容，因此该电路是一个低通电路\\(\\dot I_S\\)超前导致\\(\\dot U_R\\)超前，而 \\(\\dot U_R,\\dot U_{C_\\pi}^\\prime,\\dot U_S^\\prime\\)满足平行四边形法则，\\(\\dot U_{C_\\pi}^\\prime\\)滞后： 得到在高频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{u s h} \u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{C}_{\\pi}^{\\prime}}}{\\dot{U}_{\\mathrm{s}}^","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:9","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#单管共射放大电路的频率响应"},{"categories":null,"content":"共射放大电路 单管共射放大电路的频率响应 适用于信号频率从\\(0\\sim\\infty\\)的交流等效电路： 中频段 把\\(C\\)看作短路，把\\(C_\\pi\\)开路： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usm}} \u0026=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{i}}} \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{b}^{\\prime}}} \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left[-g_{\\mathrm{m}}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)\\right] \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{\\beta_{0}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)}{r_{\\mathrm{be}}} \\end{aligned}\\] 其中： \\(g_{\\mathrm{m}} =\\frac{\\beta_{0}}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}\\) \\(r_{be}=r_{bb^\\prime}+r_{b^\\prime e}\\) 并且在空载时： \\[\\dot{A}_{\\mathrm{usmo}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\] 低频段 可以把\\(\\dot U_s,R_s\\)看作输入，把\\(C,R_L\\)看作输出，中间看作一个二端口网络： 由于输出回路是一个高通电路，\\(\\dot I_O\\)超前\\(\\dot U_O\\)，因此\\(\\dot U_O\\)超前\\(\\dot U_{OO}\\)： 得到在低频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usl}}\u0026=\\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{U_{\\mathrm{oo}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{oo}}}=\\dot{A}_{u \\mathrm{smo}} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{j \\omega C}+R_{\\mathrm{L}}}\\\\ \u0026=\\dot{A}_{u s m o} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{\\mathrm{j} \\omega C}+R_{\\mathrm{L}}} \\cdot \\frac{R_{\\mathrm{c}}+R_{\\mathrm{L}}}{R_{\\mathrm{c}}+R_{\\mathrm{L}}}=\\frac{\\dot{A}_{u \\mathrm{sm}}}{1+\\frac{1}{\\mathrm{j} \\omega\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}}\\\\ \u0026=\\dot{A}_{u s m} \\cdot \\frac{1}{1+f_{\\mathrm{L}} /(\\mathrm{j} f)}=\\dot{A}_{\\mathrm{usm}} \\cdot \\frac{j f / f_{\\mathrm{L}}}{1+j f / f_{\\mathrm{L}}} \\end{aligned}\\Rightarrow \\left\\{\\begin{array}{l} 20 \\lg \\left|\\dot{A}_{u s \\mid}\\right|=20 \\lg \\left|\\dot{A}_{u s m}\\right|-20 \\lg \\sqrt{1+\\left(\\frac{f_{\\mathrm{L}}}{f}\\right)^{2}} \\\\ \\varphi=-180^{\\circ}+\\left(90^{\\circ}-\\arctan \\frac{f}{f_{\\mathrm{L}}}\\right) \\\\ \\end{array}\\right.\\] 其中： \\(\\frac{R_C+R_L}{R_C+R_L}\\) 与\\(R_L\\)相乘凑出\\(R_C\\|R_L\\)，也就是\\(\\dot A_{usm}\\)的一部分。 \\(A_{\\text { usmo }}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\) \\(f_{\\mathrm{L}}=\\frac{1}{2 \\pi\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}\\) \\((R_C+R_L)C\\)其实就是输出回路的时间常数，因此求低频段下的电压放大倍数就可以改为求中频段下的电压放大倍数和\\(f_L\\)，而\\(f_L\\)可以通过时间常数求出，求时间常数就要知道电容所在回路的电阻，因此就可以简化低频段电压放大倍数的求解。 \\(\\varphi\\)：可以得出，在\\(f\u003ef_L\\)的情况下，单管放大电路的相移最多为\\(45^\\circ\\)。 \\(\\omega=2\\pi f\\) \\(f\\gg f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left|\\dot{A}_{u s m}\\right|\\)。 \\(f=f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right|\\)下降\\(3\\text{dB}\\)且\\(\\varphi=-135^\\circ\\)。 \\(f\\ll f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left(\\dot{A}_{u s m} \\frac{f}{f_{\\mathrm{L}}}\\right)\\)。 \\(f\\to 0\\)：\\(\\left|\\dot A_{us}\\right|\\to 0\\)且\\(\\varphi\\to -90^\\circ\\)。 高频段 把\\(b,e\\)以左的电路进行戴维南等效变换后看作输入，\\(R_L\\)看作输出，中间看成一个二端口网络： \\(\\dot U_s^\\prime\\) 也就是变换前\\(b,e\\)的开路电压： \\[\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime}}}{\\dot{U}_{\\mathrm{i}}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime}}}{r_{\\mathrm{be}}}\\] \\(R=r_{\\mathrm{b}^{\\prime} \\mathrm{e}} / /\\left(r_{\\mathrm{bb}}+R_{\\mathrm{b}} / / R_{\\mathrm{s}}\\right)\\) 由于二端口网络的输入端内部是一个电容，因此该电路是一个低通电路\\(\\dot I_S\\)超前导致\\(\\dot U_R\\)超前，而 \\(\\dot U_R,\\dot U_{C_\\pi}^\\prime,\\dot U_S^\\prime\\)满足平行四边形法则，\\(\\dot U_{C_\\pi}^\\prime\\)滞后： 得到在高频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{u s h} \u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{C}_{\\pi}^{\\prime}}}{\\dot{U}_{\\mathrm{s}}^","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:9","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#单管共源放大电路的频率响应"},{"categories":null,"content":"共射放大电路 单管共射放大电路的频率响应 适用于信号频率从\\(0\\sim\\infty\\)的交流等效电路： 中频段 把\\(C\\)看作短路，把\\(C_\\pi\\)开路： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usm}} \u0026=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{i}}} \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{b}^{\\prime}}} \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left[-g_{\\mathrm{m}}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)\\right] \\\\ \u0026=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{\\beta_{0}\\left(R_{\\mathrm{c}} / / R_{\\mathrm{L}}\\right)}{r_{\\mathrm{be}}} \\end{aligned}\\] 其中： \\(g_{\\mathrm{m}} =\\frac{\\beta_{0}}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}\\) \\(r_{be}=r_{bb^\\prime}+r_{b^\\prime e}\\) 并且在空载时： \\[\\dot{A}_{\\mathrm{usmo}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\] 低频段 可以把\\(\\dot U_s,R_s\\)看作输入，把\\(C,R_L\\)看作输出，中间看作一个二端口网络： 由于输出回路是一个高通电路，\\(\\dot I_O\\)超前\\(\\dot U_O\\)，因此\\(\\dot U_O\\)超前\\(\\dot U_{OO}\\)： 得到在低频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{\\mathrm{usl}}\u0026=\\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{U_{\\mathrm{oo}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{U_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{oo}}}=\\dot{A}_{u \\mathrm{smo}} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{j \\omega C}+R_{\\mathrm{L}}}\\\\ \u0026=\\dot{A}_{u s m o} \\cdot \\frac{R_{\\mathrm{L}}}{R_{\\mathrm{c}}+\\frac{1}{\\mathrm{j} \\omega C}+R_{\\mathrm{L}}} \\cdot \\frac{R_{\\mathrm{c}}+R_{\\mathrm{L}}}{R_{\\mathrm{c}}+R_{\\mathrm{L}}}=\\frac{\\dot{A}_{u \\mathrm{sm}}}{1+\\frac{1}{\\mathrm{j} \\omega\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}}\\\\ \u0026=\\dot{A}_{u s m} \\cdot \\frac{1}{1+f_{\\mathrm{L}} /(\\mathrm{j} f)}=\\dot{A}_{\\mathrm{usm}} \\cdot \\frac{j f / f_{\\mathrm{L}}}{1+j f / f_{\\mathrm{L}}} \\end{aligned}\\Rightarrow \\left\\{\\begin{array}{l} 20 \\lg \\left|\\dot{A}_{u s \\mid}\\right|=20 \\lg \\left|\\dot{A}_{u s m}\\right|-20 \\lg \\sqrt{1+\\left(\\frac{f_{\\mathrm{L}}}{f}\\right)^{2}} \\\\ \\varphi=-180^{\\circ}+\\left(90^{\\circ}-\\arctan \\frac{f}{f_{\\mathrm{L}}}\\right) \\\\ \\end{array}\\right.\\] 其中： \\(\\frac{R_C+R_L}{R_C+R_L}\\) 与\\(R_L\\)相乘凑出\\(R_C\\|R_L\\)，也就是\\(\\dot A_{usm}\\)的一部分。 \\(A_{\\text { usmo }}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{r_{\\mathrm{be}}} \\cdot\\left(-g_{\\mathrm{m}} R_{\\mathrm{c}}\\right)\\) \\(f_{\\mathrm{L}}=\\frac{1}{2 \\pi\\left(R_{\\mathrm{c}}+R_{\\mathrm{L}}\\right) C}\\) \\((R_C+R_L)C\\)其实就是输出回路的时间常数，因此求低频段下的电压放大倍数就可以改为求中频段下的电压放大倍数和\\(f_L\\)，而\\(f_L\\)可以通过时间常数求出，求时间常数就要知道电容所在回路的电阻，因此就可以简化低频段电压放大倍数的求解。 \\(\\varphi\\)：可以得出，在\\(f\u003ef_L\\)的情况下，单管放大电路的相移最多为\\(45^\\circ\\)。 \\(\\omega=2\\pi f\\) \\(f\\gg f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left|\\dot{A}_{u s m}\\right|\\)。 \\(f=f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right|\\)下降\\(3\\text{dB}\\)且\\(\\varphi=-135^\\circ\\)。 \\(f\\ll f_L\\)：\\(20 \\lg \\left|\\dot{A}_{u s}\\right| \\approx 20 \\lg \\left(\\dot{A}_{u s m} \\frac{f}{f_{\\mathrm{L}}}\\right)\\)。 \\(f\\to 0\\)：\\(\\left|\\dot A_{us}\\right|\\to 0\\)且\\(\\varphi\\to -90^\\circ\\)。 高频段 把\\(b,e\\)以左的电路进行戴维南等效变换后看作输入，\\(R_L\\)看作输出，中间看成一个二端口网络： \\(\\dot U_s^\\prime\\) 也就是变换前\\(b,e\\)的开路电压： \\[\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{b}^{\\prime}}}{\\dot{U}_{\\mathrm{i}}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\frac{r_{\\mathrm{b}^{\\prime}}}{r_{\\mathrm{be}}}\\] \\(R=r_{\\mathrm{b}^{\\prime} \\mathrm{e}} / /\\left(r_{\\mathrm{bb}}+R_{\\mathrm{b}} / / R_{\\mathrm{s}}\\right)\\) 由于二端口网络的输入端内部是一个电容，因此该电路是一个低通电路\\(\\dot I_S\\)超前导致\\(\\dot U_R\\)超前，而 \\(\\dot U_R,\\dot U_{C_\\pi}^\\prime,\\dot U_S^\\prime\\)满足平行四边形法则，\\(\\dot U_{C_\\pi}^\\prime\\)滞后： 得到在高频段的标准表达式： \\[\\begin{aligned} \\dot{A}_{u s h} \u0026=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{s}}^{\\prime}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{C}_{\\pi}^{\\prime}}}{\\dot{U}_{\\mathrm{s}}^","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:9","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#多级放大电路的频率响应"},{"categories":null,"content":"复合管 多只管子合理连接等效成一只管子（场效应管和三极管也可以形成复合管）。区别于多级放大电路，是把多个管子等效成一个性能提升的一个管子，但一个管子是无法构成放大电路的，周围加上阻容元件才构成放大电路。复合管的单位是晶体管，而多级放大电路的单位是放大电路。 作用 增大放大倍数，减小前级驱动电流 \\[i_E=(1+\\beta_1)i_{B1}(1+\\beta_2)i_{B2}\\] 得到： \\[\\beta\\approx\\beta_1\\beta_2\\] 改变管子类型 最终复合管的类型与第一级晶体管的类型相同。某些场合下，需要功率管的特性一致，但类型不同， 注意 场效应管可以直接作为三极管的前级，但三极管不能直接作为场效应管的前级： 场效应管的栅极输入电阻很大，三极管的射极几乎不可能产生电流。 动态参数 使用了共射放大电路输入输出电阻计算技巧可以得到： \\[\\begin{aligned} R_{\\mathrm{i}}\u0026=R_{\\mathrm{b}} / /\\left\\{r_{\\mathrm{bel}}+\\left(1+\\beta_{1}\\right)\\left[r_{\\mathrm{be} 2}+\\left(1+\\beta_{2}\\right)\\left(R_{\\mathrm{e}} / / R_{\\mathrm{L}}\\right)\\right]\\right\\}\\\\ R_{\\mathrm{o}}\u0026=R_{\\mathrm{e}} / / \\frac{r_{\\mathrm{be} 2}+\\frac{r_{\\mathrm{be1}}+R_{\\mathrm{b}} / / R_{\\mathrm{s}}}{1+\\beta_{1}}}{1+\\beta_{2}} \\end{aligned}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:10","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#复合管"},{"categories":null,"content":"多级放大电路 放大倍数 多级放大电路的电压放大倍数等于组成它的各级放大电路电压放大倍数之积（注意增益和放大倍数的关系，增益（\\(\\text{dB}\\)）应当是之和），且每一级的电压放大倍数均应以后级输入电阻为负载。 \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{i}}}=\\frac{\\dot{U}_{01}}{\\dot{U}_{\\mathrm{i}}} \\cdot \\frac{\\dot{U}_{02}}{\\dot{U}_{\\mathrm{i} 2}} \\cdots \\cdots \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{in}}}=\\prod_{j=1}^{n} \\dot{A}_{u j}\\] 输入电阻 等于第一级的输入电阻。注意第一级电路的输入电阻与后级电路有关，比如基本共集放大电路。 输出电阻 等于最后一级的输出电阻。注意最后一级的输出电阻可能与后级电路有关，比如基本共集放大电路。 动态参数分析举例 把\\(V_{CC}\\)看成地，画出交流通路。技巧是从信号源正极输入出发，看有多少条到地的路线，这些路线上的电阻并联。 每一级都考虑后级作为负载，所以要先求后级输入电阻，作为前级的负载电阻。 \\[\\begin{aligned} R_{\\mathrm{i} 2}\u0026=R_{5} / /\\left[r_{\\mathrm{be} 2}+\\left(1+\\beta_{2}\\right)\\left(R_{6} / / R_{\\mathrm{L}}\\right)\\right] R_{\\mathrm{i}} \u0026=R_{1} / / R_{2} / / r_{\\mathrm{be} 1} \\\\ R_{\\mathrm{o}} \u0026=R_{6} / / \\frac{r_{\\mathrm{be} 2}+R_{3} / / R_{5}}{1+\\beta} \\\\ \\dot{A}_{u 1} \u0026=-\\frac{\\beta\\left(R_{3} / / R_{\\mathrm{i} 2}\\right)}{r_{\\text {be1 }}} \\\\ \\dot{A}_{u 2} \u0026=\\frac{\\left(1+\\beta_{2}\\right)\\left(R_{6} / / R_{\\mathrm{L}}\\right)}{r_{\\mathrm{be} 2}+\\left(1+\\beta_{2}\\right)\\left(R_{6} / / R_{\\mathrm{L}}\\right)} \\\\ \\dot{A}_{u} \u0026=\\dot{A}_{u 1} \\cdot \\dot{A}_{u 2} \\end{aligned}\\] 失真分析 一处失真的原因有很多，如2个N型共射放大电路组成的多级电路产生了底部失真，既可能是后级放大电路产生了饱和失真，又可能是初级放大电路产生的截止失真。所以要先判断在哪一级发生了失真，再判断是什么失真。 判断失真所在电路的方法 要从后级往前级进行计算。假如知道了后一级的最大不失真输出电压并且知道了它的放大倍数，就可以算出它的最大不失真输入电压。通过比较前一级的最大不失真输出电压和后一级的最大不失真输入电压，可以分析出要失真首先会在哪一级失真。 选择 要先粗略的了解各种放大电路的输入电阻、输出输出电阻和电压放大倍数。 输入电阻（决定前级放大电路） 千欧级：共射放大电路 百千欧级：共集放大电路 兆欧级：共源放大电路 输出电阻（决定后级放大电路） 几十：共集放大电路 放大倍数（一般是通过其他条件确定一级后，通过放大倍数确定另一级） 几十：共源放大电路 几百：共射放大电路 几千：多个共射放大电路 多级放大电路的耦合方式 多级放大电路的直接耦合 由于\\(T_2\\)的发射结正偏，\\(u_{BE2}\\approx 0.7\\)，导致\\(u_{CE1}\\approx 0.7\\)，难以使得\\(u_{CE1}\\geq u_{BE1}\\)使其工作在饱和区。可以在\\(T_2\\)的发射极串联一个电阻，拉高其基极的电位。 但是会影响： \\(T_2\\)的输入电阻 \\(T_2\\)的电压放大倍数 可以用二极管来取代\\(R_e\\)，好处是： 静态的时候具有导通压降，提高\\(T_1\\)的管压降 导通压降不变，动态时相当于很小的电阻但如果要求\\(U_{CEQ1}\\)比较高的时候，此时又不能串联太多的二极管，这时可以使用稳压二极管。 其中，电阻\\(R\\)的作用使通过稳压二极管的电流达到其最小稳压电流，因为三极管的静态电流一般为\\(1\\sim 2\\text{mA}\\)不足以达到小功率稳压管的\\(5\\text{mA}\\)。 当使用多个同型的三极管时，由于前级的集电极电位就是后级的基极电位，所以后级的管压降会逐级增大，也就是\\(U_{BQ1}\u003cU_{CQ1}=U_{BQ2}\u003cU_{CQ2}\\)，导致后级三极管的静态工作点不合适，此时可以混用不同型的三极管来解决： 此时\\(U_{BQ1}\u003cU_{CQ1}=U_{BQ2}\u003eU_{CQ2}\\)，就解决了管压降逐级升高的问题。 优点 可以放大变化缓慢的信号 可以集成化 多级放大电路的阻容耦合 利用电容连接信号源与放大电路、放大电路的前后级、放大电路与负载。 优点 静态工作点相互独立 缺点 不能放大变化缓慢的信号，低频特性差 不能集成化 多级放大电路的变压器耦合 交流通路可等效为： 优点 实现了阻抗变换 比如扬声器的阻抗往往很小，直接接入放大电路会导致晶体管进入饱和区而失去放大作用。 使用变压器可以保证功率不变： \\[P_1=P_2=I_c^2R_L^\\prime=I_L^2R_L\\] 但对负载的阻抗进行变换： \\[R_{\\mathrm{L}}^{\\prime}=\\frac{I_{I}^{2}}{I_{\\mathrm{c}}^{2}} \\cdot R_{\\mathrm{L}}=\\left(\\frac{N_{1}}{N_{2}}\\right)^{2} \\cdot R_{\\mathrm{L}}\\] 多级放大电路的光电耦合 优点 输入回路和输出回路分别接不同的独立电源、独立的“地”，可避免长距离传输时的电干扰。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:11","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#多级放大电路"},{"categories":null,"content":"多级放大电路 放大倍数 多级放大电路的电压放大倍数等于组成它的各级放大电路电压放大倍数之积（注意增益和放大倍数的关系，增益（\\(\\text{dB}\\)）应当是之和），且每一级的电压放大倍数均应以后级输入电阻为负载。 \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{\\mathrm{i}}}=\\frac{\\dot{U}_{01}}{\\dot{U}_{\\mathrm{i}}} \\cdot \\frac{\\dot{U}_{02}}{\\dot{U}_{\\mathrm{i} 2}} \\cdots \\cdots \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{in}}}=\\prod_{j=1}^{n} \\dot{A}_{u j}\\] 输入电阻 等于第一级的输入电阻。注意第一级电路的输入电阻与后级电路有关，比如基本共集放大电路。 输出电阻 等于最后一级的输出电阻。注意最后一级的输出电阻可能与后级电路有关，比如基本共集放大电路。 动态参数分析举例 把\\(V_{CC}\\)看成地，画出交流通路。技巧是从信号源正极输入出发，看有多少条到地的路线，这些路线上的电阻并联。 每一级都考虑后级作为负载，所以要先求后级输入电阻，作为前级的负载电阻。 \\[\\begin{aligned} R_{\\mathrm{i} 2}\u0026=R_{5} / /\\left[r_{\\mathrm{be} 2}+\\left(1+\\beta_{2}\\right)\\left(R_{6} / / R_{\\mathrm{L}}\\right)\\right] R_{\\mathrm{i}} \u0026=R_{1} / / R_{2} / / r_{\\mathrm{be} 1} \\\\ R_{\\mathrm{o}} \u0026=R_{6} / / \\frac{r_{\\mathrm{be} 2}+R_{3} / / R_{5}}{1+\\beta} \\\\ \\dot{A}_{u 1} \u0026=-\\frac{\\beta\\left(R_{3} / / R_{\\mathrm{i} 2}\\right)}{r_{\\text {be1 }}} \\\\ \\dot{A}_{u 2} \u0026=\\frac{\\left(1+\\beta_{2}\\right)\\left(R_{6} / / R_{\\mathrm{L}}\\right)}{r_{\\mathrm{be} 2}+\\left(1+\\beta_{2}\\right)\\left(R_{6} / / R_{\\mathrm{L}}\\right)} \\\\ \\dot{A}_{u} \u0026=\\dot{A}_{u 1} \\cdot \\dot{A}_{u 2} \\end{aligned}\\] 失真分析 一处失真的原因有很多，如2个N型共射放大电路组成的多级电路产生了底部失真，既可能是后级放大电路产生了饱和失真，又可能是初级放大电路产生的截止失真。所以要先判断在哪一级发生了失真，再判断是什么失真。 判断失真所在电路的方法 要从后级往前级进行计算。假如知道了后一级的最大不失真输出电压并且知道了它的放大倍数，就可以算出它的最大不失真输入电压。通过比较前一级的最大不失真输出电压和后一级的最大不失真输入电压，可以分析出要失真首先会在哪一级失真。 选择 要先粗略的了解各种放大电路的输入电阻、输出输出电阻和电压放大倍数。 输入电阻（决定前级放大电路） 千欧级：共射放大电路 百千欧级：共集放大电路 兆欧级：共源放大电路 输出电阻（决定后级放大电路） 几十：共集放大电路 放大倍数（一般是通过其他条件确定一级后，通过放大倍数确定另一级） 几十：共源放大电路 几百：共射放大电路 几千：多个共射放大电路 多级放大电路的耦合方式 多级放大电路的直接耦合 由于\\(T_2\\)的发射结正偏，\\(u_{BE2}\\approx 0.7\\)，导致\\(u_{CE1}\\approx 0.7\\)，难以使得\\(u_{CE1}\\geq u_{BE1}\\)使其工作在饱和区。可以在\\(T_2\\)的发射极串联一个电阻，拉高其基极的电位。 但是会影响： \\(T_2\\)的输入电阻 \\(T_2\\)的电压放大倍数 可以用二极管来取代\\(R_e\\)，好处是： 静态的时候具有导通压降，提高\\(T_1\\)的管压降 导通压降不变，动态时相当于很小的电阻但如果要求\\(U_{CEQ1}\\)比较高的时候，此时又不能串联太多的二极管，这时可以使用稳压二极管。 其中，电阻\\(R\\)的作用使通过稳压二极管的电流达到其最小稳压电流，因为三极管的静态电流一般为\\(1\\sim 2\\text{mA}\\)不足以达到小功率稳压管的\\(5\\text{mA}\\)。 当使用多个同型的三极管时，由于前级的集电极电位就是后级的基极电位，所以后级的管压降会逐级增大，也就是\\(U_{BQ1}","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:11","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#多级放大电路的耦合方式"},{"categories":null,"content":"稳定静态工作点的方法 引入直流负反馈 温度补偿：利用对温度敏感的元件，在温度变化时直接影响输入回路。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:12","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#稳定静态工作点的方法"},{"categories":null,"content":"三种接法的比较 空载的情况下 参数\\接法 共射 共射 共基 \\(A_u\\) 大 \\(\\leq 1\\) 大 \\(A_i\\) \\(\\beta\\) \\(1+\\beta\\) \\(\\alpha\\approx 1\\) \\(R_i\\) 中（千欧级） 大 小 \\(R_o\\) 大 小 大 频带 窄 中 宽 接法判断（交流通路） 接法 CE（共射） CC（共集） CB（共基） 输入 基极 基极 发射极 输出 集电极 发射极 集电极 规律：共哪个极，就不把哪个极作为输入或输出。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:13","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#三种接法的比较"},{"categories":null,"content":"静态对动态的影响 \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=-\\frac{\\beta R_{\\mathrm{L}}^{\\prime}}{r_{\\mathrm{be}}}=-\\frac{\\beta\\left(R_{\\mathrm{c}} \\| R_{\\mathrm{L}}\\right)}{r_{\\mathrm{bb}^{\\prime}}+(1+\\beta) \\frac{U_{\\mathrm{T}}}{I_{\\mathrm{EQ}}}}\\] 以阻容耦合放大电路为例，提高放大倍数的几种方法： 增大\\(\\beta\\)：不一定行，因为它还出现在分母上。 增大\\(R_c\\)：要适可而止。因为它的增大意味着\\(U_{CE}\\)的减小，容易出现饱和。 增大\\(R_L\\)：由用户决定，不可行。 减小\\(R_b\\)来增大\\(I_{EQ}\\)：最常用的方法，但是要适可而止，否则会饱和。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:14","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#静态对动态的影响"},{"categories":null,"content":"直接耦合放大电路 解决了基本共射放大电路的两个问题。 \\(R_\\mathrm{b2}\u003eR_\\mathrm{c}\\)：确保基极电位低于集电极 \\(R_\\mathrm{b1}\\)：确保基极电位不只是信号源的电压，而是经过\\(V_\\mathrm{cc}-U_\\mathrm{b2}\\)与信号源的叠加（叠加定理）。 耦合的意思是信号源直接连接放大电路，放大电路直接连接负载。此时\\(U_{BEQ}\\)就为当\\(u_1\\)短接时，\\(R_{b1}\\)得到的分压。 问题： 信号源有损耗 负载上有直流分量 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:15","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#直接耦合放大电路"},{"categories":null,"content":"阻容耦合放大电路 \\(C_1,C_2\\)：耦合电容。容量应足够大，即对于交流信号近似为短路。其作用是“隔离直流通过交流”。 问题：负载上有直流损耗。 动态分析 \\[\\dot{A}_{u}=\\frac{\\dot{U}_{0}}{\\dot{U}_{i}}=\\frac{-\\dot{I}_{\\mathrm{c}}\\left(R_{c} \\| R_{\\mathrm{L}}\\right)}{\\dot{I}_{\\mathrm{b}} r_{\\mathrm{be}}}=-\\frac{\\beta R_{\\mathrm{L}}^{\\prime}}{r_{\\mathrm{be}}}\\] \\[R_i=R_b\\| r_{be}\\approx r_{be}\\] \\[R_o=R_C\\] 若输入源有内阻： \\[\\dot{A}_{u \\mathrm{~s}}=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{i}}}{\\dot{U}_{\\mathrm{s}}} \\cdot \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{i}}}=\\frac{R_{\\mathrm{i}}}{R_{\\mathrm{s}}+R_{\\mathrm{i}}} \\cdot \\dot{A}_{u}\\] 可见放大电路的输入内阻越大，对于有内阻的输入源而言放大效果越好。 注意： 输入电阻中不应含有\\(R_s\\)（输入源的电阻） 输出电阻中不应含有\\(R_L\\)（负载电阻） ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:16","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#阻容耦合放大电路"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#集成运算放大电路"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#理想运放"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#集成运放的保护电路"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#差分放大电路"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#电流源电路"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#有源负载放大电路"},{"categories":null,"content":"集成运算放大电路 集成运算放大电路，简称集成运放，是一个高性能的直接耦合多级放大电路。因首先用于信号的运算，故而得名。 电路结构特点 直接耦合 因硅片上不能制作大电容，故而采用直接耦合方式。 相邻元件对称 因相邻元件具有良好的对称性，且受温度和干扰后的变化也相同，可制作性能良好的各种差分放大电路（作输入级）和电流源电路（作偏置电路或有源负载）。 复杂电路 因为电路的复杂化并不带来工艺的复杂性，故可制作复杂电路来实现高性能的放大电路。 有源元件 用有源元件替代无源元件，如用晶体管取代难于制作的大电阻。 符号 分类 集成度 单运放 双运放 四运放 工艺 双极型集成运放电路：晶体管电路 单极型集成运放电路：场效应管电路 双极型和单极型混合结构集成运放电路 性能指标 高阻型 高速型 高精度型 低功耗型 高压/大功率型 专用型 仪表用放大器、隔离放大器、缓冲放大器、对数/反对数放大器。 组成 \\(u_P\\)：同相输入端 \\(u_N\\)：反相输入端 \\(u_O\\)：输出端 偏置电路 为各级放大电路设置合适的静态工作点。*采用电流源电路。* 输入级 前置级，多采用双端输入的差分放大电路。是这么多代集成运放差别最大的。 特点 输入电阻大 电压放大倍数数值大 抑制零点漂移能力强 静态电流小 中间级 主放大级，多采用共射放大电路。常用复合管作放大管、以恒流源做有源负载，其放大能力强。 输出级 功率级，多采用准互补输出级。 特点 输出电阻小 输出电流大 最大不失真输出电压尽可能大 电压传输特性 \\[u_O=f(u_P-u_N)\\] 工作区 线性区 其中过原点的线段所在区域。 \\[u_O=A_{od}(u_P-u_N)\\] \\(A_{od}\\)：开环差模放大倍数，通常为几十万倍，所以集成运放工作在线性区时的最大输入电压\\((u_P-u_N)\\)的数值仅为几十微伏。 非线性区 两条平行线所在的区域。 \\[u_O=\\pm U_{OM}\\] 性能指标 指标参数 典型值 理想值 开环差模增益\\(A_{od}\\) 106dB ∞ 差模输入电阻\\(r_{id}\\) 2MΩ ∞ 共模抑制比\\(K_{CMR}\\) 90dB ∞ 输入失调电压\\(U_{IO}\\) 1mV 0 \\(U_{IO}\\)的温漂 5μV/℃ 0 输入失调电流\\(I_{IO}\\) 20nA 0 \\(I_{IO}\\)的温漂 5nA/℃ 0 最大共模输入电压\\(U_{Ic\\max}\\) ±13V 最大差模输入电压\\(U_{id\\max}\\) ±30V -3dB带宽\\(f_H\\) 10Hz ∞ 转换速率\\(SR\\) 0.5V/μS ∞ 开环差模增益：分贝值\\(=20\\lg|A_{od}|\\) 输入失调电压 使\\(u_O\\)为0时，在输入端所加的补偿电压。运放工作在线性区的输入电压一般为微伏级，也就是说如果不加补偿电压的话，可能运放本身就已经工作在非线性区了。 输入失调电压的温漂：\\(\\frac{\\mathrm dU_{IO}}{\\mathrm dT}\\) 输入失调电流：\\(|I_{B1}-I_{B2}|\\) 输入失调电流的温漂：\\(\\frac{\\mathrm dI_{IO}}{\\mathrm dT}\\) 最大共模输入电压 当共模输入电压超过此值，差模信号将不能正常放大。 最大差模输入电压 当差模输入电压超过此值，输入级放大管击穿。 -3dB带宽 如此之低的原因是PN结的结电容或寄生电容。 低频等效电路 不考虑失调因素（理想化） 考虑失调因素 分析举例 双极型集成运放原理电路分析 按以下顺序进行分析： 偏置电路 偏置电流 电路中可以近似地估算出电流大小的一路电流一般为基准电流，也就是这里流出\\(T_{10}\\)的\\(I_R\\)： \\[I_R=\\frac{V_{CC}-U_{EB12}}{R_4}\\] 输出电流 找到\\(T_{10}\\)共基极的三极管，往左看找到\\(T_{11}\\)，往右看找到\\(T_{12}\\)，与\\(T_{10}\\)组成了多路电流源。于是可以把多路电流源简化成多个独立的电流源简化掉偏置电路。 分级 输入级 是一个双端输入单端输出差分放大电路，只不过这里的\\(R_c=0\\)。 中间级 使用了复合管作为放大管的共射放大电路。并且使用了一个电流源来作为有源负载以获得较大的电压放大倍数。 输出级 是一个准互补输出级，并且使用\\(U_{BE}\\)倍增电路来消除交越失真。 性能分析以\\(I_{I_e7}\\)为例，可以看到电压放大倍数是靠电流放大倍数的积累转换而来： \\[\\begin{aligned} I_{\\mathrm{e} 7} \u0026=\\left(1+\\beta_{7}\\right) I_{\\mathrm{b} 7} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) I_{\\mathrm{b} 6} \\\\ \u0026=\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right)\\left(\\beta_{4} I_{\\mathrm{b} 4}+\\beta_{3} I_{\\mathrm{b} 3}\\right) \\\\ \u0026 \\approx\\left(1+\\beta_{7}\\right)\\left(1+\\beta_{6}\\right) \\beta_{4}\\left(1+\\beta_{3}\\right) I_{\\mathrm{b} 3} \\end{aligned}\\] 需要明确的是所有的量均为动态的变化量，并且需要注意的是\\(I_{b6}\\)和\\(I_{b3},I_{b4}\\)的关系， \\(U_{BE}\\)倍增电路的动态电阻可以忽略，把它和输出级当作一个互补输出级基本电路即可。而中间级用的是一个恒流源，干路的电流不变，一条支路电流的变化就等于另一条支路电流变化的相反数。 极型（CMOS）集成运放原理电路分析 偏置电路 整个电路就一个电阻，很好辨认基准电流。 分级 输入级 是一个场效应管差分放大电路，并且还是一个有源负载放大电路，使得单端输出达到双端输出的差模放大倍数。 中间级/输出级 是一个基本共源放大电路，还是一个有源负载放大电路。 理想运放 参数特点 \\(A_\\mathrm{od}=\\infty\\) \\(r_\\mathrm{id}=\\infty\\) \\(r_\\mathrm{o}=0\\) \\(f_\\mathrm{H}=\\infty\\) 失调因素、温漂、噪声均为0。 电压传输特性 工作区 线性区 理想运放工作在线性区的电路特征是引入负反馈。 特点 虚短 \\[u_\\mathrm{o}\\nrightarrow\\infty,A_\\mathrm{od}=\\infty\\Rightarrow u_\\mathrm{N}-u_\\mathrm{P}=u_\\mathrm{i}=\\frac{u_\\mathrm{o}}{A_\\mathrm{od}}=0\\] 虚断 \\[r_\\mathrm{id}=\\infty\\Rightarrow i_\\mathrm{N}=i_\\mathrm{P}=0\\] 例 电压串联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=u_{\\mathrm{I}}\\\\ i_{R_{1}}\u0026=i_{R_{2}}=u_{I} / R_{1}\\\\ u_{o}\u0026=\\frac{u_{I}}{R_{1}}\\left(R_{1}+R_{2}\\right)\\\\ A_{u}\u0026=\\frac{\\Delta u_{0}}{\\Delta u_{1}}=1+\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电压并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{1}}\\\\ u_{o}\u0026=-i_{\\mathrm{I}} R_{2}\\\\ A_{u}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=-\\frac{R_{2}}{R_{1}} \\end{aligned}\\] 电流串联负反馈电路 \\[\\begin{aligned} u_{N}\u0026=u_{p}=u_{I}\\\\ i_{R_{2}}\u0026=i_{R_{1}}=\\frac{u_{I}}{R_{1}}\\\\ i_{R 3}\u0026=\\frac{u_{R_{1}}+u_{R_{2}}}{R_{3}}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) u_{1} / R_{3}\\\\ i_{o}\u0026=i_{R_{2}}+i_{R_{3}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot u_{I}\\\\ A_{u \\mathrm{f}}\u0026=\\frac{\\Delta u_{\\mathrm{o}}}{\\Delta u_{\\mathrm{I}}}=\\frac{\\Delta \\dot{i}_{\\mathrm{O}} R_{\\mathrm{L}}}{\\Delta u_{\\mathrm{I}}}=\\frac{R_{1}+R_{2}+R_{3}}{R_{1} R_{3}} \\cdot R_{\\mathrm{L}} \\end{aligned}\\] 电流并联负反馈电路 \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{R_{1}}\u0026=i_{R","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:17","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#互补输出级"},{"categories":null,"content":"频率响应 耦合电容产生高通电路，极间电容产生低通电路。 截止频率 使输出电压幅值下降到70.7%，相位为±45º的信号频率为截止频率。 放大电路 低频段：随着信号频率逐渐降低，耦合电容、旁路电容等的容抗增大，使动态信号损失，放大能力下降。 高频段：随着信号频率逐渐升高，晶体管极间电容和分布电容、寄生电容等杂散电容的容抗减小，使动态信号损失，放大能力下降。 分析示例 放大电路的级数 由10倍频时增益下降幅度为60dB来看，是三级放大电路。 耦合方式 由于在低频段增益也没有衰减，说明电路中一定不存在耦合电容或者旁路电容。 \\(f=10^4\\text{Hz}\\)下的增益衰减和附加相移 折线化的波特图增益在10倍频内衰减完成，说明三级放大电路的上限截止频率都在\\(10^4\\text{Hz}\\)处。每一级在上限截止频率的附加相移都是\\(45^\\circ\\)，所以三级就是\\(-135^\\circ\\)。 附加相移 不考虑中频段的相移是同相还是反相。 \\(f=10^5\\text{Hz}\\)下的附加相移 需要考虑折线化带来的误差，虽然三级总的相移应该是\\(-270^\\circ\\)，但是每一级都有\\(5.71^\\circ\\)的误差，所以就是\\(-(270-3\\times 5.71)^\\circ\\)的附加相移。 判断一个式子是高通还是低通，只要令\\(\\omega\\to\\infty\\)或\\(f\\to\\infty\\)，看式子的大小。 高通电路 信号频率越高，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{R}{R+X_C}=\\frac{1}{1+\\frac{X_C}{R}}=\\frac{1}{1+\\frac{1}{j\\omega RC}}\\] 当\\(\\frac{1}{j\\omega RC}=\\frac{1}{j}\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_L=\\frac{1}{RC}\\Rightarrow f_L=\\frac{\\omega_L}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{f_L}{jf}+1}\\)。 \\(\\dot U_o\\)超前\\(\\dot U_i\\)。当\\(f\\to 0\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)超前\\(\\dot U_i\\)90°。 低通电路 信号频率越低，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{X_C}{X_C+R}=\\frac{1}{1+\\frac{R}{X_C}}=\\frac{1}{1+j\\omega RC}\\] 当\\(j\\omega RC=-j\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_H=\\frac{1}{RC}\\Rightarrow f_H=\\frac{\\omega_H}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{jf}{f_H}+1}\\)。 \\(\\dot U_o\\)滞后\\(\\dot U_i\\)。当\\(f\\to\\infty\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)滞后\\(\\dot U_i\\)90°。 放大倍数的频率响应 \\[\\dot\\beta=\\left.\\frac{\\dot I_c}{\\dot I_b}\\right|_{U_{CE}}\\] 由于\\(U_{CE}\\)一定，在交流通路中动态电压为0，因此可以看成短路： 由电流放大倍数的定义式，计算\\(\\dot\\beta\\)，并写出其模表达式和相角表达式： \\[\\dot{\\beta}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}(Y_\\pi+Y_\\mu+Y_{\\mathrm{b}^{\\prime} \\mathrm{e}})}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left[\\frac{1}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}+\\mathrm{j} \\omega\\left(C_{\\pi}+C_{\\mu}\\right)\\right]}=\\frac{\\beta_{0}}{1+j \\frac{f}{f_{\\beta}}}\\Rightarrow\\left\\{\\begin{aligned}|\\dot{\\beta}|\u0026=\\frac{\\beta_{0}}{\\sqrt{1+\\left(\\frac{f}{f_{\\beta}}\\right)^{2}}} \\\\ \\varphi\u0026=-\\operatorname{tg}^{-1} \\frac{f}{f_{\\beta}} \\end{aligned}\\right.\\] 其中： \\(\\beta_0=g_m r_\\mathrm{b^\\prime e}\\)：在通频带中的电流放大倍数 \\(Y\\)：导纳 由于电流源的电阻可以看作是无穷大，导纳为\\(0\\)，但是输出是短接的，因此\\(C_\\mu\\)、\\(C_\\pi\\)与\\(r_\\mathrm{b^\\prime e}\\)并联，导纳相加。 \\(C_{ob}\\)（\\(C_\\mu\\)）：集电结电容 可以从手册中查得。 \\(f_\\beta\\)：共射截止频率 从\\(b^\\prime\\)往右看，电容与电阻并联（电阻会削弱电容的作用，但不会影响电路的类型），因此右边是个低通电路，具有上限截止频率： \\[f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\] 从\\((C_{\\pi}+C_{\\mu})\\)往左边看，电流源\\(\\dot I_b\\)的内阻相当于无穷大，等效电阻就是\\(r_{b^\\prime e}\\)， \\(r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)\\)也就是左边回路的时间常数\\(\\tau\\)。 并这个值可以从手册中查得，进而算出\\(C_\\pi\\)。 补充：\\(j\\omega C\\)和\\(f\\)的关系，若令\\(\\omega=\\frac{1}{RC}\\)，就是让\\(R=\\frac{1}{j\\omega C}\\)，而\\(\\frac{1}{f}=\\frac{2\\pi}{\\omega}=2\\pi RC\\Rightarrow f=\\frac{1}{2\\pi RC}\\) \\(f=\\frac{\\omega}{2\\pi}\\) \\(f\\ll f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\beta_0\\) \\(f=f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|=\\frac{\\beta_0}{\\sqrt{2}},\\varphi=45^{\\circ}\\) \\(f\\gg f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\frac{f_B}{F}\\cdot\\beta_0\\) \\(f\\to\\infty\\Rightarrow\\left|\\dot\\beta\\right|\\to 0,\\varphi\\to 90^{\\circ}\\) 晶体管的其他频率参数如下： \\(f_\\beta\\)：共射截止频率 \\(f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\) \\(f_\\alpha\\)：共基截止频率 \\[f_\\alpha=(1+\\beta)f_\\beta\\] 在通频带内，\\(\\alpha=\\frac{\\Delta\\dot I_c}{\\Delta\\dot I_e}\\approx 1\\)。共基截止频率还是当输出衰减到70.7%所对应的频率。 \\(f_T\\)：特征频率 使\\(\\left|\\dot\\beta\\right|=1\\)的频率，也就是使电路失去放大能力所对应的频率。\\(f_T\\approx f_\\alpha\\approx \\beta_0f_\\beta\\)。 因此有两条曲线可以表示电流放大倍数的频率响应： 幅频特性曲线 相频特性曲线 我们可以将这两条曲线折线化，并采用对数坐标系（\\(1\\text{dB}=20\\lg\\sqrt2\\)），得到波特图： \\(0.1f_\\beta\\) 近似地认为当频率达到\\(0.1f_\\beta\\)时才开始出现相角，实际上在\\(0.1f_\\beta\\)前就已经出现了。 \\(f_\\beta\\) 当频率达到\\(f_\\beta\\)时，幅频特性衰减\\(20\\lg\\sqrt{2}\\approx 3\\text{dB}\\)，并且此时相角为\\(45^{\\circ}\\)。 \\(10f_\\beta\\) 当频率达到\\(10f_\\beta\\)，幅频特性衰减\\(20\\text{dB}\\)，近似地认为此时相角已达到\\(90^{\\circ}\\)，实际上这是当\\(f\\to\\infty\\)时的情况。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:18","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#频率响应"},{"categories":null,"content":"频率响应 耦合电容产生高通电路，极间电容产生低通电路。 截止频率 使输出电压幅值下降到70.7%，相位为±45º的信号频率为截止频率。 放大电路 低频段：随着信号频率逐渐降低，耦合电容、旁路电容等的容抗增大，使动态信号损失，放大能力下降。 高频段：随着信号频率逐渐升高，晶体管极间电容和分布电容、寄生电容等杂散电容的容抗减小，使动态信号损失，放大能力下降。 分析示例 放大电路的级数 由10倍频时增益下降幅度为60dB来看，是三级放大电路。 耦合方式 由于在低频段增益也没有衰减，说明电路中一定不存在耦合电容或者旁路电容。 \\(f=10^4\\text{Hz}\\)下的增益衰减和附加相移 折线化的波特图增益在10倍频内衰减完成，说明三级放大电路的上限截止频率都在\\(10^4\\text{Hz}\\)处。每一级在上限截止频率的附加相移都是\\(45^\\circ\\)，所以三级就是\\(-135^\\circ\\)。 附加相移 不考虑中频段的相移是同相还是反相。 \\(f=10^5\\text{Hz}\\)下的附加相移 需要考虑折线化带来的误差，虽然三级总的相移应该是\\(-270^\\circ\\)，但是每一级都有\\(5.71^\\circ\\)的误差，所以就是\\(-(270-3\\times 5.71)^\\circ\\)的附加相移。 判断一个式子是高通还是低通，只要令\\(\\omega\\to\\infty\\)或\\(f\\to\\infty\\)，看式子的大小。 高通电路 信号频率越高，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{R}{R+X_C}=\\frac{1}{1+\\frac{X_C}{R}}=\\frac{1}{1+\\frac{1}{j\\omega RC}}\\] 当\\(\\frac{1}{j\\omega RC}=\\frac{1}{j}\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_L=\\frac{1}{RC}\\Rightarrow f_L=\\frac{\\omega_L}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{f_L}{jf}+1}\\)。 \\(\\dot U_o\\)超前\\(\\dot U_i\\)。当\\(f\\to 0\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)超前\\(\\dot U_i\\)90°。 低通电路 信号频率越低，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{X_C}{X_C+R}=\\frac{1}{1+\\frac{R}{X_C}}=\\frac{1}{1+j\\omega RC}\\] 当\\(j\\omega RC=-j\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_H=\\frac{1}{RC}\\Rightarrow f_H=\\frac{\\omega_H}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{jf}{f_H}+1}\\)。 \\(\\dot U_o\\)滞后\\(\\dot U_i\\)。当\\(f\\to\\infty\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)滞后\\(\\dot U_i\\)90°。 放大倍数的频率响应 \\[\\dot\\beta=\\left.\\frac{\\dot I_c}{\\dot I_b}\\right|_{U_{CE}}\\] 由于\\(U_{CE}\\)一定，在交流通路中动态电压为0，因此可以看成短路： 由电流放大倍数的定义式，计算\\(\\dot\\beta\\)，并写出其模表达式和相角表达式： \\[\\dot{\\beta}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}(Y_\\pi+Y_\\mu+Y_{\\mathrm{b}^{\\prime} \\mathrm{e}})}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left[\\frac{1}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}+\\mathrm{j} \\omega\\left(C_{\\pi}+C_{\\mu}\\right)\\right]}=\\frac{\\beta_{0}}{1+j \\frac{f}{f_{\\beta}}}\\Rightarrow\\left\\{\\begin{aligned}|\\dot{\\beta}|\u0026=\\frac{\\beta_{0}}{\\sqrt{1+\\left(\\frac{f}{f_{\\beta}}\\right)^{2}}} \\\\ \\varphi\u0026=-\\operatorname{tg}^{-1} \\frac{f}{f_{\\beta}} \\end{aligned}\\right.\\] 其中： \\(\\beta_0=g_m r_\\mathrm{b^\\prime e}\\)：在通频带中的电流放大倍数 \\(Y\\)：导纳 由于电流源的电阻可以看作是无穷大，导纳为\\(0\\)，但是输出是短接的，因此\\(C_\\mu\\)、\\(C_\\pi\\)与\\(r_\\mathrm{b^\\prime e}\\)并联，导纳相加。 \\(C_{ob}\\)（\\(C_\\mu\\)）：集电结电容 可以从手册中查得。 \\(f_\\beta\\)：共射截止频率 从\\(b^\\prime\\)往右看，电容与电阻并联（电阻会削弱电容的作用，但不会影响电路的类型），因此右边是个低通电路，具有上限截止频率： \\[f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\] 从\\((C_{\\pi}+C_{\\mu})\\)往左边看，电流源\\(\\dot I_b\\)的内阻相当于无穷大，等效电阻就是\\(r_{b^\\prime e}\\)， \\(r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)\\)也就是左边回路的时间常数\\(\\tau\\)。 并这个值可以从手册中查得，进而算出\\(C_\\pi\\)。 补充：\\(j\\omega C\\)和\\(f\\)的关系，若令\\(\\omega=\\frac{1}{RC}\\)，就是让\\(R=\\frac{1}{j\\omega C}\\)，而\\(\\frac{1}{f}=\\frac{2\\pi}{\\omega}=2\\pi RC\\Rightarrow f=\\frac{1}{2\\pi RC}\\) \\(f=\\frac{\\omega}{2\\pi}\\) \\(f\\ll f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\beta_0\\) \\(f=f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|=\\frac{\\beta_0}{\\sqrt{2}},\\varphi=45^{\\circ}\\) \\(f\\gg f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\frac{f_B}{F}\\cdot\\beta_0\\) \\(f\\to\\infty\\Rightarrow\\left|\\dot\\beta\\right|\\to 0,\\varphi\\to 90^{\\circ}\\) 晶体管的其他频率参数如下： \\(f_\\beta\\)：共射截止频率 \\(f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\) \\(f_\\alpha\\)：共基截止频率 \\[f_\\alpha=(1+\\beta)f_\\beta\\] 在通频带内，\\(\\alpha=\\frac{\\Delta\\dot I_c}{\\Delta\\dot I_e}\\approx 1\\)。共基截止频率还是当输出衰减到70.7%所对应的频率。 \\(f_T\\)：特征频率 使\\(\\left|\\dot\\beta\\right|=1\\)的频率，也就是使电路失去放大能力所对应的频率。\\(f_T\\approx f_\\alpha\\approx \\beta_0f_\\beta\\)。 因此有两条曲线可以表示电流放大倍数的频率响应： 幅频特性曲线 相频特性曲线 我们可以将这两条曲线折线化，并采用对数坐标系（\\(1\\text{dB}=20\\lg\\sqrt2\\)），得到波特图： \\(0.1f_\\beta\\) 近似地认为当频率达到\\(0.1f_\\beta\\)时才开始出现相角，实际上在\\(0.1f_\\beta\\)前就已经出现了。 \\(f_\\beta\\) 当频率达到\\(f_\\beta\\)时，幅频特性衰减\\(20\\lg\\sqrt{2}\\approx 3\\text{dB}\\)，并且此时相角为\\(45^{\\circ}\\)。 \\(10f_\\beta\\) 当频率达到\\(10f_\\beta\\)，幅频特性衰减\\(20\\text{dB}\\)，近似地认为此时相角已达到\\(90^{\\circ}\\)，实际上这是当\\(f\\to\\infty\\)时的情况。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:18","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#高通电路"},{"categories":null,"content":"频率响应 耦合电容产生高通电路，极间电容产生低通电路。 截止频率 使输出电压幅值下降到70.7%，相位为±45º的信号频率为截止频率。 放大电路 低频段：随着信号频率逐渐降低，耦合电容、旁路电容等的容抗增大，使动态信号损失，放大能力下降。 高频段：随着信号频率逐渐升高，晶体管极间电容和分布电容、寄生电容等杂散电容的容抗减小，使动态信号损失，放大能力下降。 分析示例 放大电路的级数 由10倍频时增益下降幅度为60dB来看，是三级放大电路。 耦合方式 由于在低频段增益也没有衰减，说明电路中一定不存在耦合电容或者旁路电容。 \\(f=10^4\\text{Hz}\\)下的增益衰减和附加相移 折线化的波特图增益在10倍频内衰减完成，说明三级放大电路的上限截止频率都在\\(10^4\\text{Hz}\\)处。每一级在上限截止频率的附加相移都是\\(45^\\circ\\)，所以三级就是\\(-135^\\circ\\)。 附加相移 不考虑中频段的相移是同相还是反相。 \\(f=10^5\\text{Hz}\\)下的附加相移 需要考虑折线化带来的误差，虽然三级总的相移应该是\\(-270^\\circ\\)，但是每一级都有\\(5.71^\\circ\\)的误差，所以就是\\(-(270-3\\times 5.71)^\\circ\\)的附加相移。 判断一个式子是高通还是低通，只要令\\(\\omega\\to\\infty\\)或\\(f\\to\\infty\\)，看式子的大小。 高通电路 信号频率越高，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{R}{R+X_C}=\\frac{1}{1+\\frac{X_C}{R}}=\\frac{1}{1+\\frac{1}{j\\omega RC}}\\] 当\\(\\frac{1}{j\\omega RC}=\\frac{1}{j}\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_L=\\frac{1}{RC}\\Rightarrow f_L=\\frac{\\omega_L}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{f_L}{jf}+1}\\)。 \\(\\dot U_o\\)超前\\(\\dot U_i\\)。当\\(f\\to 0\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)超前\\(\\dot U_i\\)90°。 低通电路 信号频率越低，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{X_C}{X_C+R}=\\frac{1}{1+\\frac{R}{X_C}}=\\frac{1}{1+j\\omega RC}\\] 当\\(j\\omega RC=-j\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_H=\\frac{1}{RC}\\Rightarrow f_H=\\frac{\\omega_H}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{jf}{f_H}+1}\\)。 \\(\\dot U_o\\)滞后\\(\\dot U_i\\)。当\\(f\\to\\infty\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)滞后\\(\\dot U_i\\)90°。 放大倍数的频率响应 \\[\\dot\\beta=\\left.\\frac{\\dot I_c}{\\dot I_b}\\right|_{U_{CE}}\\] 由于\\(U_{CE}\\)一定，在交流通路中动态电压为0，因此可以看成短路： 由电流放大倍数的定义式，计算\\(\\dot\\beta\\)，并写出其模表达式和相角表达式： \\[\\dot{\\beta}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}(Y_\\pi+Y_\\mu+Y_{\\mathrm{b}^{\\prime} \\mathrm{e}})}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left[\\frac{1}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}+\\mathrm{j} \\omega\\left(C_{\\pi}+C_{\\mu}\\right)\\right]}=\\frac{\\beta_{0}}{1+j \\frac{f}{f_{\\beta}}}\\Rightarrow\\left\\{\\begin{aligned}|\\dot{\\beta}|\u0026=\\frac{\\beta_{0}}{\\sqrt{1+\\left(\\frac{f}{f_{\\beta}}\\right)^{2}}} \\\\ \\varphi\u0026=-\\operatorname{tg}^{-1} \\frac{f}{f_{\\beta}} \\end{aligned}\\right.\\] 其中： \\(\\beta_0=g_m r_\\mathrm{b^\\prime e}\\)：在通频带中的电流放大倍数 \\(Y\\)：导纳 由于电流源的电阻可以看作是无穷大，导纳为\\(0\\)，但是输出是短接的，因此\\(C_\\mu\\)、\\(C_\\pi\\)与\\(r_\\mathrm{b^\\prime e}\\)并联，导纳相加。 \\(C_{ob}\\)（\\(C_\\mu\\)）：集电结电容 可以从手册中查得。 \\(f_\\beta\\)：共射截止频率 从\\(b^\\prime\\)往右看，电容与电阻并联（电阻会削弱电容的作用，但不会影响电路的类型），因此右边是个低通电路，具有上限截止频率： \\[f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\] 从\\((C_{\\pi}+C_{\\mu})\\)往左边看，电流源\\(\\dot I_b\\)的内阻相当于无穷大，等效电阻就是\\(r_{b^\\prime e}\\)， \\(r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)\\)也就是左边回路的时间常数\\(\\tau\\)。 并这个值可以从手册中查得，进而算出\\(C_\\pi\\)。 补充：\\(j\\omega C\\)和\\(f\\)的关系，若令\\(\\omega=\\frac{1}{RC}\\)，就是让\\(R=\\frac{1}{j\\omega C}\\)，而\\(\\frac{1}{f}=\\frac{2\\pi}{\\omega}=2\\pi RC\\Rightarrow f=\\frac{1}{2\\pi RC}\\) \\(f=\\frac{\\omega}{2\\pi}\\) \\(f\\ll f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\beta_0\\) \\(f=f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|=\\frac{\\beta_0}{\\sqrt{2}},\\varphi=45^{\\circ}\\) \\(f\\gg f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\frac{f_B}{F}\\cdot\\beta_0\\) \\(f\\to\\infty\\Rightarrow\\left|\\dot\\beta\\right|\\to 0,\\varphi\\to 90^{\\circ}\\) 晶体管的其他频率参数如下： \\(f_\\beta\\)：共射截止频率 \\(f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\) \\(f_\\alpha\\)：共基截止频率 \\[f_\\alpha=(1+\\beta)f_\\beta\\] 在通频带内，\\(\\alpha=\\frac{\\Delta\\dot I_c}{\\Delta\\dot I_e}\\approx 1\\)。共基截止频率还是当输出衰减到70.7%所对应的频率。 \\(f_T\\)：特征频率 使\\(\\left|\\dot\\beta\\right|=1\\)的频率，也就是使电路失去放大能力所对应的频率。\\(f_T\\approx f_\\alpha\\approx \\beta_0f_\\beta\\)。 因此有两条曲线可以表示电流放大倍数的频率响应： 幅频特性曲线 相频特性曲线 我们可以将这两条曲线折线化，并采用对数坐标系（\\(1\\text{dB}=20\\lg\\sqrt2\\)），得到波特图： \\(0.1f_\\beta\\) 近似地认为当频率达到\\(0.1f_\\beta\\)时才开始出现相角，实际上在\\(0.1f_\\beta\\)前就已经出现了。 \\(f_\\beta\\) 当频率达到\\(f_\\beta\\)时，幅频特性衰减\\(20\\lg\\sqrt{2}\\approx 3\\text{dB}\\)，并且此时相角为\\(45^{\\circ}\\)。 \\(10f_\\beta\\) 当频率达到\\(10f_\\beta\\)，幅频特性衰减\\(20\\text{dB}\\)，近似地认为此时相角已达到\\(90^{\\circ}\\)，实际上这是当\\(f\\to\\infty\\)时的情况。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:18","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#低通电路"},{"categories":null,"content":"频率响应 耦合电容产生高通电路，极间电容产生低通电路。 截止频率 使输出电压幅值下降到70.7%，相位为±45º的信号频率为截止频率。 放大电路 低频段：随着信号频率逐渐降低，耦合电容、旁路电容等的容抗增大，使动态信号损失，放大能力下降。 高频段：随着信号频率逐渐升高，晶体管极间电容和分布电容、寄生电容等杂散电容的容抗减小，使动态信号损失，放大能力下降。 分析示例 放大电路的级数 由10倍频时增益下降幅度为60dB来看，是三级放大电路。 耦合方式 由于在低频段增益也没有衰减，说明电路中一定不存在耦合电容或者旁路电容。 \\(f=10^4\\text{Hz}\\)下的增益衰减和附加相移 折线化的波特图增益在10倍频内衰减完成，说明三级放大电路的上限截止频率都在\\(10^4\\text{Hz}\\)处。每一级在上限截止频率的附加相移都是\\(45^\\circ\\)，所以三级就是\\(-135^\\circ\\)。 附加相移 不考虑中频段的相移是同相还是反相。 \\(f=10^5\\text{Hz}\\)下的附加相移 需要考虑折线化带来的误差，虽然三级总的相移应该是\\(-270^\\circ\\)，但是每一级都有\\(5.71^\\circ\\)的误差，所以就是\\(-(270-3\\times 5.71)^\\circ\\)的附加相移。 判断一个式子是高通还是低通，只要令\\(\\omega\\to\\infty\\)或\\(f\\to\\infty\\)，看式子的大小。 高通电路 信号频率越高，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{R}{R+X_C}=\\frac{1}{1+\\frac{X_C}{R}}=\\frac{1}{1+\\frac{1}{j\\omega RC}}\\] 当\\(\\frac{1}{j\\omega RC}=\\frac{1}{j}\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_L=\\frac{1}{RC}\\Rightarrow f_L=\\frac{\\omega_L}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{f_L}{jf}+1}\\)。 \\(\\dot U_o\\)超前\\(\\dot U_i\\)。当\\(f\\to 0\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)超前\\(\\dot U_i\\)90°。 低通电路 信号频率越低，输出电压越接近输入电压。 \\[\\dot A_u=\\frac{X_C}{X_C+R}=\\frac{1}{1+\\frac{R}{X_C}}=\\frac{1}{1+j\\omega RC}\\] 当\\(j\\omega RC=-j\\)时，\\(\\left| \\dot A_u \\right|=\\sqrt{2}\\)，此时\\(\\omega_H=\\frac{1}{RC}\\Rightarrow f_H=\\frac{\\omega_H}{2\\pi}=\\frac{1}{2\\pi RC}\\) 因此\\(\\dot A_u=\\frac{1}{\\frac{jf}{f_H}+1}\\)。 \\(\\dot U_o\\)滞后\\(\\dot U_i\\)。当\\(f\\to\\infty\\)时，\\(\\left|\\dot U_o\\right|\\to0\\)，\\(\\dot U_o\\)滞后\\(\\dot U_i\\)90°。 放大倍数的频率响应 \\[\\dot\\beta=\\left.\\frac{\\dot I_c}{\\dot I_b}\\right|_{U_{CE}}\\] 由于\\(U_{CE}\\)一定，在交流通路中动态电压为0，因此可以看成短路： 由电流放大倍数的定义式，计算\\(\\dot\\beta\\)，并写出其模表达式和相角表达式： \\[\\dot{\\beta}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}(Y_\\pi+Y_\\mu+Y_{\\mathrm{b}^{\\prime} \\mathrm{e}})}=\\frac{g_{\\mathrm{m}} \\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}}{\\dot{U}_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left[\\frac{1}{r_{\\mathrm{b}^{\\prime} \\mathrm{e}}}+\\mathrm{j} \\omega\\left(C_{\\pi}+C_{\\mu}\\right)\\right]}=\\frac{\\beta_{0}}{1+j \\frac{f}{f_{\\beta}}}\\Rightarrow\\left\\{\\begin{aligned}|\\dot{\\beta}|\u0026=\\frac{\\beta_{0}}{\\sqrt{1+\\left(\\frac{f}{f_{\\beta}}\\right)^{2}}} \\\\ \\varphi\u0026=-\\operatorname{tg}^{-1} \\frac{f}{f_{\\beta}} \\end{aligned}\\right.\\] 其中： \\(\\beta_0=g_m r_\\mathrm{b^\\prime e}\\)：在通频带中的电流放大倍数 \\(Y\\)：导纳 由于电流源的电阻可以看作是无穷大，导纳为\\(0\\)，但是输出是短接的，因此\\(C_\\mu\\)、\\(C_\\pi\\)与\\(r_\\mathrm{b^\\prime e}\\)并联，导纳相加。 \\(C_{ob}\\)（\\(C_\\mu\\)）：集电结电容 可以从手册中查得。 \\(f_\\beta\\)：共射截止频率 从\\(b^\\prime\\)往右看，电容与电阻并联（电阻会削弱电容的作用，但不会影响电路的类型），因此右边是个低通电路，具有上限截止频率： \\[f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\] 从\\((C_{\\pi}+C_{\\mu})\\)往左边看，电流源\\(\\dot I_b\\)的内阻相当于无穷大，等效电阻就是\\(r_{b^\\prime e}\\)， \\(r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)\\)也就是左边回路的时间常数\\(\\tau\\)。 并这个值可以从手册中查得，进而算出\\(C_\\pi\\)。 补充：\\(j\\omega C\\)和\\(f\\)的关系，若令\\(\\omega=\\frac{1}{RC}\\)，就是让\\(R=\\frac{1}{j\\omega C}\\)，而\\(\\frac{1}{f}=\\frac{2\\pi}{\\omega}=2\\pi RC\\Rightarrow f=\\frac{1}{2\\pi RC}\\) \\(f=\\frac{\\omega}{2\\pi}\\) \\(f\\ll f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\beta_0\\) \\(f=f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|=\\frac{\\beta_0}{\\sqrt{2}},\\varphi=45^{\\circ}\\) \\(f\\gg f_\\beta\\Rightarrow\\left|\\dot\\beta\\right|\\approx\\frac{f_B}{F}\\cdot\\beta_0\\) \\(f\\to\\infty\\Rightarrow\\left|\\dot\\beta\\right|\\to 0,\\varphi\\to 90^{\\circ}\\) 晶体管的其他频率参数如下： \\(f_\\beta\\)：共射截止频率 \\(f_{\\beta}=\\frac{1}{2 \\pi r_{\\mathrm{b}^{\\prime} \\mathrm{e}}\\left(C_{\\pi}+C_{\\mu}\\right)}\\) \\(f_\\alpha\\)：共基截止频率 \\[f_\\alpha=(1+\\beta)f_\\beta\\] 在通频带内，\\(\\alpha=\\frac{\\Delta\\dot I_c}{\\Delta\\dot I_e}\\approx 1\\)。共基截止频率还是当输出衰减到70.7%所对应的频率。 \\(f_T\\)：特征频率 使\\(\\left|\\dot\\beta\\right|=1\\)的频率，也就是使电路失去放大能力所对应的频率。\\(f_T\\approx f_\\alpha\\approx \\beta_0f_\\beta\\)。 因此有两条曲线可以表示电流放大倍数的频率响应： 幅频特性曲线 相频特性曲线 我们可以将这两条曲线折线化，并采用对数坐标系（\\(1\\text{dB}=20\\lg\\sqrt2\\)），得到波特图： \\(0.1f_\\beta\\) 近似地认为当频率达到\\(0.1f_\\beta\\)时才开始出现相角，实际上在\\(0.1f_\\beta\\)前就已经出现了。 \\(f_\\beta\\) 当频率达到\\(f_\\beta\\)时，幅频特性衰减\\(20\\lg\\sqrt{2}\\approx 3\\text{dB}\\)，并且此时相角为\\(45^{\\circ}\\)。 \\(10f_\\beta\\) 当频率达到\\(10f_\\beta\\)，幅频特性衰减\\(20\\text{dB}\\)，近似地认为此时相角已达到\\(90^{\\circ}\\)，实际上这是当\\(f\\to\\infty\\)时的情况。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:18","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#放大倍数的频率响应"},{"categories":null,"content":"反馈 类型 正负 正反馈引入正反馈的电路通常也有负反馈，并且负反馈的作用强度比正反馈大得多。 例 自举电路 \\[I_\\mathrm{R_1}=\\frac{U_P-U_N}{R_1}\\] 把\\(R_1\\)等效成\\(R_1^\\prime\\)： 等效的前提是要保证流过\\(R_1^\\prime\\)的电流不变，也就是： \\[R_1^\\prime=\\frac{U_\\mathrm{i}}{I_{R_1}}=\\frac{U_P}{U_p-U_N}\\cdot R_1\\] 在认为运放是理想运放的前提下： \\[R_\\mathrm{i}=R_\\mathrm{i}^\\prime\\|R_\\mathrm{1}^\\prime=\\infty\\] 通过引入正反馈，增大输入电阻，因而提高输入电压。 豪兰德电流源 若负载电阻的阻值下降： 通过\\(R_2\\)的负反馈引起输出电流上升。 使得\\(u_P\\)下降，导致\\(u_P\\)下降，引起输出电流的下降。 在理想运放下： \\[\\begin{array}{l} i_{R 1}=i_{R 2}, \\quad i_{R 3}=i_{R}+i_{0}, \\quad u_{\\mathrm{N}}=u_{p}\\\\ \\frac{u_{\\mathrm{I}}-u_{\\mathrm{p}}}{R_{1}}=\\frac{u_{\\mathrm{p}}-u_{\\mathrm{o}}}{R_{2}}, \\frac{u_{\\mathrm{o}}-u_{\\mathrm{p}}}{R_{3}}=\\frac{u_{\\mathrm{p}}}{R}+i_{\\mathrm{o}} \\end{array}\\] 得出了一条重要的结论： \\[\\frac{R_2}{R_1}=\\frac{R_3}{R}\\Rightarrow i_\\mathrm{o}=-\\frac{u_\\mathrm{i}}{R}\\] 负反馈 直流和交流 直流反馈：直流通路中的反馈。 交流反馈：交流通路中的反馈。 全局和局部 级间（全局）反馈：在整个多级放大电路的输入级引入反馈。 局部反馈：在多级放大电路的某一级的输入引入反馈。 组态 电压反馈和电流反馈 根据负载的不同需求来决定，比如是恒压还是恒流。 电压反馈 将输出电压的一部分或全部引回到输入回路来影响净输入量的为电压反馈。 电流反馈 将输出电流的一部分或全部引回到输入回路来影响净输入量的为电流反馈。 串联反馈和并联反馈根据信号源的类型来决定，比如信号源更接近恒压源还是恒流源。 串联反馈 适用于更接近恒压源的信号源，这样反馈网络控制在自己身上的分压，即可控制基本放大电路的输入电压。 并联反馈 适用于更接近恒流源的信号源，这样反馈网络控制流过自身的电流，即可控制流入基本放大电路的电流。 判断 有无反馈 看输入回路和输出回路之间有无联系，输出端会不会对输入端产生影响。 例 该电路没有反馈，因为从输出端接回来的输入端是接地的，也就是说不管输出端怎么变化，同相输入端的电位始终为0。 该电路有反馈，由于输出回路并联的电阻在源极上，因此输出回路的变化会对输入回路产生影响。 直流/交流 分别判断在直流通路下和交流通路下有无反馈。 反馈正负 注意，反馈只和输出对输入的作用有关。可以使用瞬时极性法，假设给予输入一个正向的变化，看输出对输入有什么样的影响。对于晶体管和运放而言，输入的变化基本都是电压引起的，而在输出上，晶体管体现为电流，而运放体现为电压。 原则 端子 极性 反馈 相同 相同 正 相同 相反 负 相异 相反 正 相异 相同 负 例 反相输入端电位升高，导致输出电位降低，导致流过\\(R_2\\)的电流增大，流过\\(R_1\\)的电流也增大，\\(R_1\\)上的分压增大，导致反相输入端的电位降低。因此是负反馈。 电压/电流 令输出电压为0（接地），若反馈量随之为0，则为电压反馈；若反馈量依然存在，则为电流反馈。电压型负反馈相当于稳定了一个电压源，电流型负反馈相当于稳定了一个电流源， 例 先用瞬时极性法，得到\\(T_2\\)发射极的极性是负的，输入端的\\(u_S\\)串联\\(R_s\\)和\\(V_{EE}\\)串联\\(R_3\\)可以看作是电流源，通过\\(R_2\\)流入\\(V_{EE}\\)的电流减小，通过\\(R_5\\)流入\\(V_EE\\)的电流增大，\\(T_1\\)的基极电流减小，因此是负反馈。然后再假设输出直接接地，由于三极管是一个流控电流源，电流源是可以被短路的，射极电流取决于基极电流，因此是电流负反馈。 串联/并联 输入信号和反馈信号的叠加关系。可以看反馈如果出现在与输入相同的端子上（取决于\\(u_\\mathrm{I}\\)被规定在哪），就是并联反馈，如果是相异的端子，就是串联反馈。也可以看反馈和输入电压有无可确定的电位关系，如果有则是串联反馈。还可以看信号源的类型，像电压源串联电阻能够将其看作电流源。 例 并联反馈：\\(i_N=i_I-i_F\\) 串联反馈：\\(u_D=u_I-u_F\\) 方框图 \\(\\dot A=\\frac{\\dot X_\\mathrm{o}}{\\dot X_\\mathrm{i}^\\prime}\\)：基本放大电路的放大倍数 \\(\\dot F=\\frac{\\dot X_\\mathrm{f}}{\\dot X_\\mathrm{o}}\\)：反馈系数 \\(\\dot A_\\mathrm{f}=\\frac{\\dot X_\\mathrm{o}}{\\dot X_\\mathrm{i}}=\\frac{\\dot A}{1+\\dot A\\dot F}\\)：反馈放大电路的放大倍数 反馈深度\\(1+\\dot A\\dot F\\gg 1\\Rightarrow \\dot A_\\mathrm{f}\\approx\\frac{1}{\\dot F}\\Rightarrow \\dot X_\\mathrm{i}\\approx\\dot X_\\mathrm{f}\\)：深度负反馈 也就是说在深度负反馈电路中，\\(\\dot F\\)基本决定了整个电路的放大倍数，可以不用考虑\\(\\dot A\\)的参数了。这里被忽略的\\(1\\)实际上就是净输入量\\(u_\\mathrm{N}-u_\\mathrm{P}\\)，也就是深度负反馈造成的虚短，这是虚短的另一种理解。 \\(1+\\dot A\\dot F\\)是反馈深度，在对放大电路的影响中会大量出现。 \\(\\dot A\\dot F\\)：环路放大倍数 表示基本放大电路的输入和反馈输出的关系。 \\(\\dot A\\dot F\u003e0\\)（同号）：负反馈 也可以推出\\(\\dot A_\\mathrm{f},\\dot A,\\dot F\\)符号相同。 电压放大倍数（估算）要估算电压放大倍数就要求在电路中的\\(\\dot F\\)。 电压串联负反馈电路 \\[\\dot F_\\mathrm{uu}=\\frac{\\dot U_\\mathrm{f}}{\\dot U_\\mathrm{o}}\\Rightarrow \\dot A_\\mathrm{uuf}=\\frac{\\dot U_\\mathrm{o}}{\\dot U_\\mathrm{i}}\\approx \\frac{\\dot U_\\mathrm{0}}{\\dot U_\\mathrm{f}}=\\frac{1}{\\dot F_\\mathrm{uu}}\\] 例 画出方框图： 由于\\(\\dot U_\\mathrm{i}\\approx \\dot U_\\mathrm{f}=\\dot U_\\mathrm{o}\\)，得到： \\[\\dot F_\\mathrm{uu}=\\frac{\\dot U_\\mathrm{f}}{\\dot U_\\mathrm{o}}=1\\Rightarrow \\dot A_\\mathrm{uuf}\\approx\\frac{1}{\\dot F_\\mathrm{uu}}=1\\] 电压并联负反馈电路 \\[\\dot{F}_{u i}=\\frac{\\dot{I}_{\\mathrm{f}}}{\\dot{U}_{\\mathrm{o}}} \\Rightarrow \\dot{A}_{u \\mathrm{sf}}=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}} \\approx \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{I}_{\\mathrm{s}} R_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{I}_{\\mathrm{i}} R_{\\mathrm{s}}} \\approx \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{I}_{\\mathrm{f}}} \\cdot \\frac{1}{R_{\\mathrm{s}}}=\\frac{1}{\\dot{F}_{u i}} \\cdot \\frac{1}{R_{\\mathrm{s}}}\\] \\(\\dot U_\\mathrm{s}\\approx \\dot I_\\mathrm{s}R_\\mathrm{s}\\) 由于\\(R_s\\)需要取得很大，才能讲电压源串联电阻看作电流源，并且从放大电路的输入端看进去的输入电阻应该是很小的，因此可以看作电压全部降在\\(R_\\mathrm{s}\\)上。 例 画出方框图： \\[\\dot{F}_\\mathrm{ui}=\\frac{\\dot{I}_{\\mathrm{f}}}{\\dot{U}_{\\mathrm{o}}}=\\frac{-\\dot{U}_{o} / R_{1}}{\\dot{U}_{\\mathrm{o}}}=-\\frac{1}{R_{1}} \\Rightarrow \\dot{A}_{u \\mathrm{","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:19","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#反馈"},{"categories":null,"content":"反馈 类型 正负 正反馈引入正反馈的电路通常也有负反馈，并且负反馈的作用强度比正反馈大得多。 例 自举电路 \\[I_\\mathrm{R_1}=\\frac{U_P-U_N}{R_1}\\] 把\\(R_1\\)等效成\\(R_1^\\prime\\)： 等效的前提是要保证流过\\(R_1^\\prime\\)的电流不变，也就是： \\[R_1^\\prime=\\frac{U_\\mathrm{i}}{I_{R_1}}=\\frac{U_P}{U_p-U_N}\\cdot R_1\\] 在认为运放是理想运放的前提下： \\[R_\\mathrm{i}=R_\\mathrm{i}^\\prime\\|R_\\mathrm{1}^\\prime=\\infty\\] 通过引入正反馈，增大输入电阻，因而提高输入电压。 豪兰德电流源 若负载电阻的阻值下降： 通过\\(R_2\\)的负反馈引起输出电流上升。 使得\\(u_P\\)下降，导致\\(u_P\\)下降，引起输出电流的下降。 在理想运放下： \\[\\begin{array}{l} i_{R 1}=i_{R 2}, \\quad i_{R 3}=i_{R}+i_{0}, \\quad u_{\\mathrm{N}}=u_{p}\\\\ \\frac{u_{\\mathrm{I}}-u_{\\mathrm{p}}}{R_{1}}=\\frac{u_{\\mathrm{p}}-u_{\\mathrm{o}}}{R_{2}}, \\frac{u_{\\mathrm{o}}-u_{\\mathrm{p}}}{R_{3}}=\\frac{u_{\\mathrm{p}}}{R}+i_{\\mathrm{o}} \\end{array}\\] 得出了一条重要的结论： \\[\\frac{R_2}{R_1}=\\frac{R_3}{R}\\Rightarrow i_\\mathrm{o}=-\\frac{u_\\mathrm{i}}{R}\\] 负反馈 直流和交流 直流反馈：直流通路中的反馈。 交流反馈：交流通路中的反馈。 全局和局部 级间（全局）反馈：在整个多级放大电路的输入级引入反馈。 局部反馈：在多级放大电路的某一级的输入引入反馈。 组态 电压反馈和电流反馈 根据负载的不同需求来决定，比如是恒压还是恒流。 电压反馈 将输出电压的一部分或全部引回到输入回路来影响净输入量的为电压反馈。 电流反馈 将输出电流的一部分或全部引回到输入回路来影响净输入量的为电流反馈。 串联反馈和并联反馈根据信号源的类型来决定，比如信号源更接近恒压源还是恒流源。 串联反馈 适用于更接近恒压源的信号源，这样反馈网络控制在自己身上的分压，即可控制基本放大电路的输入电压。 并联反馈 适用于更接近恒流源的信号源，这样反馈网络控制流过自身的电流，即可控制流入基本放大电路的电流。 判断 有无反馈 看输入回路和输出回路之间有无联系，输出端会不会对输入端产生影响。 例 该电路没有反馈，因为从输出端接回来的输入端是接地的，也就是说不管输出端怎么变化，同相输入端的电位始终为0。 该电路有反馈，由于输出回路并联的电阻在源极上，因此输出回路的变化会对输入回路产生影响。 直流/交流 分别判断在直流通路下和交流通路下有无反馈。 反馈正负 注意，反馈只和输出对输入的作用有关。可以使用瞬时极性法，假设给予输入一个正向的变化，看输出对输入有什么样的影响。对于晶体管和运放而言，输入的变化基本都是电压引起的，而在输出上，晶体管体现为电流，而运放体现为电压。 原则 端子 极性 反馈 相同 相同 正 相同 相反 负 相异 相反 正 相异 相同 负 例 反相输入端电位升高，导致输出电位降低，导致流过\\(R_2\\)的电流增大，流过\\(R_1\\)的电流也增大，\\(R_1\\)上的分压增大，导致反相输入端的电位降低。因此是负反馈。 电压/电流 令输出电压为0（接地），若反馈量随之为0，则为电压反馈；若反馈量依然存在，则为电流反馈。电压型负反馈相当于稳定了一个电压源，电流型负反馈相当于稳定了一个电流源， 例 先用瞬时极性法，得到\\(T_2\\)发射极的极性是负的，输入端的\\(u_S\\)串联\\(R_s\\)和\\(V_{EE}\\)串联\\(R_3\\)可以看作是电流源，通过\\(R_2\\)流入\\(V_{EE}\\)的电流减小，通过\\(R_5\\)流入\\(V_EE\\)的电流增大，\\(T_1\\)的基极电流减小，因此是负反馈。然后再假设输出直接接地，由于三极管是一个流控电流源，电流源是可以被短路的，射极电流取决于基极电流，因此是电流负反馈。 串联/并联 输入信号和反馈信号的叠加关系。可以看反馈如果出现在与输入相同的端子上（取决于\\(u_\\mathrm{I}\\)被规定在哪），就是并联反馈，如果是相异的端子，就是串联反馈。也可以看反馈和输入电压有无可确定的电位关系，如果有则是串联反馈。还可以看信号源的类型，像电压源串联电阻能够将其看作电流源。 例 并联反馈：\\(i_N=i_I-i_F\\) 串联反馈：\\(u_D=u_I-u_F\\) 方框图 \\(\\dot A=\\frac{\\dot X_\\mathrm{o}}{\\dot X_\\mathrm{i}^\\prime}\\)：基本放大电路的放大倍数 \\(\\dot F=\\frac{\\dot X_\\mathrm{f}}{\\dot X_\\mathrm{o}}\\)：反馈系数 \\(\\dot A_\\mathrm{f}=\\frac{\\dot X_\\mathrm{o}}{\\dot X_\\mathrm{i}}=\\frac{\\dot A}{1+\\dot A\\dot F}\\)：反馈放大电路的放大倍数 反馈深度\\(1+\\dot A\\dot F\\gg 1\\Rightarrow \\dot A_\\mathrm{f}\\approx\\frac{1}{\\dot F}\\Rightarrow \\dot X_\\mathrm{i}\\approx\\dot X_\\mathrm{f}\\)：深度负反馈 也就是说在深度负反馈电路中，\\(\\dot F\\)基本决定了整个电路的放大倍数，可以不用考虑\\(\\dot A\\)的参数了。这里被忽略的\\(1\\)实际上就是净输入量\\(u_\\mathrm{N}-u_\\mathrm{P}\\)，也就是深度负反馈造成的虚短，这是虚短的另一种理解。 \\(1+\\dot A\\dot F\\)是反馈深度，在对放大电路的影响中会大量出现。 \\(\\dot A\\dot F\\)：环路放大倍数 表示基本放大电路的输入和反馈输出的关系。 \\(\\dot A\\dot F\u003e0\\)（同号）：负反馈 也可以推出\\(\\dot A_\\mathrm{f},\\dot A,\\dot F\\)符号相同。 电压放大倍数（估算）要估算电压放大倍数就要求在电路中的\\(\\dot F\\)。 电压串联负反馈电路 \\[\\dot F_\\mathrm{uu}=\\frac{\\dot U_\\mathrm{f}}{\\dot U_\\mathrm{o}}\\Rightarrow \\dot A_\\mathrm{uuf}=\\frac{\\dot U_\\mathrm{o}}{\\dot U_\\mathrm{i}}\\approx \\frac{\\dot U_\\mathrm{0}}{\\dot U_\\mathrm{f}}=\\frac{1}{\\dot F_\\mathrm{uu}}\\] 例 画出方框图： 由于\\(\\dot U_\\mathrm{i}\\approx \\dot U_\\mathrm{f}=\\dot U_\\mathrm{o}\\)，得到： \\[\\dot F_\\mathrm{uu}=\\frac{\\dot U_\\mathrm{f}}{\\dot U_\\mathrm{o}}=1\\Rightarrow \\dot A_\\mathrm{uuf}\\approx\\frac{1}{\\dot F_\\mathrm{uu}}=1\\] 电压并联负反馈电路 \\[\\dot{F}_{u i}=\\frac{\\dot{I}_{\\mathrm{f}}}{\\dot{U}_{\\mathrm{o}}} \\Rightarrow \\dot{A}_{u \\mathrm{sf}}=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{U}_{\\mathrm{s}}} \\approx \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{I}_{\\mathrm{s}} R_{\\mathrm{s}}}=\\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{I}_{\\mathrm{i}} R_{\\mathrm{s}}} \\approx \\frac{\\dot{U}_{\\mathrm{o}}}{\\dot{I}_{\\mathrm{f}}} \\cdot \\frac{1}{R_{\\mathrm{s}}}=\\frac{1}{\\dot{F}_{u i}} \\cdot \\frac{1}{R_{\\mathrm{s}}}\\] \\(\\dot U_\\mathrm{s}\\approx \\dot I_\\mathrm{s}R_\\mathrm{s}\\) 由于\\(R_s\\)需要取得很大，才能讲电压源串联电阻看作电流源，并且从放大电路的输入端看进去的输入电阻应该是很小的，因此可以看作电压全部降在\\(R_\\mathrm{s}\\)上。 例 画出方框图： \\[\\dot{F}_\\mathrm{ui}=\\frac{\\dot{I}_{\\mathrm{f}}}{\\dot{U}_{\\mathrm{o}}}=\\frac{-\\dot{U}_{o} / R_{1}}{\\dot{U}_{\\mathrm{o}}}=-\\frac{1}{R_{1}} \\Rightarrow \\dot{A}_{u \\mathrm{","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:2:19","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#自激振荡"},{"categories":null,"content":"运算电路 在运算电路中，假设所有运放均为工作在线性区的理想运放，也就是必须要引入负反馈。并且在分析电路时，也要通过负反馈回路，求得输出与输入的关系。 设计思路 思路1：虚短/虚断 根据虚短，由于输出电压由 (2) 决定，如果要让一个元器件的电压决定输出的话，就要接在 (2) 。而根据虚断， (1) 的电流与 (2) 相同，如果 (2) 为电阻的话，就可以轻易地将流过 (1) 的电流转换为电压输出，因此如果要让一个元器件的电流决定输出的话，应当接在 (1) 。不同特性的元器件如下： 特性 元件 比例 电阻 积分/微分 电容 指数/对数 PN结（二极管/三极管） 思路2：逆运算 把一个已知运算的电路作为反馈回路，就得到其逆运算的电路，即求反函数。 分析举例 电路均为运算电路，求解运算关系式，确定其中模拟乘法器k值的极性。 注意这里假设的极性不会影响\\(k\\)正负的判断： \\[\\begin{aligned} u_{o}^{\\prime}\u0026=-\\left(\\frac{R_{3}}{R_{1}} \\cdot u_{\\mathrm{I} 1}+\\frac{R_{3}}{R_{2}} \\cdot u_{\\mathrm{I} 2}\\right)=k u_{\\mathrm{I} 3} u_{o}\\\\ u_{o}\u0026=-\\frac{\\frac{R_{3}}{R_{1}} \\cdot u_{\\mathrm{I} 1}+\\frac{R_{3}}{R_{2}} \\cdot u_{\\mathrm{I} 2}}{k u_{\\mathrm{I} 3}}(k\u003e0) \\end{aligned}\\] 电路均为运算电路，求解运算关系式，确定其中模拟乘法器k值的极性。 判断运放输出的极性既可以从输入的端口判断，有可以从反馈回路来判断： \\[\\begin{aligned} u_{\\mathrm{o} 1}\u0026=k u_{\\mathrm{I} 1}^{2}, \\\\ u_{\\mathrm{o} 2}\u0026=k u_{\\mathrm{I2}}^{2} \\\\ u_{\\mathrm{o} 3}\u0026=-\\left(k u_{\\mathrm{I} 1}^{2}+k u_{\\mathrm{l} 2}^{2}\\right) \\\\ u_{\\mathrm{o} 4}\u0026=-u_{\\mathrm{o} 3}=k u_{\\mathrm{o}}^{2} \\\\ u_{\\mathrm{o}}\u0026=\\sqrt{u_{\\mathrm{I} 1}^{2}+u_{\\mathrm{I2}}^{2}} \\end{aligned}\\] 当\\(k\u003c0\\)时同理。可以得到最终结果为： \\[\\begin{cases} u_{\\mathrm{o}}=\\sqrt{u_{\\mathrm{I} 1}^{2}+u_{\\mathrm{I2}}^{2}}, \\quad k \u003e 0 \\\\ u_{\\mathrm{o}}=-\\sqrt{u_{\\mathrm{I} 1}^{2}+u_{\\mathrm{I2}}^{2}}, \\quad k \u003c 0 \\end{cases}\\] 利用运算电路，求解方程\\(4 x^{2}-20 x+16=0\\)。已知模拟乘法器的相乘因子为\\(0.1\\text{V}^{-1}\\)。 化简方程： \\[4 u_{\\mathrm{I}}^{2}-20 u_{\\mathrm{I}}+16=0 \\rightarrow u_{\\mathrm{I}}^{2}-5 u_{\\mathrm{I}}+4=0\\] 搭建电路如下（电路不唯一）： 相当于用电路搭建出一个函数了，现在只要求函数的零点即可，即调整\\(u_\\mathrm{I1}\\)，使得输出为\\(0\\)的\\(u_\\mathrm{I1}\\)就是方程的解。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#运算电路"},{"categories":null,"content":"比例运算电路 与电压放大电路的区别如下：    电路     比例运算电路                               电压放大电路                                             研究对象                         运算精度                                   电压放大倍数和最大不失真输出电压   时域（特定时间输出电压与输入电压的关系）   频域（截止频率）                                              输入电阻、输出电阻                                此外，比例运算电路可以当电压放大电路用，而电压放大器不能当比例运算电路用。 例 对每个运放进行单独分析，上方运放的电流从同相输入端输入，是一个同相比例运算电路，下方运放的电流从反相输入端流入，是反相比例运算电路，得到： \\[\\begin{aligned} u_{1} \u0026=\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ u_{o 2} \u0026=-\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ u_{O} \u0026=2\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ R_{i} \u0026=\\infty \\\\ R_{o} \u0026=0 \\end{aligned}\\] 与单个运放的同相比例运算电路相比，好处是可以将单端输出的信号源变为双端输出。 反相比例运算电路 相当于以\\(i_\\mathrm{F}=i_\\mathrm{R}\\)为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)， \\(\\frac{u_\\mathrm{O}}{i_\\mathrm{F}}=R_\\mathrm{f}\\)，两者都与\\(i_\\mathrm{F}\\)成比例，因此两者成比例。 \\(R^\\prime=R\\|R_\\mathrm{f}\\) 保证输入级的对称性。由于理想运放的输入级往往是一个理想对称的差分放大电路。实际运放的输入端是存在静态电流的，如果一个输入端直接接地，电位为\\(0\\)，而另一个输入端由于有电阻，存在电位，就直接引入差模输入。为了防止外接电阻破坏了这种对称，需要加上\\(R^\\prime\\)，并且假设输入和输出都接地的情况下，大小为\\(R\\|R_\\mathrm{f}\\)。电路引入了电压并联负反馈。由于运算电路均假设为理想运放，引入的负反馈为深度负反馈，输出电阻为0，并且带上负载后输入电压与输出电压的关系不变，因此每一级可以单独地进行分析， 由于从\\(R\\)往右看，电位始终为0，因此右边等效输入电阻为\\(0\\)，因此输入电阻就是\\(R\\)。或者从输入电阻的定义\\(R_\\mathrm{i}=\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)，输入电阻也是\\(R\\)。共模信号为\\(0\\)。 根据虚短和虚断，有： \\[\\begin{aligned} i_\\mathrm{N}=i_\\mathrm{P}=0\\\\ u_\\mathrm{N}=u_\\mathrm{P}=0 \\end{aligned}\\] 得到： \\[\\begin{aligned} i_{\\mathrm{F}}\u0026=i_{R}=\\frac{u_{1}}{R}\\\\ u_{o}\u0026=-i_{f} R_{f}=-\\frac{R_{f}}{R} \\cdot u_{I} \\end{aligned}\\] 问题 当要求比例系数和输入电阻都大的时候，\\(R_\\mathrm{f}\\)需要非常大的电阻，由于电阻越大，引入的噪声越多，电路就容易产生噪音。 T型反馈网络反相比例运算电路 \\[\\begin{aligned} i_{2}\u0026=i_{1}=\\frac{u_{i}}{R_{1}}\\\\ u_{M}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{i}\\\\ u_{0}\u0026=u_{\\mathrm{M}}-\\left(i_{2}+i_{3}\\right) R_{4}\\\\ i_{3}\u0026=-\\frac{u_{M}}{R_{3}}\\\\ \\end{aligned}\\Rightarrow u_{0}=-\\frac{R_{2}+R_{4}}{R_{1}}\\left(1+\\frac{R_{2} / / R_{4}}{R_{3}}\\right) \\cdot u_{i}\\] 优点 可以在不使用大电阻的情况下，达到较大的比例系数和输入电阻。 例 若要求输入电阻为\\(100\\text{k}\\Omega\\)，比例系数为\\(-100\\)，则电阻可以这么取： \\[\\begin{aligned} R_1\u0026=R_2=R_4=100\\text{k}\\Omega \\\\ R_3\u0026=\\frac{50}{49}\\text{k}\\Omega \\end{aligned}\\] 而使用反相比例运算电路的话，\\(R_\\mathrm{f}\\)就必须是一个兆欧级的大电阻。 同相比例运算电路 相当于以\\(i_\\mathrm{F}=i_\\mathrm{R}\\)为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)， \\(\\frac{u_\\mathrm{O}}{i_\\mathrm{F}}=R_\\mathrm{f}+R\\)，两者都与\\(i_\\mathrm{F}\\)成比例，因此两者成比例。 \\(R^\\prime=R\\|R_\\mathrm{f}\\) 电路引入了电压串联负反馈，并且输入电阻为无穷大。根据虚短和虚断，有： \\[u_\\mathrm{N}=u_\\mathrm{P}=u_\\mathrm{i}\\] 得到： \\[u_\\mathrm{o}=(R+R_\\mathrm{f})\\cdot \\frac{u_\\mathrm{N}}{R}=\\left(1+\\frac{R_\\mathrm{f}}{R}\\right)\\cdot u_\\mathrm{i}\\] 由于不像反相比例运算电路那样，\\(u_\\mathrm{N}=u_\\mathrm{P}=0\\)，因此共模输入可能影响运算电路的精度，此时集成运放的共模抑制比显得十分重要。 电压跟随器 是同相比例运算电路的特例： \\(u_\\mathrm{o}=u_\\mathrm{N}=u_\\mathrm{P}=u_\\mathrm{i}\\) \\(\\dot F=1\\) \\(R_\\mathrm{i}=\\infty\\) \\(R_\\mathrm{o}=0\\) \\(u_\\mathrm{ic}=u_\\mathrm{i}\\)（共模输入电压） ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#比例运算电路"},{"categories":null,"content":"比例运算电路 与电压放大电路的区别如下：    电路     比例运算电路                               电压放大电路                                             研究对象                         运算精度                                   电压放大倍数和最大不失真输出电压   时域（特定时间输出电压与输入电压的关系）   频域（截止频率）                                              输入电阻、输出电阻                                此外，比例运算电路可以当电压放大电路用，而电压放大器不能当比例运算电路用。 例 对每个运放进行单独分析，上方运放的电流从同相输入端输入，是一个同相比例运算电路，下方运放的电流从反相输入端流入，是反相比例运算电路，得到： \\[\\begin{aligned} u_{1} \u0026=\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ u_{o 2} \u0026=-\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ u_{O} \u0026=2\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ R_{i} \u0026=\\infty \\\\ R_{o} \u0026=0 \\end{aligned}\\] 与单个运放的同相比例运算电路相比，好处是可以将单端输出的信号源变为双端输出。 反相比例运算电路 相当于以\\(i_\\mathrm{F}=i_\\mathrm{R}\\)为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)， \\(\\frac{u_\\mathrm{O}}{i_\\mathrm{F}}=R_\\mathrm{f}\\)，两者都与\\(i_\\mathrm{F}\\)成比例，因此两者成比例。 \\(R^\\prime=R\\|R_\\mathrm{f}\\) 保证输入级的对称性。由于理想运放的输入级往往是一个理想对称的差分放大电路。实际运放的输入端是存在静态电流的，如果一个输入端直接接地，电位为\\(0\\)，而另一个输入端由于有电阻，存在电位，就直接引入差模输入。为了防止外接电阻破坏了这种对称，需要加上\\(R^\\prime\\)，并且假设输入和输出都接地的情况下，大小为\\(R\\|R_\\mathrm{f}\\)。电路引入了电压并联负反馈。由于运算电路均假设为理想运放，引入的负反馈为深度负反馈，输出电阻为0，并且带上负载后输入电压与输出电压的关系不变，因此每一级可以单独地进行分析， 由于从\\(R\\)往右看，电位始终为0，因此右边等效输入电阻为\\(0\\)，因此输入电阻就是\\(R\\)。或者从输入电阻的定义\\(R_\\mathrm{i}=\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)，输入电阻也是\\(R\\)。共模信号为\\(0\\)。 根据虚短和虚断，有： \\[\\begin{aligned} i_\\mathrm{N}=i_\\mathrm{P}=0\\\\ u_\\mathrm{N}=u_\\mathrm{P}=0 \\end{aligned}\\] 得到： \\[\\begin{aligned} i_{\\mathrm{F}}\u0026=i_{R}=\\frac{u_{1}}{R}\\\\ u_{o}\u0026=-i_{f} R_{f}=-\\frac{R_{f}}{R} \\cdot u_{I} \\end{aligned}\\] 问题 当要求比例系数和输入电阻都大的时候，\\(R_\\mathrm{f}\\)需要非常大的电阻，由于电阻越大，引入的噪声越多，电路就容易产生噪音。 T型反馈网络反相比例运算电路 \\[\\begin{aligned} i_{2}\u0026=i_{1}=\\frac{u_{i}}{R_{1}}\\\\ u_{M}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{i}\\\\ u_{0}\u0026=u_{\\mathrm{M}}-\\left(i_{2}+i_{3}\\right) R_{4}\\\\ i_{3}\u0026=-\\frac{u_{M}}{R_{3}}\\\\ \\end{aligned}\\Rightarrow u_{0}=-\\frac{R_{2}+R_{4}}{R_{1}}\\left(1+\\frac{R_{2} / / R_{4}}{R_{3}}\\right) \\cdot u_{i}\\] 优点 可以在不使用大电阻的情况下，达到较大的比例系数和输入电阻。 例 若要求输入电阻为\\(100\\text{k}\\Omega\\)，比例系数为\\(-100\\)，则电阻可以这么取： \\[\\begin{aligned} R_1\u0026=R_2=R_4=100\\text{k}\\Omega \\\\ R_3\u0026=\\frac{50}{49}\\text{k}\\Omega \\end{aligned}\\] 而使用反相比例运算电路的话，\\(R_\\mathrm{f}\\)就必须是一个兆欧级的大电阻。 同相比例运算电路 相当于以\\(i_\\mathrm{F}=i_\\mathrm{R}\\)为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)， \\(\\frac{u_\\mathrm{O}}{i_\\mathrm{F}}=R_\\mathrm{f}+R\\)，两者都与\\(i_\\mathrm{F}\\)成比例，因此两者成比例。 \\(R^\\prime=R\\|R_\\mathrm{f}\\) 电路引入了电压串联负反馈，并且输入电阻为无穷大。根据虚短和虚断，有： \\[u_\\mathrm{N}=u_\\mathrm{P}=u_\\mathrm{i}\\] 得到： \\[u_\\mathrm{o}=(R+R_\\mathrm{f})\\cdot \\frac{u_\\mathrm{N}}{R}=\\left(1+\\frac{R_\\mathrm{f}}{R}\\right)\\cdot u_\\mathrm{i}\\] 由于不像反相比例运算电路那样，\\(u_\\mathrm{N}=u_\\mathrm{P}=0\\)，因此共模输入可能影响运算电路的精度，此时集成运放的共模抑制比显得十分重要。 电压跟随器 是同相比例运算电路的特例： \\(u_\\mathrm{o}=u_\\mathrm{N}=u_\\mathrm{P}=u_\\mathrm{i}\\) \\(\\dot F=1\\) \\(R_\\mathrm{i}=\\infty\\) \\(R_\\mathrm{o}=0\\) \\(u_\\mathrm{ic}=u_\\mathrm{i}\\)（共模输入电压） ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#反相比例运算电路"},{"categories":null,"content":"比例运算电路 与电压放大电路的区别如下：    电路     比例运算电路                               电压放大电路                                             研究对象                         运算精度                                   电压放大倍数和最大不失真输出电压   时域（特定时间输出电压与输入电压的关系）   频域（截止频率）                                              输入电阻、输出电阻                                此外，比例运算电路可以当电压放大电路用，而电压放大器不能当比例运算电路用。 例 对每个运放进行单独分析，上方运放的电流从同相输入端输入，是一个同相比例运算电路，下方运放的电流从反相输入端流入，是反相比例运算电路，得到： \\[\\begin{aligned} u_{1} \u0026=\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ u_{o 2} \u0026=-\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ u_{O} \u0026=2\\left(1+\\frac{R_{3}}{R_{2}}\\right) u_{I} \\\\ R_{i} \u0026=\\infty \\\\ R_{o} \u0026=0 \\end{aligned}\\] 与单个运放的同相比例运算电路相比，好处是可以将单端输出的信号源变为双端输出。 反相比例运算电路 相当于以\\(i_\\mathrm{F}=i_\\mathrm{R}\\)为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)， \\(\\frac{u_\\mathrm{O}}{i_\\mathrm{F}}=R_\\mathrm{f}\\)，两者都与\\(i_\\mathrm{F}\\)成比例，因此两者成比例。 \\(R^\\prime=R\\|R_\\mathrm{f}\\) 保证输入级的对称性。由于理想运放的输入级往往是一个理想对称的差分放大电路。实际运放的输入端是存在静态电流的，如果一个输入端直接接地，电位为\\(0\\)，而另一个输入端由于有电阻，存在电位，就直接引入差模输入。为了防止外接电阻破坏了这种对称，需要加上\\(R^\\prime\\)，并且假设输入和输出都接地的情况下，大小为\\(R\\|R_\\mathrm{f}\\)。电路引入了电压并联负反馈。由于运算电路均假设为理想运放，引入的负反馈为深度负反馈，输出电阻为0，并且带上负载后输入电压与输出电压的关系不变，因此每一级可以单独地进行分析， 由于从\\(R\\)往右看，电位始终为0，因此右边等效输入电阻为\\(0\\)，因此输入电阻就是\\(R\\)。或者从输入电阻的定义\\(R_\\mathrm{i}=\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)，输入电阻也是\\(R\\)。共模信号为\\(0\\)。 根据虚短和虚断，有： \\[\\begin{aligned} i_\\mathrm{N}=i_\\mathrm{P}=0\\\\ u_\\mathrm{N}=u_\\mathrm{P}=0 \\end{aligned}\\] 得到： \\[\\begin{aligned} i_{\\mathrm{F}}\u0026=i_{R}=\\frac{u_{1}}{R}\\\\ u_{o}\u0026=-i_{f} R_{f}=-\\frac{R_{f}}{R} \\cdot u_{I} \\end{aligned}\\] 问题 当要求比例系数和输入电阻都大的时候，\\(R_\\mathrm{f}\\)需要非常大的电阻，由于电阻越大，引入的噪声越多，电路就容易产生噪音。 T型反馈网络反相比例运算电路 \\[\\begin{aligned} i_{2}\u0026=i_{1}=\\frac{u_{i}}{R_{1}}\\\\ u_{M}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{i}\\\\ u_{0}\u0026=u_{\\mathrm{M}}-\\left(i_{2}+i_{3}\\right) R_{4}\\\\ i_{3}\u0026=-\\frac{u_{M}}{R_{3}}\\\\ \\end{aligned}\\Rightarrow u_{0}=-\\frac{R_{2}+R_{4}}{R_{1}}\\left(1+\\frac{R_{2} / / R_{4}}{R_{3}}\\right) \\cdot u_{i}\\] 优点 可以在不使用大电阻的情况下，达到较大的比例系数和输入电阻。 例 若要求输入电阻为\\(100\\text{k}\\Omega\\)，比例系数为\\(-100\\)，则电阻可以这么取： \\[\\begin{aligned} R_1\u0026=R_2=R_4=100\\text{k}\\Omega \\\\ R_3\u0026=\\frac{50}{49}\\text{k}\\Omega \\end{aligned}\\] 而使用反相比例运算电路的话，\\(R_\\mathrm{f}\\)就必须是一个兆欧级的大电阻。 同相比例运算电路 相当于以\\(i_\\mathrm{F}=i_\\mathrm{R}\\)为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{R}}=R\\)， \\(\\frac{u_\\mathrm{O}}{i_\\mathrm{F}}=R_\\mathrm{f}+R\\)，两者都与\\(i_\\mathrm{F}\\)成比例，因此两者成比例。 \\(R^\\prime=R\\|R_\\mathrm{f}\\) 电路引入了电压串联负反馈，并且输入电阻为无穷大。根据虚短和虚断，有： \\[u_\\mathrm{N}=u_\\mathrm{P}=u_\\mathrm{i}\\] 得到： \\[u_\\mathrm{o}=(R+R_\\mathrm{f})\\cdot \\frac{u_\\mathrm{N}}{R}=\\left(1+\\frac{R_\\mathrm{f}}{R}\\right)\\cdot u_\\mathrm{i}\\] 由于不像反相比例运算电路那样，\\(u_\\mathrm{N}=u_\\mathrm{P}=0\\)，因此共模输入可能影响运算电路的精度，此时集成运放的共模抑制比显得十分重要。 电压跟随器 是同相比例运算电路的特例： \\(u_\\mathrm{o}=u_\\mathrm{N}=u_\\mathrm{P}=u_\\mathrm{i}\\) \\(\\dot F=1\\) \\(R_\\mathrm{i}=\\infty\\) \\(R_\\mathrm{o}=0\\) \\(u_\\mathrm{ic}=u_\\mathrm{i}\\)（共模输入电压） ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#同相比例运算电路"},{"categories":null,"content":"求和运算电路 反相求和运算电路 从反相比例运算电路出发，以电流并联求和为中介。 有两种分析方法： 节点电流法 根据虚短和虚断，有： \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{R 1}+i_{R 2}+i_{R 3}\\\\ \u0026=\\frac{u_{11}}{R_{1}}+\\frac{u_{12}}{R_{2}}+\\frac{u_{13}}{R_{3}} \\end{aligned}\\] 得到： \\[u_{\\mathrm{o}}=-i_{\\mathrm{F}} R_{\\mathrm{f}}=-R_{\\mathrm{f}}\\left(\\frac{u_{\\mathrm{i1}}}{R_{1}}+\\frac{u_{\\mathrm{i2}}}{R_{2}}+\\frac{u_{\\mathrm{i} 3}}{R_{3}}\\right)\\] 叠加定理 由于电路中没有非线性元件，因此叠加定理可用。将除\\(u_\\mathrm{I1}\\)之外的输入置零： 得到： \\[u_{o1}=-\\frac{R_{\\mathrm{f}}}{R_{1}} \\cdot u_{\\mathrm{I} 1}\\] 同理： \\[\\begin{aligned} u_{\\mathrm{o} 2}\u0026=-\\frac{R_{\\mathrm{f}}}{R_{2}} \\cdot u_{\\mathrm{I} 2}\\\\ u_{\\mathrm{o} 3}\u0026=-\\frac{R_{\\mathrm{f}}}{R_{3}} \\cdot u_{\\mathrm{I} 3} \\end{aligned}\\] 由叠加定理，得： \\[\\begin{aligned} u_{\\mathrm{o}}\u0026=u_{\\mathrm{o} 1}+u_{\\mathrm{o} 2}+u_{\\mathrm{o}}\\\\ \u0026=-\\frac{R_{f}}{R_{1}} \\cdot u_\\mathrm{I 1}-\\frac{R_{f}}{R_{2}} \\cdot u_{\\mathrm{I} 2}-\\frac{R_{f}}{R_{3}} \\cdot u_{\\mathrm{I} 3} \\end{aligned}\\] 同相求和运算电路 \\(R_1\\|R_2\\|R_3\\|R_4=R\\|R_\\mathrm{f}\\) 也可以尝试使用两种分析方法： 叠加定理 \\[u_{O 1}=\\left(1+\\frac{R_{f}}{R}\\right) \\cdot \\frac{R_{2} / / R_{3} / / R_{4}}{R_{1}+R_{2} / / R_{3} / / R_{4}} \\cdot u_{1 1}\\] \\(u_\\mathrm{O2},u_\\mathrm{O3}\\)形式相同，但表达式繁琐，计算麻烦。 节点电流+等式变换 \\[\\begin{aligned} i_{4}\u0026=i_{1}+i_{2}+i_{3}\\\\ \\frac{u_{p}}{R_{4}}\u0026=\\frac{u_{11}-u_{p}}{R_{1}}+\\frac{u_{12}-u_{p}}{R_{2}}+\\frac{u_{13}-u_{p}}{R_{3}}\\\\ \\frac{u_{11}}{R_{1}}+\\frac{u_{12}}{R_{2}}+\\frac{u_{13}}{R_{3}}\u0026=\\left(\\frac{1}{R_{1}}+\\frac{1}{R_{2}}+\\frac{1}{R_{3}}+\\frac{1}{R_{4}}\\right) u_\\mathrm{P}\\\\ u_{\\mathrm{P}}\u0026=(R / / R_\\mathrm{f})\\left(\\frac{u_{\\mathrm{I1}}}{R_{1}}+\\frac{u_{\\mathrm{I} 2}}{R_{2}}+\\frac{u_{\\mathrm{I3}}}{R_{3}}\\right) \\end{aligned}\\] 得到输出电压： \\[u_{\\mathrm{O}}=\\left(1+\\frac{R_{\\mathrm{f}}}{R}\\right) \\cdot u_{\\mathrm{p}}=\\frac{R+R_{\\mathrm{f}}}{R} \\cdot (R / / R_\\mathrm{f})\\left(\\frac{u_{\\mathrm{I1}}}{R_{1}}+\\frac{u_{\\mathrm{l2}}}{R_{2}}+\\frac{u_{\\mathrm{I} 3}}{R_{3}}\\right) \\cdot \\frac{R_{\\mathrm{f}}}{R_{\\mathrm{f}}}\\] 这里乘以\\(\\frac{R_\\mathrm{f}}{R_\\mathrm{f}}\\)是为了凑\\(R / / R_\\mathrm{f}\\)，以便分子分母消去得到最终结果： \\[u_{\\mathrm{O}}=R_{\\mathrm{f}} \\cdot\\left(\\frac{u_{\\mathrm{I} 1}}{R_{1}}+\\frac{u_{\\mathrm{I} 2}}{R_{2}}+\\frac{u_{\\mathrm{I} 3}}{R_{3}}\\right)\\] 最终的表达式与反相求和运算电路只差了一个负号。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#求和运算电路"},{"categories":null,"content":"求和运算电路 反相求和运算电路 从反相比例运算电路出发，以电流并联求和为中介。 有两种分析方法： 节点电流法 根据虚短和虚断，有： \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{R 1}+i_{R 2}+i_{R 3}\\\\ \u0026=\\frac{u_{11}}{R_{1}}+\\frac{u_{12}}{R_{2}}+\\frac{u_{13}}{R_{3}} \\end{aligned}\\] 得到： \\[u_{\\mathrm{o}}=-i_{\\mathrm{F}} R_{\\mathrm{f}}=-R_{\\mathrm{f}}\\left(\\frac{u_{\\mathrm{i1}}}{R_{1}}+\\frac{u_{\\mathrm{i2}}}{R_{2}}+\\frac{u_{\\mathrm{i} 3}}{R_{3}}\\right)\\] 叠加定理 由于电路中没有非线性元件，因此叠加定理可用。将除\\(u_\\mathrm{I1}\\)之外的输入置零： 得到： \\[u_{o1}=-\\frac{R_{\\mathrm{f}}}{R_{1}} \\cdot u_{\\mathrm{I} 1}\\] 同理： \\[\\begin{aligned} u_{\\mathrm{o} 2}\u0026=-\\frac{R_{\\mathrm{f}}}{R_{2}} \\cdot u_{\\mathrm{I} 2}\\\\ u_{\\mathrm{o} 3}\u0026=-\\frac{R_{\\mathrm{f}}}{R_{3}} \\cdot u_{\\mathrm{I} 3} \\end{aligned}\\] 由叠加定理，得： \\[\\begin{aligned} u_{\\mathrm{o}}\u0026=u_{\\mathrm{o} 1}+u_{\\mathrm{o} 2}+u_{\\mathrm{o}}\\\\ \u0026=-\\frac{R_{f}}{R_{1}} \\cdot u_\\mathrm{I 1}-\\frac{R_{f}}{R_{2}} \\cdot u_{\\mathrm{I} 2}-\\frac{R_{f}}{R_{3}} \\cdot u_{\\mathrm{I} 3} \\end{aligned}\\] 同相求和运算电路 \\(R_1\\|R_2\\|R_3\\|R_4=R\\|R_\\mathrm{f}\\) 也可以尝试使用两种分析方法： 叠加定理 \\[u_{O 1}=\\left(1+\\frac{R_{f}}{R}\\right) \\cdot \\frac{R_{2} / / R_{3} / / R_{4}}{R_{1}+R_{2} / / R_{3} / / R_{4}} \\cdot u_{1 1}\\] \\(u_\\mathrm{O2},u_\\mathrm{O3}\\)形式相同，但表达式繁琐，计算麻烦。 节点电流+等式变换 \\[\\begin{aligned} i_{4}\u0026=i_{1}+i_{2}+i_{3}\\\\ \\frac{u_{p}}{R_{4}}\u0026=\\frac{u_{11}-u_{p}}{R_{1}}+\\frac{u_{12}-u_{p}}{R_{2}}+\\frac{u_{13}-u_{p}}{R_{3}}\\\\ \\frac{u_{11}}{R_{1}}+\\frac{u_{12}}{R_{2}}+\\frac{u_{13}}{R_{3}}\u0026=\\left(\\frac{1}{R_{1}}+\\frac{1}{R_{2}}+\\frac{1}{R_{3}}+\\frac{1}{R_{4}}\\right) u_\\mathrm{P}\\\\ u_{\\mathrm{P}}\u0026=(R / / R_\\mathrm{f})\\left(\\frac{u_{\\mathrm{I1}}}{R_{1}}+\\frac{u_{\\mathrm{I} 2}}{R_{2}}+\\frac{u_{\\mathrm{I3}}}{R_{3}}\\right) \\end{aligned}\\] 得到输出电压： \\[u_{\\mathrm{O}}=\\left(1+\\frac{R_{\\mathrm{f}}}{R}\\right) \\cdot u_{\\mathrm{p}}=\\frac{R+R_{\\mathrm{f}}}{R} \\cdot (R / / R_\\mathrm{f})\\left(\\frac{u_{\\mathrm{I1}}}{R_{1}}+\\frac{u_{\\mathrm{l2}}}{R_{2}}+\\frac{u_{\\mathrm{I} 3}}{R_{3}}\\right) \\cdot \\frac{R_{\\mathrm{f}}}{R_{\\mathrm{f}}}\\] 这里乘以\\(\\frac{R_\\mathrm{f}}{R_\\mathrm{f}}\\)是为了凑\\(R / / R_\\mathrm{f}\\)，以便分子分母消去得到最终结果： \\[u_{\\mathrm{O}}=R_{\\mathrm{f}} \\cdot\\left(\\frac{u_{\\mathrm{I} 1}}{R_{1}}+\\frac{u_{\\mathrm{I} 2}}{R_{2}}+\\frac{u_{\\mathrm{I} 3}}{R_{3}}\\right)\\] 最终的表达式与反相求和运算电路只差了一个负号。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#反相求和运算电路"},{"categories":null,"content":"求和运算电路 反相求和运算电路 从反相比例运算电路出发，以电流并联求和为中介。 有两种分析方法： 节点电流法 根据虚短和虚断，有： \\[\\begin{aligned} u_{\\mathrm{N}}\u0026=u_{\\mathrm{p}}=0\\\\ i_{\\mathrm{F}}\u0026=i_{R 1}+i_{R 2}+i_{R 3}\\\\ \u0026=\\frac{u_{11}}{R_{1}}+\\frac{u_{12}}{R_{2}}+\\frac{u_{13}}{R_{3}} \\end{aligned}\\] 得到： \\[u_{\\mathrm{o}}=-i_{\\mathrm{F}} R_{\\mathrm{f}}=-R_{\\mathrm{f}}\\left(\\frac{u_{\\mathrm{i1}}}{R_{1}}+\\frac{u_{\\mathrm{i2}}}{R_{2}}+\\frac{u_{\\mathrm{i} 3}}{R_{3}}\\right)\\] 叠加定理 由于电路中没有非线性元件，因此叠加定理可用。将除\\(u_\\mathrm{I1}\\)之外的输入置零： 得到： \\[u_{o1}=-\\frac{R_{\\mathrm{f}}}{R_{1}} \\cdot u_{\\mathrm{I} 1}\\] 同理： \\[\\begin{aligned} u_{\\mathrm{o} 2}\u0026=-\\frac{R_{\\mathrm{f}}}{R_{2}} \\cdot u_{\\mathrm{I} 2}\\\\ u_{\\mathrm{o} 3}\u0026=-\\frac{R_{\\mathrm{f}}}{R_{3}} \\cdot u_{\\mathrm{I} 3} \\end{aligned}\\] 由叠加定理，得： \\[\\begin{aligned} u_{\\mathrm{o}}\u0026=u_{\\mathrm{o} 1}+u_{\\mathrm{o} 2}+u_{\\mathrm{o}}\\\\ \u0026=-\\frac{R_{f}}{R_{1}} \\cdot u_\\mathrm{I 1}-\\frac{R_{f}}{R_{2}} \\cdot u_{\\mathrm{I} 2}-\\frac{R_{f}}{R_{3}} \\cdot u_{\\mathrm{I} 3} \\end{aligned}\\] 同相求和运算电路 \\(R_1\\|R_2\\|R_3\\|R_4=R\\|R_\\mathrm{f}\\) 也可以尝试使用两种分析方法： 叠加定理 \\[u_{O 1}=\\left(1+\\frac{R_{f}}{R}\\right) \\cdot \\frac{R_{2} / / R_{3} / / R_{4}}{R_{1}+R_{2} / / R_{3} / / R_{4}} \\cdot u_{1 1}\\] \\(u_\\mathrm{O2},u_\\mathrm{O3}\\)形式相同，但表达式繁琐，计算麻烦。 节点电流+等式变换 \\[\\begin{aligned} i_{4}\u0026=i_{1}+i_{2}+i_{3}\\\\ \\frac{u_{p}}{R_{4}}\u0026=\\frac{u_{11}-u_{p}}{R_{1}}+\\frac{u_{12}-u_{p}}{R_{2}}+\\frac{u_{13}-u_{p}}{R_{3}}\\\\ \\frac{u_{11}}{R_{1}}+\\frac{u_{12}}{R_{2}}+\\frac{u_{13}}{R_{3}}\u0026=\\left(\\frac{1}{R_{1}}+\\frac{1}{R_{2}}+\\frac{1}{R_{3}}+\\frac{1}{R_{4}}\\right) u_\\mathrm{P}\\\\ u_{\\mathrm{P}}\u0026=(R / / R_\\mathrm{f})\\left(\\frac{u_{\\mathrm{I1}}}{R_{1}}+\\frac{u_{\\mathrm{I} 2}}{R_{2}}+\\frac{u_{\\mathrm{I3}}}{R_{3}}\\right) \\end{aligned}\\] 得到输出电压： \\[u_{\\mathrm{O}}=\\left(1+\\frac{R_{\\mathrm{f}}}{R}\\right) \\cdot u_{\\mathrm{p}}=\\frac{R+R_{\\mathrm{f}}}{R} \\cdot (R / / R_\\mathrm{f})\\left(\\frac{u_{\\mathrm{I1}}}{R_{1}}+\\frac{u_{\\mathrm{l2}}}{R_{2}}+\\frac{u_{\\mathrm{I} 3}}{R_{3}}\\right) \\cdot \\frac{R_{\\mathrm{f}}}{R_{\\mathrm{f}}}\\] 这里乘以\\(\\frac{R_\\mathrm{f}}{R_\\mathrm{f}}\\)是为了凑\\(R / / R_\\mathrm{f}\\)，以便分子分母消去得到最终结果： \\[u_{\\mathrm{O}}=R_{\\mathrm{f}} \\cdot\\left(\\frac{u_{\\mathrm{I} 1}}{R_{1}}+\\frac{u_{\\mathrm{I} 2}}{R_{2}}+\\frac{u_{\\mathrm{I} 3}}{R_{3}}\\right)\\] 最终的表达式与反相求和运算电路只差了一个负号。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#同相求和运算电路"},{"categories":null,"content":"加减运算电路 \\(R_1\\|R_2\\|R_\\mathrm{f}=R_3\\|R_4\\|R_5\\) 通过类似上面的分析，可以把加减运算电路看作同相求和运算电路和反相求和运算电路的结合，得到： \\[u_{o}=R_{f} \\cdot\\left(\\frac{u_{\\mathrm{I3}}}{R_{3}}+\\frac{u_{\\mathrm{I} 4}}{R_{4}}-\\frac{u_{\\mathrm{I1}}}{R_{1}}-\\frac{u_{1 2}}{R_{2}}\\right)\\] 差分运算电路 属于加减运算电路的特例，电阻参数取值合适可以实现差分放大电路的功能： \\[u_\\mathrm{O}=\\frac{R_\\mathrm{f}}{R}\\cdot (u_\\mathrm{I2}-u_\\mathrm{I1})\\] 使用两个加减运算电路也可以组成一个差分运算电路： 好处是两个输入端的输入电阻变为了无穷大。 例 仪用放大器电路 根据虚短和虚断，有： \\[u_{\\mathrm{A}}=u_{\\mathrm{I} 1} \\quad u_{\\mathrm{B}}=u_{\\mathrm{I} 2} \\quad i_{R_{1}}=i_{R_{2}}=\\frac{u_{\\mathrm{I} 1}-u_{\\mathrm{I} 2}}{R_{2}}\\] 得到： \\[\\begin{aligned} u_{01}-u_{02}\u0026=\\frac{u_{11}-u_{12}}{R_{2}} \\cdot\\left(2 R_{1}+R_{2}\\right)\\\\ \u0026=\\left(1+\\frac{2 R_{1}}{R_{2}}\\right)\\left(u_{11}-u_{12}\\right)\\\\ u_{0}\u0026=\\left(1+\\frac{2 R_{1}}{R_{2}}\\right) \\frac{R_{f}}{R}\\left(u_{12}-u_{\\mathrm{I} 1}\\right) \\end{aligned}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#加减运算电路"},{"categories":null,"content":"加减运算电路 \\(R_1\\|R_2\\|R_\\mathrm{f}=R_3\\|R_4\\|R_5\\) 通过类似上面的分析，可以把加减运算电路看作同相求和运算电路和反相求和运算电路的结合，得到： \\[u_{o}=R_{f} \\cdot\\left(\\frac{u_{\\mathrm{I3}}}{R_{3}}+\\frac{u_{\\mathrm{I} 4}}{R_{4}}-\\frac{u_{\\mathrm{I1}}}{R_{1}}-\\frac{u_{1 2}}{R_{2}}\\right)\\] 差分运算电路 属于加减运算电路的特例，电阻参数取值合适可以实现差分放大电路的功能： \\[u_\\mathrm{O}=\\frac{R_\\mathrm{f}}{R}\\cdot (u_\\mathrm{I2}-u_\\mathrm{I1})\\] 使用两个加减运算电路也可以组成一个差分运算电路： 好处是两个输入端的输入电阻变为了无穷大。 例 仪用放大器电路 根据虚短和虚断，有： \\[u_{\\mathrm{A}}=u_{\\mathrm{I} 1} \\quad u_{\\mathrm{B}}=u_{\\mathrm{I} 2} \\quad i_{R_{1}}=i_{R_{2}}=\\frac{u_{\\mathrm{I} 1}-u_{\\mathrm{I} 2}}{R_{2}}\\] 得到： \\[\\begin{aligned} u_{01}-u_{02}\u0026=\\frac{u_{11}-u_{12}}{R_{2}} \\cdot\\left(2 R_{1}+R_{2}\\right)\\\\ \u0026=\\left(1+\\frac{2 R_{1}}{R_{2}}\\right)\\left(u_{11}-u_{12}\\right)\\\\ u_{0}\u0026=\\left(1+\\frac{2 R_{1}}{R_{2}}\\right) \\frac{R_{f}}{R}\\left(u_{12}-u_{\\mathrm{I} 1}\\right) \\end{aligned}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#差分运算电路"},{"categories":null,"content":"积分/微分运算电路 积分运算电路 在实际电路中，为了防止输入为直流量导致电容可以看作短路，导致运放开环，常常在电容两端并联一个大电阻。 分析1 以\\(C\\)的电压为中介，根据虚短，\\(i_\\mathrm{C}=C\\cdot \\frac{\\mathrm{d}u_\\mathrm{C}}{\\mathrm{d}t}\\Rightarrow u_\\mathrm{O}=u_\\mathrm{C}=\\int \\frac{i_\\mathrm{C}}{C}\\mathrm{d}t\\)，电流是被积函数，再以电流为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{C}}=R\\)，电流与输入电压成比例，因此输出电压是积分。 分析2 根据虚断，有： \\[i_{C}=i_{R}=\\frac{u_{I}}{R}\\] 根据虚短，电容的左端虚地，因此电流可以看作从地流出来，电压要加上负号： \\[\\begin{aligned} u_{\\mathrm{o}}\u0026=-u_{\\mathrm{C}}=-\\frac{1}{C} \\int \\frac{u_{1}}{R} \\mathrm{~d} t\\\\ \u0026=-\\frac{1}{R C} \\int u_{1} d t\\\\ \u0026=-\\frac{1}{R C} \\int_{t_{1}}^{t_{2}} u_{1} d t+u_{\\mathrm{o}}\\left(t_{1}\\right)\\\\ \u0026=-\\frac{1}{R C} \\cdot u_{1}\\left(t_{2}-t_{1}\\right)+u_{0}\\left(t_{1}\\right) \\end{aligned}\\] 注意两个括号的含义不同，\\((t_2-t_1)\\)代表的是相乘，而\\((t_1)\\)指的是\\(\\left.u_\\mathrm{I}\\right|_{t=t_1}\\) 用途 延时 波形变换 \\[\\Delta q=\\Delta u\\cdot C=\\Delta t\\cdot i\\] 因此斜率可以轻易地求得。 移相 微分运算电路 分析1 以电流为中介，根据虚短和虚断，输出电压\\(u_\\mathrm{R}=u_\\mathrm{O}=i_\\mathrm{R}\\cdot R=i_\\mathrm{C}\\cdot R\\)与电流成比例， \\(i_\\mathrm{C}=C \\frac{\\mathrm{d} u_\\mathrm{I}}{\\mathrm{d} t}\\)，电流是输入电压的微分，因此输出电压是输入电压的微分。 分析2 根据虚断，流过\\(C\\)的电流就是流过\\(R\\)的电流： \\[i_{R}=i_{C}=C \\frac{d u_{I}}{\\mathrm{d} t}\\] 根据虚短，电容的右端虚地： \\[u_{0}=-i_{R} R=-R C \\frac{d u_{I}}{d t}\\] 问题 由于电容两端的电压不可突变，当输入电压产生一个脉冲时，变化的电压直接加在了运放的输入端，造成阻塞现象。 在输入端串联电阻。 在反馈电阻上并联两个极性相反的稳压二极管，限制输出电压，避免运放进入非线性区。 将输入置零电容接地，只看反馈网络，可以看出反馈网络为滞后网络，造成微分运算电路易产生自激振荡。 在反馈电阻上并联一个小电容作为密勒补偿。 此外，可以把积分电路放在负反馈回路里，使用逆运算来实现微分电路。 首先对极性进行分析，假定一个正的输入，运放要工作在线性区必须引入负反馈，由于是并联反馈，当输入增加时流入反馈回路的电流应当增大，因此上方的极性为负才能让电流流进去，推出输出极性也是正。最后根据推出的极性标定运放的同相输入端或反相输入端。 定性分析： 以电流为中介，根据虚断和虚地，\\(i_1=i_2=\\frac{u_\\mathrm{I}}{R_1}=\\frac{u_\\mathrm{O2}}{R_2}\\)，即\\(u_\\mathrm{I}\\propto u_\\mathrm{O2}\\)，而\\(u_\\mathrm{O}=u_\\mathrm{I2}\\)，因此不管反馈回路上是什么，只要输出电压通过\\(R_2\\)与输入电压成比例关系，就实现了逆运算。 定量分析： \\[\\begin{aligned} u_{\\mathrm{O} 2}\u0026=-\\frac{1}{R_{3} C} \\int u_{\\mathrm{o}} \\mathrm{d} t \\\\ \u0026=-\\frac{R_{2}}{R_{1}} u_{\\mathrm{I}} \\\\ u_{\\mathrm{O}}\u0026=\\frac{R_{2} R_{3} C}{R_{1}} \\cdot \\frac{\\mathrm{d} u_{\\mathrm{I}}}{\\mathrm{d} t} \\end{aligned}\\] 阻塞现象 运放由于某种原因进入非线性区而不能自动恢复的现象，集成运放内部某些晶体管进入饱和区或者截止区。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#积分-微分运算电路"},{"categories":null,"content":"积分/微分运算电路 积分运算电路 在实际电路中，为了防止输入为直流量导致电容可以看作短路，导致运放开环，常常在电容两端并联一个大电阻。 分析1 以\\(C\\)的电压为中介，根据虚短，\\(i_\\mathrm{C}=C\\cdot \\frac{\\mathrm{d}u_\\mathrm{C}}{\\mathrm{d}t}\\Rightarrow u_\\mathrm{O}=u_\\mathrm{C}=\\int \\frac{i_\\mathrm{C}}{C}\\mathrm{d}t\\)，电流是被积函数，再以电流为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{C}}=R\\)，电流与输入电压成比例，因此输出电压是积分。 分析2 根据虚断，有： \\[i_{C}=i_{R}=\\frac{u_{I}}{R}\\] 根据虚短，电容的左端虚地，因此电流可以看作从地流出来，电压要加上负号： \\[\\begin{aligned} u_{\\mathrm{o}}\u0026=-u_{\\mathrm{C}}=-\\frac{1}{C} \\int \\frac{u_{1}}{R} \\mathrm{~d} t\\\\ \u0026=-\\frac{1}{R C} \\int u_{1} d t\\\\ \u0026=-\\frac{1}{R C} \\int_{t_{1}}^{t_{2}} u_{1} d t+u_{\\mathrm{o}}\\left(t_{1}\\right)\\\\ \u0026=-\\frac{1}{R C} \\cdot u_{1}\\left(t_{2}-t_{1}\\right)+u_{0}\\left(t_{1}\\right) \\end{aligned}\\] 注意两个括号的含义不同，\\((t_2-t_1)\\)代表的是相乘，而\\((t_1)\\)指的是\\(\\left.u_\\mathrm{I}\\right|_{t=t_1}\\) 用途 延时 波形变换 \\[\\Delta q=\\Delta u\\cdot C=\\Delta t\\cdot i\\] 因此斜率可以轻易地求得。 移相 微分运算电路 分析1 以电流为中介，根据虚短和虚断，输出电压\\(u_\\mathrm{R}=u_\\mathrm{O}=i_\\mathrm{R}\\cdot R=i_\\mathrm{C}\\cdot R\\)与电流成比例， \\(i_\\mathrm{C}=C \\frac{\\mathrm{d} u_\\mathrm{I}}{\\mathrm{d} t}\\)，电流是输入电压的微分，因此输出电压是输入电压的微分。 分析2 根据虚断，流过\\(C\\)的电流就是流过\\(R\\)的电流： \\[i_{R}=i_{C}=C \\frac{d u_{I}}{\\mathrm{d} t}\\] 根据虚短，电容的右端虚地： \\[u_{0}=-i_{R} R=-R C \\frac{d u_{I}}{d t}\\] 问题 由于电容两端的电压不可突变，当输入电压产生一个脉冲时，变化的电压直接加在了运放的输入端，造成阻塞现象。 在输入端串联电阻。 在反馈电阻上并联两个极性相反的稳压二极管，限制输出电压，避免运放进入非线性区。 将输入置零电容接地，只看反馈网络，可以看出反馈网络为滞后网络，造成微分运算电路易产生自激振荡。 在反馈电阻上并联一个小电容作为密勒补偿。 此外，可以把积分电路放在负反馈回路里，使用逆运算来实现微分电路。 首先对极性进行分析，假定一个正的输入，运放要工作在线性区必须引入负反馈，由于是并联反馈，当输入增加时流入反馈回路的电流应当增大，因此上方的极性为负才能让电流流进去，推出输出极性也是正。最后根据推出的极性标定运放的同相输入端或反相输入端。 定性分析： 以电流为中介，根据虚断和虚地，\\(i_1=i_2=\\frac{u_\\mathrm{I}}{R_1}=\\frac{u_\\mathrm{O2}}{R_2}\\)，即\\(u_\\mathrm{I}\\propto u_\\mathrm{O2}\\)，而\\(u_\\mathrm{O}=u_\\mathrm{I2}\\)，因此不管反馈回路上是什么，只要输出电压通过\\(R_2\\)与输入电压成比例关系，就实现了逆运算。 定量分析： \\[\\begin{aligned} u_{\\mathrm{O} 2}\u0026=-\\frac{1}{R_{3} C} \\int u_{\\mathrm{o}} \\mathrm{d} t \\\\ \u0026=-\\frac{R_{2}}{R_{1}} u_{\\mathrm{I}} \\\\ u_{\\mathrm{O}}\u0026=\\frac{R_{2} R_{3} C}{R_{1}} \\cdot \\frac{\\mathrm{d} u_{\\mathrm{I}}}{\\mathrm{d} t} \\end{aligned}\\] 阻塞现象 运放由于某种原因进入非线性区而不能自动恢复的现象，集成运放内部某些晶体管进入饱和区或者截止区。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#积分运算电路"},{"categories":null,"content":"积分/微分运算电路 积分运算电路 在实际电路中，为了防止输入为直流量导致电容可以看作短路，导致运放开环，常常在电容两端并联一个大电阻。 分析1 以\\(C\\)的电压为中介，根据虚短，\\(i_\\mathrm{C}=C\\cdot \\frac{\\mathrm{d}u_\\mathrm{C}}{\\mathrm{d}t}\\Rightarrow u_\\mathrm{O}=u_\\mathrm{C}=\\int \\frac{i_\\mathrm{C}}{C}\\mathrm{d}t\\)，电流是被积函数，再以电流为中介，由于\\(\\frac{u_\\mathrm{I}}{i_\\mathrm{C}}=R\\)，电流与输入电压成比例，因此输出电压是积分。 分析2 根据虚断，有： \\[i_{C}=i_{R}=\\frac{u_{I}}{R}\\] 根据虚短，电容的左端虚地，因此电流可以看作从地流出来，电压要加上负号： \\[\\begin{aligned} u_{\\mathrm{o}}\u0026=-u_{\\mathrm{C}}=-\\frac{1}{C} \\int \\frac{u_{1}}{R} \\mathrm{~d} t\\\\ \u0026=-\\frac{1}{R C} \\int u_{1} d t\\\\ \u0026=-\\frac{1}{R C} \\int_{t_{1}}^{t_{2}} u_{1} d t+u_{\\mathrm{o}}\\left(t_{1}\\right)\\\\ \u0026=-\\frac{1}{R C} \\cdot u_{1}\\left(t_{2}-t_{1}\\right)+u_{0}\\left(t_{1}\\right) \\end{aligned}\\] 注意两个括号的含义不同，\\((t_2-t_1)\\)代表的是相乘，而\\((t_1)\\)指的是\\(\\left.u_\\mathrm{I}\\right|_{t=t_1}\\) 用途 延时 波形变换 \\[\\Delta q=\\Delta u\\cdot C=\\Delta t\\cdot i\\] 因此斜率可以轻易地求得。 移相 微分运算电路 分析1 以电流为中介，根据虚短和虚断，输出电压\\(u_\\mathrm{R}=u_\\mathrm{O}=i_\\mathrm{R}\\cdot R=i_\\mathrm{C}\\cdot R\\)与电流成比例， \\(i_\\mathrm{C}=C \\frac{\\mathrm{d} u_\\mathrm{I}}{\\mathrm{d} t}\\)，电流是输入电压的微分，因此输出电压是输入电压的微分。 分析2 根据虚断，流过\\(C\\)的电流就是流过\\(R\\)的电流： \\[i_{R}=i_{C}=C \\frac{d u_{I}}{\\mathrm{d} t}\\] 根据虚短，电容的右端虚地： \\[u_{0}=-i_{R} R=-R C \\frac{d u_{I}}{d t}\\] 问题 由于电容两端的电压不可突变，当输入电压产生一个脉冲时，变化的电压直接加在了运放的输入端，造成阻塞现象。 在输入端串联电阻。 在反馈电阻上并联两个极性相反的稳压二极管，限制输出电压，避免运放进入非线性区。 将输入置零电容接地，只看反馈网络，可以看出反馈网络为滞后网络，造成微分运算电路易产生自激振荡。 在反馈电阻上并联一个小电容作为密勒补偿。 此外，可以把积分电路放在负反馈回路里，使用逆运算来实现微分电路。 首先对极性进行分析，假定一个正的输入，运放要工作在线性区必须引入负反馈，由于是并联反馈，当输入增加时流入反馈回路的电流应当增大，因此上方的极性为负才能让电流流进去，推出输出极性也是正。最后根据推出的极性标定运放的同相输入端或反相输入端。 定性分析： 以电流为中介，根据虚断和虚地，\\(i_1=i_2=\\frac{u_\\mathrm{I}}{R_1}=\\frac{u_\\mathrm{O2}}{R_2}\\)，即\\(u_\\mathrm{I}\\propto u_\\mathrm{O2}\\)，而\\(u_\\mathrm{O}=u_\\mathrm{I2}\\)，因此不管反馈回路上是什么，只要输出电压通过\\(R_2\\)与输入电压成比例关系，就实现了逆运算。 定量分析： \\[\\begin{aligned} u_{\\mathrm{O} 2}\u0026=-\\frac{1}{R_{3} C} \\int u_{\\mathrm{o}} \\mathrm{d} t \\\\ \u0026=-\\frac{R_{2}}{R_{1}} u_{\\mathrm{I}} \\\\ u_{\\mathrm{O}}\u0026=\\frac{R_{2} R_{3} C}{R_{1}} \\cdot \\frac{\\mathrm{d} u_{\\mathrm{I}}}{\\mathrm{d} t} \\end{aligned}\\] 阻塞现象 运放由于某种原因进入非线性区而不能自动恢复的现象，集成运放内部某些晶体管进入饱和区或者截止区。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#微分运算电路"},{"categories":null,"content":"指数/对数运算电路 应用 用作乘法/除法运算电路 对数运算电路 利用PN电压与电流的关系（指数形式），使用和逆运算实现微分电路类似的思路，将三极管置于反馈回路中。 使用三极管而不用二极管的原因是，二极管输入电压的范围太小，而对于三极管， \\(u_\\mathrm{I}\\propto i_\\mathrm{C}\\propto i_\\mathrm{BE}\\xrightarrow{\\ln x}u_\\mathrm{BE}=u_\\mathrm{O}\\)，放大了输入电压的范围。 根据虚断，有： \\[\\begin{aligned} i_{\\mathrm{C}}\u0026=i_{\\mathrm{R}}=\\frac{u_{1}}{R} \\\\ \u0026\\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE}}}{U_{\\mathrm{T}}}} \\end{aligned}\\] 根据虚短，有： \\[u_{\\mathrm{o}}=-u_{\\mathrm{BE}} \\approx-U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{\\mathrm{s}} R}\\] 其中： \\(u_\\mathrm{I}\\) 极性：必须为正。 幅值：不能使流过三级管的电流超过\\(I_\\mathrm{CM}\\)或者使运放超过其功耗限制。 \\(I_\\mathrm{S}\\) 反向饱和电流，受温度影响大，在实用电路中要采取措施消除。 \\(U_\\mathrm{T}\\) 要减小其对运算电路的影响。 集成对数运算电路 \\[\\begin{aligned} i_{\\mathrm{C} 1}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{3}} \\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE}}}{U_{\\mathrm{T}}}} \\Rightarrow u_{\\mathrm{BE} 1} \\approx U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{\\mathrm{s}} R_{3}}\\\\ i_{R} \u0026\\stackrel{u_{\\mathrm{BE} 2}-u_{\\mathrm{BE} 1}\\approx 0}\\approx \\frac{U_{\\mathrm{REF}}}{R_{3}} \\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE} 2}}{U_{\\mathrm{T}}}} \\Rightarrow u_{\\mathrm{BE} 2} \\approx U_{\\mathrm{T}} \\ln \\frac{I_{R}}{I_{\\mathrm{s}}}\\\\ u_{\\mathrm{N} 2}\u0026=u_{\\mathrm{P} 2}=u_{\\mathrm{BE} 2}-u_{\\mathrm{BE} 1} \\approx-U_{\\mathrm{T}} \\ln \\frac{i_{I}}{I_{R}}=-U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{R} R_{3}}\\\\ u_{0}\u0026=\\left(1+\\frac{R_{2}}{R_{5}}\\right) u_{\\mathrm{N} 2} \\approx-\\left(1+\\frac{R_{2}}{R_{5}}\\right) U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{R} R_{3}} \\end{aligned}\\] 由于\\(U_{\\mathrm{T}}=k T / q\\)，\\(R_5\\)可以采用一个正温度系数的热敏电阻，以抵消温度影响。一个热敏电阻显然完全难以抵消\\(U_\\mathrm{T}\\)的变化，因此许多集成对数运算电路往往更复杂。 指数运算电路 \\(u_\\mathrm{BE}=u_\\mathrm{I}\\xrightarrow{e^x}i_\\mathrm{BE}\\propto i_\\mathrm{C}\\propto u_\\mathrm{O}\\) 根据虚短和虚断，有： \\[\\begin{aligned} u_{\\mathrm{I}}\u0026=u_{\\mathrm{BE}} \\\\ i_{R}\u0026=i_{\\mathrm{E}} \\approx I_{\\mathrm{s}} e^{\\frac{u_{\\mathrm{I}}}{U_{\\mathrm{T}}}} \\end{aligned}\\] 由于输入的电压就是\\(u_\\mathrm{BE}\\)，因此输入的电压必须为正且很有限，得到输出为： \\[u_{\\mathrm{o}}=-i_{R} R \\approx-I_{\\mathrm{s}} R e^{\\frac{u_{\\mathrm{I}}}{U_{\\mathrm{T}}}}\\] 常常采用逆运算的对数运算电路来实现指数运算的功能。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#指数-对数运算电路"},{"categories":null,"content":"指数/对数运算电路 应用 用作乘法/除法运算电路 对数运算电路 利用PN电压与电流的关系（指数形式），使用和逆运算实现微分电路类似的思路，将三极管置于反馈回路中。 使用三极管而不用二极管的原因是，二极管输入电压的范围太小，而对于三极管， \\(u_\\mathrm{I}\\propto i_\\mathrm{C}\\propto i_\\mathrm{BE}\\xrightarrow{\\ln x}u_\\mathrm{BE}=u_\\mathrm{O}\\)，放大了输入电压的范围。 根据虚断，有： \\[\\begin{aligned} i_{\\mathrm{C}}\u0026=i_{\\mathrm{R}}=\\frac{u_{1}}{R} \\\\ \u0026\\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE}}}{U_{\\mathrm{T}}}} \\end{aligned}\\] 根据虚短，有： \\[u_{\\mathrm{o}}=-u_{\\mathrm{BE}} \\approx-U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{\\mathrm{s}} R}\\] 其中： \\(u_\\mathrm{I}\\) 极性：必须为正。 幅值：不能使流过三级管的电流超过\\(I_\\mathrm{CM}\\)或者使运放超过其功耗限制。 \\(I_\\mathrm{S}\\) 反向饱和电流，受温度影响大，在实用电路中要采取措施消除。 \\(U_\\mathrm{T}\\) 要减小其对运算电路的影响。 集成对数运算电路 \\[\\begin{aligned} i_{\\mathrm{C} 1}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{3}} \\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE}}}{U_{\\mathrm{T}}}} \\Rightarrow u_{\\mathrm{BE} 1} \\approx U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{\\mathrm{s}} R_{3}}\\\\ i_{R} \u0026\\stackrel{u_{\\mathrm{BE} 2}-u_{\\mathrm{BE} 1}\\approx 0}\\approx \\frac{U_{\\mathrm{REF}}}{R_{3}} \\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE} 2}}{U_{\\mathrm{T}}}} \\Rightarrow u_{\\mathrm{BE} 2} \\approx U_{\\mathrm{T}} \\ln \\frac{I_{R}}{I_{\\mathrm{s}}}\\\\ u_{\\mathrm{N} 2}\u0026=u_{\\mathrm{P} 2}=u_{\\mathrm{BE} 2}-u_{\\mathrm{BE} 1} \\approx-U_{\\mathrm{T}} \\ln \\frac{i_{I}}{I_{R}}=-U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{R} R_{3}}\\\\ u_{0}\u0026=\\left(1+\\frac{R_{2}}{R_{5}}\\right) u_{\\mathrm{N} 2} \\approx-\\left(1+\\frac{R_{2}}{R_{5}}\\right) U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{R} R_{3}} \\end{aligned}\\] 由于\\(U_{\\mathrm{T}}=k T / q\\)，\\(R_5\\)可以采用一个正温度系数的热敏电阻，以抵消温度影响。一个热敏电阻显然完全难以抵消\\(U_\\mathrm{T}\\)的变化，因此许多集成对数运算电路往往更复杂。 指数运算电路 \\(u_\\mathrm{BE}=u_\\mathrm{I}\\xrightarrow{e^x}i_\\mathrm{BE}\\propto i_\\mathrm{C}\\propto u_\\mathrm{O}\\) 根据虚短和虚断，有： \\[\\begin{aligned} u_{\\mathrm{I}}\u0026=u_{\\mathrm{BE}} \\\\ i_{R}\u0026=i_{\\mathrm{E}} \\approx I_{\\mathrm{s}} e^{\\frac{u_{\\mathrm{I}}}{U_{\\mathrm{T}}}} \\end{aligned}\\] 由于输入的电压就是\\(u_\\mathrm{BE}\\)，因此输入的电压必须为正且很有限，得到输出为： \\[u_{\\mathrm{o}}=-i_{R} R \\approx-I_{\\mathrm{s}} R e^{\\frac{u_{\\mathrm{I}}}{U_{\\mathrm{T}}}}\\] 常常采用逆运算的对数运算电路来实现指数运算的功能。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#对数运算电路"},{"categories":null,"content":"指数/对数运算电路 应用 用作乘法/除法运算电路 对数运算电路 利用PN电压与电流的关系（指数形式），使用和逆运算实现微分电路类似的思路，将三极管置于反馈回路中。 使用三极管而不用二极管的原因是，二极管输入电压的范围太小，而对于三极管， \\(u_\\mathrm{I}\\propto i_\\mathrm{C}\\propto i_\\mathrm{BE}\\xrightarrow{\\ln x}u_\\mathrm{BE}=u_\\mathrm{O}\\)，放大了输入电压的范围。 根据虚断，有： \\[\\begin{aligned} i_{\\mathrm{C}}\u0026=i_{\\mathrm{R}}=\\frac{u_{1}}{R} \\\\ \u0026\\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE}}}{U_{\\mathrm{T}}}} \\end{aligned}\\] 根据虚短，有： \\[u_{\\mathrm{o}}=-u_{\\mathrm{BE}} \\approx-U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{\\mathrm{s}} R}\\] 其中： \\(u_\\mathrm{I}\\) 极性：必须为正。 幅值：不能使流过三级管的电流超过\\(I_\\mathrm{CM}\\)或者使运放超过其功耗限制。 \\(I_\\mathrm{S}\\) 反向饱和电流，受温度影响大，在实用电路中要采取措施消除。 \\(U_\\mathrm{T}\\) 要减小其对运算电路的影响。 集成对数运算电路 \\[\\begin{aligned} i_{\\mathrm{C} 1}\u0026=i_{\\mathrm{I}}=\\frac{u_{\\mathrm{I}}}{R_{3}} \\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE}}}{U_{\\mathrm{T}}}} \\Rightarrow u_{\\mathrm{BE} 1} \\approx U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{\\mathrm{s}} R_{3}}\\\\ i_{R} \u0026\\stackrel{u_{\\mathrm{BE} 2}-u_{\\mathrm{BE} 1}\\approx 0}\\approx \\frac{U_{\\mathrm{REF}}}{R_{3}} \\approx I_{\\mathrm{s}} \\mathrm{e}^{\\frac{u_{\\mathrm{BE} 2}}{U_{\\mathrm{T}}}} \\Rightarrow u_{\\mathrm{BE} 2} \\approx U_{\\mathrm{T}} \\ln \\frac{I_{R}}{I_{\\mathrm{s}}}\\\\ u_{\\mathrm{N} 2}\u0026=u_{\\mathrm{P} 2}=u_{\\mathrm{BE} 2}-u_{\\mathrm{BE} 1} \\approx-U_{\\mathrm{T}} \\ln \\frac{i_{I}}{I_{R}}=-U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{R} R_{3}}\\\\ u_{0}\u0026=\\left(1+\\frac{R_{2}}{R_{5}}\\right) u_{\\mathrm{N} 2} \\approx-\\left(1+\\frac{R_{2}}{R_{5}}\\right) U_{\\mathrm{T}} \\ln \\frac{u_{\\mathrm{I}}}{I_{R} R_{3}} \\end{aligned}\\] 由于\\(U_{\\mathrm{T}}=k T / q\\)，\\(R_5\\)可以采用一个正温度系数的热敏电阻，以抵消温度影响。一个热敏电阻显然完全难以抵消\\(U_\\mathrm{T}\\)的变化，因此许多集成对数运算电路往往更复杂。 指数运算电路 \\(u_\\mathrm{BE}=u_\\mathrm{I}\\xrightarrow{e^x}i_\\mathrm{BE}\\propto i_\\mathrm{C}\\propto u_\\mathrm{O}\\) 根据虚短和虚断，有： \\[\\begin{aligned} u_{\\mathrm{I}}\u0026=u_{\\mathrm{BE}} \\\\ i_{R}\u0026=i_{\\mathrm{E}} \\approx I_{\\mathrm{s}} e^{\\frac{u_{\\mathrm{I}}}{U_{\\mathrm{T}}}} \\end{aligned}\\] 由于输入的电压就是\\(u_\\mathrm{BE}\\)，因此输入的电压必须为正且很有限，得到输出为： \\[u_{\\mathrm{o}}=-i_{R} R \\approx-I_{\\mathrm{s}} R e^{\\frac{u_{\\mathrm{I}}}{U_{\\mathrm{T}}}}\\] 常常采用逆运算的对数运算电路来实现指数运算的功能。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#指数运算电路"},{"categories":null,"content":"模拟乘法器 \\[u_\\mathrm{O}=ku_\\mathrm{X}u_\\mathrm{Y}\\] \\(k\\)：通常为\\(\\pm0.1\\text{V}^{-1}\\) 等效电路为： 理想情况下，\\(r_\\mathrm{i1},r_\\mathrm{i2},f_\\mathrm{H}\\)为无穷大， 失调电压、电流及其温漂为\\(0\\)，\\(r_\\mathrm{o}\\)为\\(0\\)， \\(u_\\mathrm{X},u_\\mathrm{Y}\\)幅值和频率变化时\\(k\\)值不变。模拟乘法器有单象限、两象限和四象限之分： 应用 乘方运算电路/正弦波二倍频变换电路 \\[u_\\mathrm{O}=k^2u_\\mathrm{I}^2\\] 若输入信号为正弦波，即： \\[u_\\mathrm{I}=\\sqrt{2}U_\\mathrm{i}\\sin\\omega t\\] 则输出为： \\[u_\\mathrm{O}=2kU_\\mathrm{i}^2\\sin^2\\omega t=2kU_\\mathrm{i}^2(1-\\cos 2\\omega t)\\] 实现了对正弦波电压的二倍频变换。 除法运算电路 将模拟乘法器加入运放的负反馈回路中实现逆运算。 进行瞬时极性法分析可以得到，\\(u_\\mathrm{I1}\\)与\\(u_\\mathrm{I2}\\)的极性必须相同。分析电路，得到输出电压的表达式： \\[\\begin{aligned} i_{1}\u0026=i_{2}\\\\ \\frac{u_{1}}{R_{1}}\u0026=\\frac{-u_{0}^{\\prime}}{R_{2}}\\\\ \u0026\\Downarrow \\\\ u_{0}^{\\prime}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{\\mathrm{I} 1}=k u_{\\mathrm{I} 2} u_{o}\\\\ \u0026\\Downarrow \\\\ u_{\\mathrm{o}}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot \\frac{u_{\\mathrm{I1}}}{{ku}_{\\mathrm{I} 2}} \\end{aligned}\\] 开方运算电路 将乘方运算电路加入运放的负反馈回路中实现逆运算。 通常会串联一个二极管，防止输入极性错误导致运放产生正反馈。 \\[\\begin{aligned} u_{\\mathrm{o}}^{\\prime}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{\\mathrm{I}}=k u_{\\mathrm{o}}^{2} \\\\ u_{\\mathrm{o}}\u0026=\\sqrt{-\\frac{R_{2}}{k R_{1}} \\cdot u_{\\mathrm{I}}} \\end{aligned}\\] 其中： \\[u_{\\mathrm{o}}\u003e0, k\u003e0\\] 延伸 \\(u_{\\mathrm{i}}\u003c0,u_{\\mathrm{o}}\u003c0\\) \\[u_{\\mathrm{o}}=-\\sqrt{-\\frac{R_{2}}{k R_{1}} \\cdot u_{\\mathrm{I}}}\\] \\(u_{\\mathrm{i}}\u003e0,u_{\\mathrm{o}}\u003e0\\) \\[\\begin{aligned} \\dot{u}_{o}^{\\prime}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{I}=u_{o}^{2} \\quad(k\u003c0) \\\\ u_{o}\u0026=\\sqrt{-\\frac{R_{2}}{R_{1}} \\cdot u_{I}} \\end{aligned}\\] 变跨导型模拟乘法器 \\(u_\\mathrm{Y}\\)所在电路相当于电流源，控制差分放大电路的静态工作点，在忽略\\(r_\\mathrm{bb^\\prime}\\)的前提下，可以估算跨导： \\[\\begin{aligned} g_{\\mathrm{m}}\u0026\\approx \\frac{I_{\\mathrm{EQ}}}{U_{\\mathrm{T}}}=\\frac{I}{2 U_{\\mathrm{T}}}=\\frac{\\frac{u_{\\mathrm{Y}}-u_{\\mathrm{BE} 3}}{R_{\\mathrm{e}}}}{2U_\\mathrm{T}}\\stackrel{u_{\\mathrm{Y}}\\gg u_{\\mathrm{BE} 3}}\\approx=\\frac{u_{\\mathrm{Y}}}{2 U_{\\mathrm{T}} R_{\\mathrm{e}}}\\\\ u_{\\mathrm{o}}\u0026=-\\left(\\Delta i_{\\mathrm{C} 1}-\\Delta i_{\\mathrm{C} 2}\\right) R_{\\mathrm{c}} \\approx-g_{\\mathrm{m}} u_{\\mathrm{X}} R_{\\mathrm{c}} \\approx \\frac{R_{\\mathrm{c}}}{2 U_{\\mathrm{T}} R_{\\mathrm{e}}} \\cdot u_{\\mathrm{x}} u_{\\mathrm{Y}} \\end{aligned}\\] 实际电路需在多方面改进，如线性度、温度的影响、输入电压的极性等方面。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:6","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#模拟乘法器"},{"categories":null,"content":"模拟乘法器 \\[u_\\mathrm{O}=ku_\\mathrm{X}u_\\mathrm{Y}\\] \\(k\\)：通常为\\(\\pm0.1\\text{V}^{-1}\\) 等效电路为： 理想情况下，\\(r_\\mathrm{i1},r_\\mathrm{i2},f_\\mathrm{H}\\)为无穷大， 失调电压、电流及其温漂为\\(0\\)，\\(r_\\mathrm{o}\\)为\\(0\\)， \\(u_\\mathrm{X},u_\\mathrm{Y}\\)幅值和频率变化时\\(k\\)值不变。模拟乘法器有单象限、两象限和四象限之分： 应用 乘方运算电路/正弦波二倍频变换电路 \\[u_\\mathrm{O}=k^2u_\\mathrm{I}^2\\] 若输入信号为正弦波，即： \\[u_\\mathrm{I}=\\sqrt{2}U_\\mathrm{i}\\sin\\omega t\\] 则输出为： \\[u_\\mathrm{O}=2kU_\\mathrm{i}^2\\sin^2\\omega t=2kU_\\mathrm{i}^2(1-\\cos 2\\omega t)\\] 实现了对正弦波电压的二倍频变换。 除法运算电路 将模拟乘法器加入运放的负反馈回路中实现逆运算。 进行瞬时极性法分析可以得到，\\(u_\\mathrm{I1}\\)与\\(u_\\mathrm{I2}\\)的极性必须相同。分析电路，得到输出电压的表达式： \\[\\begin{aligned} i_{1}\u0026=i_{2}\\\\ \\frac{u_{1}}{R_{1}}\u0026=\\frac{-u_{0}^{\\prime}}{R_{2}}\\\\ \u0026\\Downarrow \\\\ u_{0}^{\\prime}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{\\mathrm{I} 1}=k u_{\\mathrm{I} 2} u_{o}\\\\ \u0026\\Downarrow \\\\ u_{\\mathrm{o}}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot \\frac{u_{\\mathrm{I1}}}{{ku}_{\\mathrm{I} 2}} \\end{aligned}\\] 开方运算电路 将乘方运算电路加入运放的负反馈回路中实现逆运算。 通常会串联一个二极管，防止输入极性错误导致运放产生正反馈。 \\[\\begin{aligned} u_{\\mathrm{o}}^{\\prime}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{\\mathrm{I}}=k u_{\\mathrm{o}}^{2} \\\\ u_{\\mathrm{o}}\u0026=\\sqrt{-\\frac{R_{2}}{k R_{1}} \\cdot u_{\\mathrm{I}}} \\end{aligned}\\] 其中： \\[u_{\\mathrm{o}}\u003e0, k\u003e0\\] 延伸 \\(u_{\\mathrm{i}}\u003c0,u_{\\mathrm{o}}\u003c0\\) \\[u_{\\mathrm{o}}=-\\sqrt{-\\frac{R_{2}}{k R_{1}} \\cdot u_{\\mathrm{I}}}\\] \\(u_{\\mathrm{i}}\u003e0,u_{\\mathrm{o}}\u003e0\\) \\[\\begin{aligned} \\dot{u}_{o}^{\\prime}\u0026=-\\frac{R_{2}}{R_{1}} \\cdot u_{I}=u_{o}^{2} \\quad(k\u003c0) \\\\ u_{o}\u0026=\\sqrt{-\\frac{R_{2}}{R_{1}} \\cdot u_{I}} \\end{aligned}\\] 变跨导型模拟乘法器 \\(u_\\mathrm{Y}\\)所在电路相当于电流源，控制差分放大电路的静态工作点，在忽略\\(r_\\mathrm{bb^\\prime}\\)的前提下，可以估算跨导： \\[\\begin{aligned} g_{\\mathrm{m}}\u0026\\approx \\frac{I_{\\mathrm{EQ}}}{U_{\\mathrm{T}}}=\\frac{I}{2 U_{\\mathrm{T}}}=\\frac{\\frac{u_{\\mathrm{Y}}-u_{\\mathrm{BE} 3}}{R_{\\mathrm{e}}}}{2U_\\mathrm{T}}\\stackrel{u_{\\mathrm{Y}}\\gg u_{\\mathrm{BE} 3}}\\approx=\\frac{u_{\\mathrm{Y}}}{2 U_{\\mathrm{T}} R_{\\mathrm{e}}}\\\\ u_{\\mathrm{o}}\u0026=-\\left(\\Delta i_{\\mathrm{C} 1}-\\Delta i_{\\mathrm{C} 2}\\right) R_{\\mathrm{c}} \\approx-g_{\\mathrm{m}} u_{\\mathrm{X}} R_{\\mathrm{c}} \\approx \\frac{R_{\\mathrm{c}}}{2 U_{\\mathrm{T}} R_{\\mathrm{e}}} \\cdot u_{\\mathrm{x}} u_{\\mathrm{Y}} \\end{aligned}\\] 实际电路需在多方面改进，如线性度、温度的影响、输入电压的极性等方面。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:3:6","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#变跨导型模拟乘法器"},{"categories":null,"content":"滤波电路 多级滤波电路衰减相乘，在波特图里体现为斜率相加。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#滤波电路"},{"categories":null,"content":"低通滤波器 简称 LPF（Low Pass Filter）。 \\(\\left|\\dot A_{u\\mathrm{p}}\\right|\\)：通带放大倍数 \\(f_\\mathrm{p}\\)：通带截止频率 理想情况下无过渡带： 应用场景 交流转直流 电容滤波电路 \\(\\left|u_2\\right|\u003eu_C\\) 有一对二极管导通，对电容充电，充电的时间常数非常小。 \\(\\left|u_2\\right|\u003cu_C\\) 所有二极管均截止，电容通过\\(R_\\mathrm{L}\\)放电，放电的时间常数\\(\\tau=R_\\mathrm{L}C\\)，一般远远大于充电的时间常数。电容电压的波形图如下： 考虑二极管和变压器的内阻时，波形图如下： 经过电容滤波电路滤波后，二极管的导通角\\(\\theta\\)变小，导致峰值电流升高，平均电流增大，因此该电路不适合大电流负载： 当\\(R_\\mathrm{L}C=(3\\sim 5)\\frac{T}{2}\\)时，\\(U_\\mathrm{O(AV)}=1.2U_2\\)，电容的耐压值应大于\\(1.1\\sqrt{2}U_2\\)。 缺点 不适于大电流负载。 滤波电容为电解电容，数值比较大。当电解电容的容量大到一定数值，就不是纯电容了。 复式滤波电路 类型 \\(U_\\mathrm{L(AV)}/U_2\\) \\(\\theta\\) 适用场合 电容滤波电路 1.2 小 小电流负载 电感滤波电路 0.9 大 大电流负载 LC滤波电路 0.9 大 适应性较强 LC\\(\\pi\\)型滤波电路或RC\\(\\pi\\)型滤波电路 1.2 小 小电流负载 LC滤波电路 LC\\(\\pi\\)型滤波电路 RC\\(\\pi\\)型滤波电路 电感滤波电路 当回路电流减小时，感生电动势的方向阻止电流的减小，从而增大二极管的导通角： 这里的电感加了一条横杠，说明是带磁芯的大电感，可以估算输出的直流分量和交流分量： \\[\\begin{aligned} U_{\\mathrm{O}(\\mathrm{AV})}\u0026=\\frac{R_{\\mathrm{L}}}{R+R_{\\mathrm{L}}} \\cdot U_{\\mathrm{D}(\\mathrm{AV})} \\approx \\frac{R_{\\mathrm{L}}}{R+R_{\\mathrm{L}}} \\times \\mathbf{0 . 9} U_{2} \\\\ u_{\\mathrm{O}(\\mathrm{AC})}\u0026=\\frac{R_{\\mathrm{L}}}{\\sqrt{R_{\\mathrm{L}}^{2}+(\\omega L)^{2}}} \\cdot u_{\\mathrm{d}} \\approx \\frac{R_{\\mathrm{L}}}{\\omega L} \\cdot u_{\\mathrm{d}} \\end{aligned}\\] 一阶低通滤波电路 同相输入一阶低通滤波电器 \\(\\dot{A}_{u p}=1+\\frac{R_{2}}{R_{1}}\\) 频率趋于0时的放大倍数为通带放大倍数。 \\(f_{p}=\\frac{1}{2 \\pi R C}\\) 通带截止频率决定于\\(RC\\)。 \\(\\dot{A}_{u}=\\frac{\\dot{A}_{u p}}{1+j \\frac{f}{f_{p}}}\\) 适用于\\(f\\in(0,\\infty)\\)的电压放大倍数表达式，表明进入高频段的下降速率为\\(-20\\text{dB}\\)/十倍频经过拉普拉斯变换得到传递函数： \\[A_{u}(s)=\\frac{U_{0}(s)}{U_{i}(s)}=\\left(1+\\frac{R_{f}}{R_{1}}\\right) \\frac{1 / s C}{R+1 / s C}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\cdot \\frac{1}{1+s R C}\\] 求解传递函数时，只需将放大倍数中的\\(j\\omega\\)用\\(s\\)取代即可；\\(s\\)的方次称为阶数。得到幅频特性曲线： 为了使过渡带变窄，需采用多阶滤波器，即像多级放大电路那样，增加RC环节。 反相输入低通滤波器 加入\\(R_2\\)前，电压放大倍数表达式为： \\[\\dot{A}_{u} =-\\frac{1}{j \\omega R_{1} C}\\] 即\\(f\\to 0\\Rightarrow \\left|\\dot A_u\\to\\infty\\right|\\)，没有通带，因此还不能够称为一个滤波电路。 加入\\(R_2\\)后： \\[\\begin{aligned} f_{\\mathrm{P}}\u0026=f_{\\mathrm{H}}=\\frac{1}{2 \\pi R_{2} C} \\\\ \\dot{A}_{u} \u0026=-\\frac{R_{2}}{R_{1}}=-\\frac{1}{R_{1}} \\cdot \\frac{R_{2} \\cdot(1 / j \\omega C)}{R_{2}+(1 / j \\omega C)} \\\\ \u0026=-\\frac{R_{2}}{R_{1}} \\cdot \\frac{1}{1+j \\frac{f}{f_\\mathrm{p}}} \\end{aligned}\\] 得到折线化的幅频特性曲线由原来的直线（黑）变为了折线（红）： 二阶低通滤波电路 简单二阶低通滤波器 其中，\\(C_1=C_2\\)。 通过阻抗列写电压两个结点电压的表达式： \\[\\begin{aligned} \\dot{U}_{\\mathrm{M}}\u0026=\\frac{\\frac{1}{j \\omega C_{1}} / /\\left(R+\\frac{1}{j \\omega C_{2}}\\right)}{R+\\left[\\frac{1}{\\mathrm{j} \\omega C_{1}} / /\\left(R+\\frac{1}{j \\omega C_{1}}\\right)\\right]} \\cdot \\dot{U}_{\\mathrm{i}}\\\\ \\dot{U}_{\\mathrm{P}}\u0026=\\frac{\\left(\\frac{1}{\\mathrm{j} \\omega C_{2}}\\right)}{R+\\frac{1}{j \\omega C_{2}}} \\cdot \\dot{U}_{\\mathrm{M}}\\\\ \\end{aligned}\\] 得到电压放大倍数、特征频率、截止频率： \\[\\begin{aligned} \\dot{A}_{u}\u0026=\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\frac{1}{1-\\left(\\frac{f}{f_{0}}\\right)^{2}+3 j \\frac{f}{f_{0}}} \\\\ f_{0}\u0026=\\frac{1}{2 \\pi R C}\\\\ f_{\\mathrm{p}} \u0026\\approx 0.37 f_{0} \\end{aligned}\\] 这里的截止频率并不等于特征频率，在特征频率下，信号已经衰减超过\\(3\\text{dB}\\)： 压控电压源二阶低通滤波器 为使 \\(f_P=f_0\\)，且在\\(f=f0\\)时幅频特性按\\(-40\\text{dB}\\)/十倍频下降。 电路引入了正反馈，下面分析在极限情况下是否会使电路产生自激振荡： \\(f\\to0\\) \\(C_1\\)趋于断路，正反馈近似断开，放大倍数为通带放大倍数。 \\(f\\to\\infty\\) \\(C_2\\)趋于短路，使得\\(u_\\mathrm{P}\\to 0\\)，导致正反馈不起作用，此时放大倍数也趋于0。两个电容在极限情况下分别抑制正反馈，那么在两个极限情况之间有可能在\\(f=f_0\\)时放大倍数等于或大于通带放大倍数，对于不同频率的信号正反馈的强弱不同。列写P、M的节点电流方程，整理可得： \\[\\begin{aligned} \\dot{A}_{u}\u0026=\\frac{\\dot{A}_{u p}}{1-\\left(\\frac{f}{f_{0}}\\right)^{2}+j\\left[3-\\dot{A}_{u p}\\right] \\frac{f}{f_{0}}} \\\\ \u0026\\Downarrow \\\\ \\left|\\dot{A}_{u}\\right|_{f=f_{0}}\u0026=\\left|\\frac{\\dot{A}_{u p}}{3-\\dot{A}_{u p}}\\right|=Q\\left|\\dot{A}_{u p}\\right| \\\\ \u0026\\Downarrow \\\\ Q\u0026=\\left|\\dot{A}_{u}\\right|_{f=f_{0}} /\\left|\\dot{A}_{u p}\\right| \\end{aligned}\\] 当\\(2 \\leq\\left|\\dot{A}_{u p}\\right|\u003c3\\)时，\\(\\left|\\dot{A}_{u}\\right|_{f=f_{0}} \\geq\\left|\\dot{A}_{u p}\\right|\\)。 \\(\\left|\\dot{A}_{u p}\\right|\\)可以确定\\(Q\\)的值，下面是\\(Q\\)在不同取值时，得到的幅频特性曲线： 在\\(Q=1\\)时，即\\(\\left|\\dot{A}_{u}\\right|_{f=f_{0}}=\\left|\\dot{A}_{u p}\\right|\\)，就可以达到比较令人满意的效果。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#低通滤波器"},{"categories":null,"content":"低通滤波器 简称 LPF（Low Pass Filter）。 \\(\\left|\\dot A_{u\\mathrm{p}}\\right|\\)：通带放大倍数 \\(f_\\mathrm{p}\\)：通带截止频率 理想情况下无过渡带： 应用场景 交流转直流 电容滤波电路 \\(\\left|u_2\\right|\u003eu_C\\) 有一对二极管导通，对电容充电，充电的时间常数非常小。 \\(\\left|u_2\\right|","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#电容滤波电路"},{"categories":null,"content":"低通滤波器 简称 LPF（Low Pass Filter）。 \\(\\left|\\dot A_{u\\mathrm{p}}\\right|\\)：通带放大倍数 \\(f_\\mathrm{p}\\)：通带截止频率 理想情况下无过渡带： 应用场景 交流转直流 电容滤波电路 \\(\\left|u_2\\right|\u003eu_C\\) 有一对二极管导通，对电容充电，充电的时间常数非常小。 \\(\\left|u_2\\right|","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#复式滤波电路"},{"categories":null,"content":"低通滤波器 简称 LPF（Low Pass Filter）。 \\(\\left|\\dot A_{u\\mathrm{p}}\\right|\\)：通带放大倍数 \\(f_\\mathrm{p}\\)：通带截止频率 理想情况下无过渡带： 应用场景 交流转直流 电容滤波电路 \\(\\left|u_2\\right|\u003eu_C\\) 有一对二极管导通，对电容充电，充电的时间常数非常小。 \\(\\left|u_2\\right|","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#电感滤波电路"},{"categories":null,"content":"低通滤波器 简称 LPF（Low Pass Filter）。 \\(\\left|\\dot A_{u\\mathrm{p}}\\right|\\)：通带放大倍数 \\(f_\\mathrm{p}\\)：通带截止频率 理想情况下无过渡带： 应用场景 交流转直流 电容滤波电路 \\(\\left|u_2\\right|\u003eu_C\\) 有一对二极管导通，对电容充电，充电的时间常数非常小。 \\(\\left|u_2\\right|","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#一阶低通滤波电路"},{"categories":null,"content":"低通滤波器 简称 LPF（Low Pass Filter）。 \\(\\left|\\dot A_{u\\mathrm{p}}\\right|\\)：通带放大倍数 \\(f_\\mathrm{p}\\)：通带截止频率 理想情况下无过渡带： 应用场景 交流转直流 电容滤波电路 \\(\\left|u_2\\right|\u003eu_C\\) 有一对二极管导通，对电容充电，充电的时间常数非常小。 \\(\\left|u_2\\right|","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#二阶低通滤波电路"},{"categories":null,"content":"高通滤波器 简称 HPF（High Pass Filter）。 应用场景 阻容耦合 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#高通滤波器"},{"categories":null,"content":"带通滤波器 简称 BPF（Band Pass Filter）。 可以使用一个低通滤波器和一个高通滤波器串联得到，其中低通滤波器的上限截止频率要高于高通滤波器的下限截止频率： ` 应用场景 调频收音机 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#带通滤波器"},{"categories":null,"content":"带阻滤波器 简称 BEF（Band Elimination Filter）。 可以使用一个低通滤波器和一个高通滤波器并联再通过求和电路得到，其中低通滤波器的下限截止频率要高于高通滤波器的上限截止频率： 应用场景 抗已知频率的干扰 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#带阻滤波器"},{"categories":null,"content":"全通滤波器 简称 APF（All Pass Filter）。 应用场景 频率到相位的转换 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#全通滤波器"},{"categories":null,"content":"无源滤波电路 可用于高电压大电流，但滤波参数随负载变化。以无源低通滤波器为例： 定性分析： \\[\\left\\{\\begin{array}{l} f \\rightarrow 0, \\dot{U}_{0} \\rightarrow \\frac{R_{\\mathrm{L}}}{R+R_{\\mathrm{L}}} \\cdot \\dot{U}_{\\mathrm{i}} \\\\ f \\rightarrow \\infty, \\dot{U}_{0} \\rightarrow 0 \\end{array}\\right.\\] 定量计算： \\[\\begin{aligned} \\dot{A}_{u \\mathrm{p}}=\\frac{R_{\\mathrm{L}}}{R+R_{\\mathrm{L}}} \\\\ f_{\\mathrm{p}}=\\frac{1}{2 \\pi\\left(R / /{R}_{\\mathrm{L}}\\right) C} \\\\ \\dot{A}_{u}=\\frac{\\dot{A}_{u \\mathrm{p}}}{1+j \\frac{f}{f_{\\mathrm{p}}}} \\end{aligned}\\] 可见负载变化，通带放大倍数和截止频率均变化： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:6","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#无源滤波电路"},{"categories":null,"content":"有源滤波电路 属于信号处理电路，其输出电压和电流的大小受有源元件自身参数和供电电源的限制，但滤波参数不随负载变化，并且可以带有放大功能。同时可以使用类似运算电路实现逆运算的思路，来实现滤波器，如使用低通滤波器来构建一个高通滤波器。 例 双T网络 极限频率下： \\[\\left|\\dot A_u\\right|=\\begin{cases} 1 ,\u0026f\\to0 \\\\ 1 ,\u0026f\\to \\infty \\\\ \\end{cases}\\] 因此在两个极限频率之间，就存在一个频率\\(f_0=\\frac{1}{2\\pi RC}\\)使得信号无法通过，属于带阻滤波器。 高通滤波器+反相求和=低通滤波器 极限频率下： \\[\\left|\\dot A_u\\right|=\\begin{cases} 1 ,\u0026f\\to0 \\\\ 0 ,\u0026f\\to \\infty \\\\ \\end{cases}\\] 因此为低通滤波器。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:4:7","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#有源滤波电路"},{"categories":null,"content":"振荡电路 在振荡电路中引入的是正反馈，且振荡频率可控： 组成 放大电路 正反馈网络 选频网络 非线性环节（稳幅环节） 正反馈网络和选频网络常常合二为一。 分类 常用选频网络所用元件分类 RC正弦波振荡电路：\\(\\leq 1\\text{MHz}\\) LC正弦波振荡电路：\\(100\\text{kHz}\\sim 1000\\text{MHz}\\) 石英晶体正弦波振荡电路：频率稳定 条件：起振和维持就要满足自激振荡的条件。 过程 要达到稳定的振幅就必须要有非线性环节。 判断 电路存在4个组成部分 放大电路是否能正常工作 是否满足相位条件 也就是是否为正反馈。反馈和输出应当不具有相位差，否则就不会形成正反馈，而是相位不停旋转。使用瞬时极性法分析相位条件时与分析运放有区别，运放要通过反馈回路确定输出，而这类简单的放大电路则不需要。应该断开反馈，在断开处给放大电路加 \\(f=f_0\\)的信号\\(U_\\mathrm{i}\\)，且规定其极性，然后根据\\(U_\\mathrm{i}\\to U_\\mathrm{o}\\to U_\\mathrm{f}\\)的顺序来分析极性，分析时需要注意\\(V_\\mathrm{CC}\\)与地是相连的，因此它们的极性也是相同的。若\\(U_\\mathrm{f}\\)与\\(U_\\mathrm{i}\\)极性相同，则电路可能产生自激振荡，否则电路不可能产生自激振荡。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#振荡电路"},{"categories":null,"content":"RC正弦波振荡电路 当振荡频率过高时，晶体管内部的结电容可能会对振荡产生影响。 RC串并联选频网络 相当于一个电路里存在一个高通电路和一个低通电路，这两个电路通频带的交集，就是待选频率。 分析使用两种极限情况进行分析： \\(f\\to 0\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] \\(f\\to\\infty\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] 因此两个极限频率之间应该应存在一个频率使得信号通过，写出反馈系数的表达式： \\[\\begin{aligned} \\dot{F}\u0026=\\frac{\\dot{U}_{\\mathrm{f}}}{\\dot{U}_{0}}=\\frac{R / / \\frac{1}{j \\omega C}}{R+\\frac{1}{j \\omega C}+R / / \\frac{1}{j \\omega C}}\\\\ \u0026=\\frac{1}{3+j\\left(\\omega R C-\\frac{1}{\\omega R C}\\right)}\\\\ \u0026=\\frac{1}{3+j\\left(\\frac{f}{f_{0}}-\\frac{f_{0}}{f}\\right)} \\end{aligned}\\] 其中： \\(f_{0}=\\frac{1}{2 \\pi R C}\\) 同时为低通电路的上限截止频率和高通电路的下限截止频率。 也就是\\(\\left|\\dot F\\right|_{\\max}=\\left|\\dot F\\right|_{f=f_0, \\varphi=0}=\\frac{1}{3}\\) 幅频特性曲线和相频特性曲线为： 放大电路 应使用电压放大倍数略大于3、输入电阻趋于无穷大、输出电阻趋于0的放大电路。 共射放大电路 共射放大电路的输出为一端接地，另一端反相的，不满足相位条件。 共集放大电路 没有电压放大的能力，而RC串并联选频网络要求的反馈系数必须大于3，不符合幅值条件。 共基放大电路 输入电阻小，输出电阻大，不方便计算且容易将温度特性带入反馈网络中。 两级共射放大电路 可以引入电压串联负反馈减小放大倍数，增大输入电阻并减小输出电阻。 同相比例运算电路 RC移相式电路 由于共射放大电路的输出是反相的，因此输出没有相移时，不可能产生正反馈。一个电容最多可以产生\\(90^\\circ\\)的相移，使用3个电容就最多能产生\\(270^\\circ\\)的相移，就有可能存在一个频率，使相移为\\(-180^\\circ\\)，共射放大电路产生正反馈。电路的反馈回路中，电阻和电容的位置可以互换，无非就是最大相移是正负的区别。 RC双T选频网络 选频网络和正反馈网络是两个网络： 文氏桥振荡器 以RC串并联选频网络为选频网络和正反馈网络、并引入电压串联负反馈，两个网络构成桥路，一对顶点作为输出电压，一对顶点作为放大电路的净输入电压，就构成文氏桥振荡器： \\(R_\\mathrm{f}\u003e2R_1\\) 可以变换成桥： 同相比例运算电路有非常好的线性度，而反馈回路也是线性，缺少非线性环节，因此可以用热敏电阻或二极管作为非线性环节： 频率调节 调节频率的过程中，需要保证RC串并联选频网络中的两个电阻与电容都为相同的值。使用双刀单掷的开关作为电容选择来粗调频率，同轴电位器作为电阻选择来微调频率： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#rc正弦波振荡电路"},{"categories":null,"content":"RC正弦波振荡电路 当振荡频率过高时，晶体管内部的结电容可能会对振荡产生影响。 RC串并联选频网络 相当于一个电路里存在一个高通电路和一个低通电路，这两个电路通频带的交集，就是待选频率。 分析使用两种极限情况进行分析： \\(f\\to 0\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] \\(f\\to\\infty\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] 因此两个极限频率之间应该应存在一个频率使得信号通过，写出反馈系数的表达式： \\[\\begin{aligned} \\dot{F}\u0026=\\frac{\\dot{U}_{\\mathrm{f}}}{\\dot{U}_{0}}=\\frac{R / / \\frac{1}{j \\omega C}}{R+\\frac{1}{j \\omega C}+R / / \\frac{1}{j \\omega C}}\\\\ \u0026=\\frac{1}{3+j\\left(\\omega R C-\\frac{1}{\\omega R C}\\right)}\\\\ \u0026=\\frac{1}{3+j\\left(\\frac{f}{f_{0}}-\\frac{f_{0}}{f}\\right)} \\end{aligned}\\] 其中： \\(f_{0}=\\frac{1}{2 \\pi R C}\\) 同时为低通电路的上限截止频率和高通电路的下限截止频率。 也就是\\(\\left|\\dot F\\right|_{\\max}=\\left|\\dot F\\right|_{f=f_0, \\varphi=0}=\\frac{1}{3}\\) 幅频特性曲线和相频特性曲线为： 放大电路 应使用电压放大倍数略大于3、输入电阻趋于无穷大、输出电阻趋于0的放大电路。 共射放大电路 共射放大电路的输出为一端接地，另一端反相的，不满足相位条件。 共集放大电路 没有电压放大的能力，而RC串并联选频网络要求的反馈系数必须大于3，不符合幅值条件。 共基放大电路 输入电阻小，输出电阻大，不方便计算且容易将温度特性带入反馈网络中。 两级共射放大电路 可以引入电压串联负反馈减小放大倍数，增大输入电阻并减小输出电阻。 同相比例运算电路 RC移相式电路 由于共射放大电路的输出是反相的，因此输出没有相移时，不可能产生正反馈。一个电容最多可以产生\\(90^\\circ\\)的相移，使用3个电容就最多能产生\\(270^\\circ\\)的相移，就有可能存在一个频率，使相移为\\(-180^\\circ\\)，共射放大电路产生正反馈。电路的反馈回路中，电阻和电容的位置可以互换，无非就是最大相移是正负的区别。 RC双T选频网络 选频网络和正反馈网络是两个网络： 文氏桥振荡器 以RC串并联选频网络为选频网络和正反馈网络、并引入电压串联负反馈，两个网络构成桥路，一对顶点作为输出电压，一对顶点作为放大电路的净输入电压，就构成文氏桥振荡器： \\(R_\\mathrm{f}\u003e2R_1\\) 可以变换成桥： 同相比例运算电路有非常好的线性度，而反馈回路也是线性，缺少非线性环节，因此可以用热敏电阻或二极管作为非线性环节： 频率调节 调节频率的过程中，需要保证RC串并联选频网络中的两个电阻与电容都为相同的值。使用双刀单掷的开关作为电容选择来粗调频率，同轴电位器作为电阻选择来微调频率： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#rc串并联选频网络"},{"categories":null,"content":"RC正弦波振荡电路 当振荡频率过高时，晶体管内部的结电容可能会对振荡产生影响。 RC串并联选频网络 相当于一个电路里存在一个高通电路和一个低通电路，这两个电路通频带的交集，就是待选频率。 分析使用两种极限情况进行分析： \\(f\\to 0\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] \\(f\\to\\infty\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] 因此两个极限频率之间应该应存在一个频率使得信号通过，写出反馈系数的表达式： \\[\\begin{aligned} \\dot{F}\u0026=\\frac{\\dot{U}_{\\mathrm{f}}}{\\dot{U}_{0}}=\\frac{R / / \\frac{1}{j \\omega C}}{R+\\frac{1}{j \\omega C}+R / / \\frac{1}{j \\omega C}}\\\\ \u0026=\\frac{1}{3+j\\left(\\omega R C-\\frac{1}{\\omega R C}\\right)}\\\\ \u0026=\\frac{1}{3+j\\left(\\frac{f}{f_{0}}-\\frac{f_{0}}{f}\\right)} \\end{aligned}\\] 其中： \\(f_{0}=\\frac{1}{2 \\pi R C}\\) 同时为低通电路的上限截止频率和高通电路的下限截止频率。 也就是\\(\\left|\\dot F\\right|_{\\max}=\\left|\\dot F\\right|_{f=f_0, \\varphi=0}=\\frac{1}{3}\\) 幅频特性曲线和相频特性曲线为： 放大电路 应使用电压放大倍数略大于3、输入电阻趋于无穷大、输出电阻趋于0的放大电路。 共射放大电路 共射放大电路的输出为一端接地，另一端反相的，不满足相位条件。 共集放大电路 没有电压放大的能力，而RC串并联选频网络要求的反馈系数必须大于3，不符合幅值条件。 共基放大电路 输入电阻小，输出电阻大，不方便计算且容易将温度特性带入反馈网络中。 两级共射放大电路 可以引入电压串联负反馈减小放大倍数，增大输入电阻并减小输出电阻。 同相比例运算电路 RC移相式电路 由于共射放大电路的输出是反相的，因此输出没有相移时，不可能产生正反馈。一个电容最多可以产生\\(90^\\circ\\)的相移，使用3个电容就最多能产生\\(270^\\circ\\)的相移，就有可能存在一个频率，使相移为\\(-180^\\circ\\)，共射放大电路产生正反馈。电路的反馈回路中，电阻和电容的位置可以互换，无非就是最大相移是正负的区别。 RC双T选频网络 选频网络和正反馈网络是两个网络： 文氏桥振荡器 以RC串并联选频网络为选频网络和正反馈网络、并引入电压串联负反馈，两个网络构成桥路，一对顶点作为输出电压，一对顶点作为放大电路的净输入电压，就构成文氏桥振荡器： \\(R_\\mathrm{f}\u003e2R_1\\) 可以变换成桥： 同相比例运算电路有非常好的线性度，而反馈回路也是线性，缺少非线性环节，因此可以用热敏电阻或二极管作为非线性环节： 频率调节 调节频率的过程中，需要保证RC串并联选频网络中的两个电阻与电容都为相同的值。使用双刀单掷的开关作为电容选择来粗调频率，同轴电位器作为电阻选择来微调频率： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#rc移相式电路"},{"categories":null,"content":"RC正弦波振荡电路 当振荡频率过高时，晶体管内部的结电容可能会对振荡产生影响。 RC串并联选频网络 相当于一个电路里存在一个高通电路和一个低通电路，这两个电路通频带的交集，就是待选频率。 分析使用两种极限情况进行分析： \\(f\\to 0\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] \\(f\\to\\infty\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] 因此两个极限频率之间应该应存在一个频率使得信号通过，写出反馈系数的表达式： \\[\\begin{aligned} \\dot{F}\u0026=\\frac{\\dot{U}_{\\mathrm{f}}}{\\dot{U}_{0}}=\\frac{R / / \\frac{1}{j \\omega C}}{R+\\frac{1}{j \\omega C}+R / / \\frac{1}{j \\omega C}}\\\\ \u0026=\\frac{1}{3+j\\left(\\omega R C-\\frac{1}{\\omega R C}\\right)}\\\\ \u0026=\\frac{1}{3+j\\left(\\frac{f}{f_{0}}-\\frac{f_{0}}{f}\\right)} \\end{aligned}\\] 其中： \\(f_{0}=\\frac{1}{2 \\pi R C}\\) 同时为低通电路的上限截止频率和高通电路的下限截止频率。 也就是\\(\\left|\\dot F\\right|_{\\max}=\\left|\\dot F\\right|_{f=f_0, \\varphi=0}=\\frac{1}{3}\\) 幅频特性曲线和相频特性曲线为： 放大电路 应使用电压放大倍数略大于3、输入电阻趋于无穷大、输出电阻趋于0的放大电路。 共射放大电路 共射放大电路的输出为一端接地，另一端反相的，不满足相位条件。 共集放大电路 没有电压放大的能力，而RC串并联选频网络要求的反馈系数必须大于3，不符合幅值条件。 共基放大电路 输入电阻小，输出电阻大，不方便计算且容易将温度特性带入反馈网络中。 两级共射放大电路 可以引入电压串联负反馈减小放大倍数，增大输入电阻并减小输出电阻。 同相比例运算电路 RC移相式电路 由于共射放大电路的输出是反相的，因此输出没有相移时，不可能产生正反馈。一个电容最多可以产生\\(90^\\circ\\)的相移，使用3个电容就最多能产生\\(270^\\circ\\)的相移，就有可能存在一个频率，使相移为\\(-180^\\circ\\)，共射放大电路产生正反馈。电路的反馈回路中，电阻和电容的位置可以互换，无非就是最大相移是正负的区别。 RC双T选频网络 选频网络和正反馈网络是两个网络： 文氏桥振荡器 以RC串并联选频网络为选频网络和正反馈网络、并引入电压串联负反馈，两个网络构成桥路，一对顶点作为输出电压，一对顶点作为放大电路的净输入电压，就构成文氏桥振荡器： \\(R_\\mathrm{f}\u003e2R_1\\) 可以变换成桥： 同相比例运算电路有非常好的线性度，而反馈回路也是线性，缺少非线性环节，因此可以用热敏电阻或二极管作为非线性环节： 频率调节 调节频率的过程中，需要保证RC串并联选频网络中的两个电阻与电容都为相同的值。使用双刀单掷的开关作为电容选择来粗调频率，同轴电位器作为电阻选择来微调频率： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#rc双t选频网络"},{"categories":null,"content":"RC正弦波振荡电路 当振荡频率过高时，晶体管内部的结电容可能会对振荡产生影响。 RC串并联选频网络 相当于一个电路里存在一个高通电路和一个低通电路，这两个电路通频带的交集，就是待选频率。 分析使用两种极限情况进行分析： \\(f\\to 0\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] \\(f\\to\\infty\\) \\[\\begin{aligned} \\left|\\dot U_\\mathrm{f}\\right|\u0026\\to 0 \\\\ \\varphi_\\mathrm{f}\u0026\\to 90^\\circ \\end{aligned}\\] 因此两个极限频率之间应该应存在一个频率使得信号通过，写出反馈系数的表达式： \\[\\begin{aligned} \\dot{F}\u0026=\\frac{\\dot{U}_{\\mathrm{f}}}{\\dot{U}_{0}}=\\frac{R / / \\frac{1}{j \\omega C}}{R+\\frac{1}{j \\omega C}+R / / \\frac{1}{j \\omega C}}\\\\ \u0026=\\frac{1}{3+j\\left(\\omega R C-\\frac{1}{\\omega R C}\\right)}\\\\ \u0026=\\frac{1}{3+j\\left(\\frac{f}{f_{0}}-\\frac{f_{0}}{f}\\right)} \\end{aligned}\\] 其中： \\(f_{0}=\\frac{1}{2 \\pi R C}\\) 同时为低通电路的上限截止频率和高通电路的下限截止频率。 也就是\\(\\left|\\dot F\\right|_{\\max}=\\left|\\dot F\\right|_{f=f_0, \\varphi=0}=\\frac{1}{3}\\) 幅频特性曲线和相频特性曲线为： 放大电路 应使用电压放大倍数略大于3、输入电阻趋于无穷大、输出电阻趋于0的放大电路。 共射放大电路 共射放大电路的输出为一端接地，另一端反相的，不满足相位条件。 共集放大电路 没有电压放大的能力，而RC串并联选频网络要求的反馈系数必须大于3，不符合幅值条件。 共基放大电路 输入电阻小，输出电阻大，不方便计算且容易将温度特性带入反馈网络中。 两级共射放大电路 可以引入电压串联负反馈减小放大倍数，增大输入电阻并减小输出电阻。 同相比例运算电路 RC移相式电路 由于共射放大电路的输出是反相的，因此输出没有相移时，不可能产生正反馈。一个电容最多可以产生\\(90^\\circ\\)的相移，使用3个电容就最多能产生\\(270^\\circ\\)的相移，就有可能存在一个频率，使相移为\\(-180^\\circ\\)，共射放大电路产生正反馈。电路的反馈回路中，电阻和电容的位置可以互换，无非就是最大相移是正负的区别。 RC双T选频网络 选频网络和正反馈网络是两个网络： 文氏桥振荡器 以RC串并联选频网络为选频网络和正反馈网络、并引入电压串联负反馈，两个网络构成桥路，一对顶点作为输出电压，一对顶点作为放大电路的净输入电压，就构成文氏桥振荡器： \\(R_\\mathrm{f}\u003e2R_1\\) 可以变换成桥： 同相比例运算电路有非常好的线性度，而反馈回路也是线性，缺少非线性环节，因此可以用热敏电阻或二极管作为非线性环节： 频率调节 调节频率的过程中，需要保证RC串并联选频网络中的两个电阻与电容都为相同的值。使用双刀单掷的开关作为电容选择来粗调频率，同轴电位器作为电阻选择来微调频率： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#文氏桥振荡器"},{"categories":null,"content":"LC正弦波振荡电路 LC并联网络 理想的LC并联网络在谐振（可以看作交替给对方充能）时呈纯阻性，且阻抗无穷大： 此时的谐振频率为： \\[f_{0} = \\frac{1}{2 \\pi \\sqrt{L C}}\\] 而实际电路有损耗： 当损耗不大的情况下，品质因数（可达几百）和谐振频率为： \\[\\begin{aligned} Q \u0026\\approx \\frac{1}{R} \\cdot \\sqrt{\\frac{L}{C}} \\\\ f_{0} \u0026\\approx \\frac{1}{2 \\pi \\sqrt{L C}} \\end{aligned}\\] 网络的幅频特性曲线和相频特性曲线为： 品质因数越大，幅值越高，由于相频特性曲线变陡峭了，导致相位的发生变化时，频率也不会有很大的变化，因此振荡的频率也越稳定。 变压器反馈式正弦波振荡电路 要使LC选频放大电路开始振荡，就要引入反馈，最简单的做法是通过变压器引入反馈： 变压器的两个原边\\(N_1\\)和\\(N_2\\)是同名端。同名端就是有黑点的端口，电位变化一致。 \\(C_1\\) 作用是防止在直流通路中，基极直接接地导致三极管截止，电路无法正常工作。 使用瞬时极性法进行分析相位条件： 由于\\(U_\\mathrm{f}\\)与\\(U_\\mathrm{i}\\)极性相同，因此该电路可能发生振荡。由于三极管是非线性的，因此只要调整合适的线圈匝数比，满足幅值条件，即可发生振荡。 优点 容易振荡 波形较好 缺点 耦合不紧密 使用磁路进行耦合导致\\(N_1,N_2\\)耦合不紧密，解决方法是把\\(N_1,N_2\\)合二为一，变成电感反馈式正弦波振荡电路。 频率稳定性不高 LC选频放大电路 使用LC并联网络作为三极管的集电极电阻。对于共射放大电路而言，集电极电阻越大，放大倍数越大。这样频率不同，放大电路的放大倍数也会不同。且只有在谐振频率下，集电极阻抗非常大，放大倍数才会非常大。 幅频特性曲线与相频特性曲线与LC并联网络一致，当\\(f=f_0\\)时的电压放大倍数的数值最大，且附加相移为0，LC并联网络变为了纯阻性，也就达到了选频和放大的效果。 电感反馈式正弦波振荡电路 输出和反馈在同一个线圈上，耦合更加紧密。 \\(C_1\\) 作用是防止在直流通路中，基极直连\\(V_\\mathrm{CC}\\)导致三极管饱和，电路无法正常工作。使变压器反馈式正弦波振荡电路的\\(N_1,N_2\\)直接相连，在交流通路里： 电感的3个抽头分别接晶体管的三个极，故称之为 电感三点式电路 。 优点 耦合紧密 容易振荡 振幅大 振荡频率范围宽 将可调电容作为LC选频放大电路的电容时，即可调节振荡频率。 缺点 波形较差，有高次谐波 电感对于空气高频信号阻抗大，比较敏感 调节线圈的匝数比时，要注意由于\\(\\left|\\dot A\\right|\\)与\\(\\left|\\dot F\\right|\\)分别在分子和分母上含有负载，它们的变化是相反的。 电容反馈式正弦波振荡电路 也叫做 电容三点式电路 。 \\(R_\\mathrm{c}\\) 防止三极管的集电极在交流通路里直接接地，导致没有输出。 \\(C_1\\) 防止在直流通路中集电极直接接地。 \\(C_2\\) 防止在直流通路中基极直接接地。通过电容串联的公式，可以得到： \\[f_{0} \\approx \\frac{1}{2 \\pi \\sqrt{L \\cdot C_{1} C_{2} /\\left(C_{1}+C_{2}\\right)}}\\] 当频率比较高的时候，晶体管内的结电容开始作用了，因此可以在\\(L\\)旁边串联上一个小电容\\(C\\ll C_1\\)且\\(C\\ll C_2\\)，则LC并联网络的电容大小就受制于\\(C\\)，几乎不受结电容的影响： \\[f_0\\approx\\frac{1}{2\\pi\\sqrt{LC}}\\] 优点 波形好 缺点 振荡频率调整范围小 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#lc正弦波振荡电路"},{"categories":null,"content":"LC正弦波振荡电路 LC并联网络 理想的LC并联网络在谐振（可以看作交替给对方充能）时呈纯阻性，且阻抗无穷大： 此时的谐振频率为： \\[f_{0} = \\frac{1}{2 \\pi \\sqrt{L C}}\\] 而实际电路有损耗： 当损耗不大的情况下，品质因数（可达几百）和谐振频率为： \\[\\begin{aligned} Q \u0026\\approx \\frac{1}{R} \\cdot \\sqrt{\\frac{L}{C}} \\\\ f_{0} \u0026\\approx \\frac{1}{2 \\pi \\sqrt{L C}} \\end{aligned}\\] 网络的幅频特性曲线和相频特性曲线为： 品质因数越大，幅值越高，由于相频特性曲线变陡峭了，导致相位的发生变化时，频率也不会有很大的变化，因此振荡的频率也越稳定。 变压器反馈式正弦波振荡电路 要使LC选频放大电路开始振荡，就要引入反馈，最简单的做法是通过变压器引入反馈： 变压器的两个原边\\(N_1\\)和\\(N_2\\)是同名端。同名端就是有黑点的端口，电位变化一致。 \\(C_1\\) 作用是防止在直流通路中，基极直接接地导致三极管截止，电路无法正常工作。 使用瞬时极性法进行分析相位条件： 由于\\(U_\\mathrm{f}\\)与\\(U_\\mathrm{i}\\)极性相同，因此该电路可能发生振荡。由于三极管是非线性的，因此只要调整合适的线圈匝数比，满足幅值条件，即可发生振荡。 优点 容易振荡 波形较好 缺点 耦合不紧密 使用磁路进行耦合导致\\(N_1,N_2\\)耦合不紧密，解决方法是把\\(N_1,N_2\\)合二为一，变成电感反馈式正弦波振荡电路。 频率稳定性不高 LC选频放大电路 使用LC并联网络作为三极管的集电极电阻。对于共射放大电路而言，集电极电阻越大，放大倍数越大。这样频率不同，放大电路的放大倍数也会不同。且只有在谐振频率下，集电极阻抗非常大，放大倍数才会非常大。 幅频特性曲线与相频特性曲线与LC并联网络一致，当\\(f=f_0\\)时的电压放大倍数的数值最大，且附加相移为0，LC并联网络变为了纯阻性，也就达到了选频和放大的效果。 电感反馈式正弦波振荡电路 输出和反馈在同一个线圈上，耦合更加紧密。 \\(C_1\\) 作用是防止在直流通路中，基极直连\\(V_\\mathrm{CC}\\)导致三极管饱和，电路无法正常工作。使变压器反馈式正弦波振荡电路的\\(N_1,N_2\\)直接相连，在交流通路里： 电感的3个抽头分别接晶体管的三个极，故称之为 电感三点式电路 。 优点 耦合紧密 容易振荡 振幅大 振荡频率范围宽 将可调电容作为LC选频放大电路的电容时，即可调节振荡频率。 缺点 波形较差，有高次谐波 电感对于空气高频信号阻抗大，比较敏感 调节线圈的匝数比时，要注意由于\\(\\left|\\dot A\\right|\\)与\\(\\left|\\dot F\\right|\\)分别在分子和分母上含有负载，它们的变化是相反的。 电容反馈式正弦波振荡电路 也叫做 电容三点式电路 。 \\(R_\\mathrm{c}\\) 防止三极管的集电极在交流通路里直接接地，导致没有输出。 \\(C_1\\) 防止在直流通路中集电极直接接地。 \\(C_2\\) 防止在直流通路中基极直接接地。通过电容串联的公式，可以得到： \\[f_{0} \\approx \\frac{1}{2 \\pi \\sqrt{L \\cdot C_{1} C_{2} /\\left(C_{1}+C_{2}\\right)}}\\] 当频率比较高的时候，晶体管内的结电容开始作用了，因此可以在\\(L\\)旁边串联上一个小电容\\(C\\ll C_1\\)且\\(C\\ll C_2\\)，则LC并联网络的电容大小就受制于\\(C\\)，几乎不受结电容的影响： \\[f_0\\approx\\frac{1}{2\\pi\\sqrt{LC}}\\] 优点 波形好 缺点 振荡频率调整范围小 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#lc并联网络"},{"categories":null,"content":"LC正弦波振荡电路 LC并联网络 理想的LC并联网络在谐振（可以看作交替给对方充能）时呈纯阻性，且阻抗无穷大： 此时的谐振频率为： \\[f_{0} = \\frac{1}{2 \\pi \\sqrt{L C}}\\] 而实际电路有损耗： 当损耗不大的情况下，品质因数（可达几百）和谐振频率为： \\[\\begin{aligned} Q \u0026\\approx \\frac{1}{R} \\cdot \\sqrt{\\frac{L}{C}} \\\\ f_{0} \u0026\\approx \\frac{1}{2 \\pi \\sqrt{L C}} \\end{aligned}\\] 网络的幅频特性曲线和相频特性曲线为： 品质因数越大，幅值越高，由于相频特性曲线变陡峭了，导致相位的发生变化时，频率也不会有很大的变化，因此振荡的频率也越稳定。 变压器反馈式正弦波振荡电路 要使LC选频放大电路开始振荡，就要引入反馈，最简单的做法是通过变压器引入反馈： 变压器的两个原边\\(N_1\\)和\\(N_2\\)是同名端。同名端就是有黑点的端口，电位变化一致。 \\(C_1\\) 作用是防止在直流通路中，基极直接接地导致三极管截止，电路无法正常工作。 使用瞬时极性法进行分析相位条件： 由于\\(U_\\mathrm{f}\\)与\\(U_\\mathrm{i}\\)极性相同，因此该电路可能发生振荡。由于三极管是非线性的，因此只要调整合适的线圈匝数比，满足幅值条件，即可发生振荡。 优点 容易振荡 波形较好 缺点 耦合不紧密 使用磁路进行耦合导致\\(N_1,N_2\\)耦合不紧密，解决方法是把\\(N_1,N_2\\)合二为一，变成电感反馈式正弦波振荡电路。 频率稳定性不高 LC选频放大电路 使用LC并联网络作为三极管的集电极电阻。对于共射放大电路而言，集电极电阻越大，放大倍数越大。这样频率不同，放大电路的放大倍数也会不同。且只有在谐振频率下，集电极阻抗非常大，放大倍数才会非常大。 幅频特性曲线与相频特性曲线与LC并联网络一致，当\\(f=f_0\\)时的电压放大倍数的数值最大，且附加相移为0，LC并联网络变为了纯阻性，也就达到了选频和放大的效果。 电感反馈式正弦波振荡电路 输出和反馈在同一个线圈上，耦合更加紧密。 \\(C_1\\) 作用是防止在直流通路中，基极直连\\(V_\\mathrm{CC}\\)导致三极管饱和，电路无法正常工作。使变压器反馈式正弦波振荡电路的\\(N_1,N_2\\)直接相连，在交流通路里： 电感的3个抽头分别接晶体管的三个极，故称之为 电感三点式电路 。 优点 耦合紧密 容易振荡 振幅大 振荡频率范围宽 将可调电容作为LC选频放大电路的电容时，即可调节振荡频率。 缺点 波形较差，有高次谐波 电感对于空气高频信号阻抗大，比较敏感 调节线圈的匝数比时，要注意由于\\(\\left|\\dot A\\right|\\)与\\(\\left|\\dot F\\right|\\)分别在分子和分母上含有负载，它们的变化是相反的。 电容反馈式正弦波振荡电路 也叫做 电容三点式电路 。 \\(R_\\mathrm{c}\\) 防止三极管的集电极在交流通路里直接接地，导致没有输出。 \\(C_1\\) 防止在直流通路中集电极直接接地。 \\(C_2\\) 防止在直流通路中基极直接接地。通过电容串联的公式，可以得到： \\[f_{0} \\approx \\frac{1}{2 \\pi \\sqrt{L \\cdot C_{1} C_{2} /\\left(C_{1}+C_{2}\\right)}}\\] 当频率比较高的时候，晶体管内的结电容开始作用了，因此可以在\\(L\\)旁边串联上一个小电容\\(C\\ll C_1\\)且\\(C\\ll C_2\\)，则LC并联网络的电容大小就受制于\\(C\\)，几乎不受结电容的影响： \\[f_0\\approx\\frac{1}{2\\pi\\sqrt{LC}}\\] 优点 波形好 缺点 振荡频率调整范围小 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#变压器反馈式正弦波振荡电路"},{"categories":null,"content":"LC正弦波振荡电路 LC并联网络 理想的LC并联网络在谐振（可以看作交替给对方充能）时呈纯阻性，且阻抗无穷大： 此时的谐振频率为： \\[f_{0} = \\frac{1}{2 \\pi \\sqrt{L C}}\\] 而实际电路有损耗： 当损耗不大的情况下，品质因数（可达几百）和谐振频率为： \\[\\begin{aligned} Q \u0026\\approx \\frac{1}{R} \\cdot \\sqrt{\\frac{L}{C}} \\\\ f_{0} \u0026\\approx \\frac{1}{2 \\pi \\sqrt{L C}} \\end{aligned}\\] 网络的幅频特性曲线和相频特性曲线为： 品质因数越大，幅值越高，由于相频特性曲线变陡峭了，导致相位的发生变化时，频率也不会有很大的变化，因此振荡的频率也越稳定。 变压器反馈式正弦波振荡电路 要使LC选频放大电路开始振荡，就要引入反馈，最简单的做法是通过变压器引入反馈： 变压器的两个原边\\(N_1\\)和\\(N_2\\)是同名端。同名端就是有黑点的端口，电位变化一致。 \\(C_1\\) 作用是防止在直流通路中，基极直接接地导致三极管截止，电路无法正常工作。 使用瞬时极性法进行分析相位条件： 由于\\(U_\\mathrm{f}\\)与\\(U_\\mathrm{i}\\)极性相同，因此该电路可能发生振荡。由于三极管是非线性的，因此只要调整合适的线圈匝数比，满足幅值条件，即可发生振荡。 优点 容易振荡 波形较好 缺点 耦合不紧密 使用磁路进行耦合导致\\(N_1,N_2\\)耦合不紧密，解决方法是把\\(N_1,N_2\\)合二为一，变成电感反馈式正弦波振荡电路。 频率稳定性不高 LC选频放大电路 使用LC并联网络作为三极管的集电极电阻。对于共射放大电路而言，集电极电阻越大，放大倍数越大。这样频率不同，放大电路的放大倍数也会不同。且只有在谐振频率下，集电极阻抗非常大，放大倍数才会非常大。 幅频特性曲线与相频特性曲线与LC并联网络一致，当\\(f=f_0\\)时的电压放大倍数的数值最大，且附加相移为0，LC并联网络变为了纯阻性，也就达到了选频和放大的效果。 电感反馈式正弦波振荡电路 输出和反馈在同一个线圈上，耦合更加紧密。 \\(C_1\\) 作用是防止在直流通路中，基极直连\\(V_\\mathrm{CC}\\)导致三极管饱和，电路无法正常工作。使变压器反馈式正弦波振荡电路的\\(N_1,N_2\\)直接相连，在交流通路里： 电感的3个抽头分别接晶体管的三个极，故称之为 电感三点式电路 。 优点 耦合紧密 容易振荡 振幅大 振荡频率范围宽 将可调电容作为LC选频放大电路的电容时，即可调节振荡频率。 缺点 波形较差，有高次谐波 电感对于空气高频信号阻抗大，比较敏感 调节线圈的匝数比时，要注意由于\\(\\left|\\dot A\\right|\\)与\\(\\left|\\dot F\\right|\\)分别在分子和分母上含有负载，它们的变化是相反的。 电容反馈式正弦波振荡电路 也叫做 电容三点式电路 。 \\(R_\\mathrm{c}\\) 防止三极管的集电极在交流通路里直接接地，导致没有输出。 \\(C_1\\) 防止在直流通路中集电极直接接地。 \\(C_2\\) 防止在直流通路中基极直接接地。通过电容串联的公式，可以得到： \\[f_{0} \\approx \\frac{1}{2 \\pi \\sqrt{L \\cdot C_{1} C_{2} /\\left(C_{1}+C_{2}\\right)}}\\] 当频率比较高的时候，晶体管内的结电容开始作用了，因此可以在\\(L\\)旁边串联上一个小电容\\(C\\ll C_1\\)且\\(C\\ll C_2\\)，则LC并联网络的电容大小就受制于\\(C\\)，几乎不受结电容的影响： \\[f_0\\approx\\frac{1}{2\\pi\\sqrt{LC}}\\] 优点 波形好 缺点 振荡频率调整范围小 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#电感反馈式正弦波振荡电路"},{"categories":null,"content":"LC正弦波振荡电路 LC并联网络 理想的LC并联网络在谐振（可以看作交替给对方充能）时呈纯阻性，且阻抗无穷大： 此时的谐振频率为： \\[f_{0} = \\frac{1}{2 \\pi \\sqrt{L C}}\\] 而实际电路有损耗： 当损耗不大的情况下，品质因数（可达几百）和谐振频率为： \\[\\begin{aligned} Q \u0026\\approx \\frac{1}{R} \\cdot \\sqrt{\\frac{L}{C}} \\\\ f_{0} \u0026\\approx \\frac{1}{2 \\pi \\sqrt{L C}} \\end{aligned}\\] 网络的幅频特性曲线和相频特性曲线为： 品质因数越大，幅值越高，由于相频特性曲线变陡峭了，导致相位的发生变化时，频率也不会有很大的变化，因此振荡的频率也越稳定。 变压器反馈式正弦波振荡电路 要使LC选频放大电路开始振荡，就要引入反馈，最简单的做法是通过变压器引入反馈： 变压器的两个原边\\(N_1\\)和\\(N_2\\)是同名端。同名端就是有黑点的端口，电位变化一致。 \\(C_1\\) 作用是防止在直流通路中，基极直接接地导致三极管截止，电路无法正常工作。 使用瞬时极性法进行分析相位条件： 由于\\(U_\\mathrm{f}\\)与\\(U_\\mathrm{i}\\)极性相同，因此该电路可能发生振荡。由于三极管是非线性的，因此只要调整合适的线圈匝数比，满足幅值条件，即可发生振荡。 优点 容易振荡 波形较好 缺点 耦合不紧密 使用磁路进行耦合导致\\(N_1,N_2\\)耦合不紧密，解决方法是把\\(N_1,N_2\\)合二为一，变成电感反馈式正弦波振荡电路。 频率稳定性不高 LC选频放大电路 使用LC并联网络作为三极管的集电极电阻。对于共射放大电路而言，集电极电阻越大，放大倍数越大。这样频率不同，放大电路的放大倍数也会不同。且只有在谐振频率下，集电极阻抗非常大，放大倍数才会非常大。 幅频特性曲线与相频特性曲线与LC并联网络一致，当\\(f=f_0\\)时的电压放大倍数的数值最大，且附加相移为0，LC并联网络变为了纯阻性，也就达到了选频和放大的效果。 电感反馈式正弦波振荡电路 输出和反馈在同一个线圈上，耦合更加紧密。 \\(C_1\\) 作用是防止在直流通路中，基极直连\\(V_\\mathrm{CC}\\)导致三极管饱和，电路无法正常工作。使变压器反馈式正弦波振荡电路的\\(N_1,N_2\\)直接相连，在交流通路里： 电感的3个抽头分别接晶体管的三个极，故称之为 电感三点式电路 。 优点 耦合紧密 容易振荡 振幅大 振荡频率范围宽 将可调电容作为LC选频放大电路的电容时，即可调节振荡频率。 缺点 波形较差，有高次谐波 电感对于空气高频信号阻抗大，比较敏感 调节线圈的匝数比时，要注意由于\\(\\left|\\dot A\\right|\\)与\\(\\left|\\dot F\\right|\\)分别在分子和分母上含有负载，它们的变化是相反的。 电容反馈式正弦波振荡电路 也叫做 电容三点式电路 。 \\(R_\\mathrm{c}\\) 防止三极管的集电极在交流通路里直接接地，导致没有输出。 \\(C_1\\) 防止在直流通路中集电极直接接地。 \\(C_2\\) 防止在直流通路中基极直接接地。通过电容串联的公式，可以得到： \\[f_{0} \\approx \\frac{1}{2 \\pi \\sqrt{L \\cdot C_{1} C_{2} /\\left(C_{1}+C_{2}\\right)}}\\] 当频率比较高的时候，晶体管内的结电容开始作用了，因此可以在\\(L\\)旁边串联上一个小电容\\(C\\ll C_1\\)且\\(C\\ll C_2\\)，则LC并联网络的电容大小就受制于\\(C\\)，几乎不受结电容的影响： \\[f_0\\approx\\frac{1}{2\\pi\\sqrt{LC}}\\] 优点 波形好 缺点 振荡频率调整范围小 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#电容反馈式正弦波振荡电路"},{"categories":null,"content":"石英晶体正弦波振荡电路 介绍 二氧化硅结晶体按一定方向切割的晶片。其机械变形和电场有关，产生： 压电效应 产生机械变形时会产生电场，外加电场会产生机械变形。 压电振荡 以石英晶体的固有频率产生机械变形时，其产生的电场强度最大；当以石英晶体的固有频率施加电场时，其产生的机械变形最大。 固有频率只决定于其几何尺寸和电极面积，因此频率在生产时就固定好了，很稳定。 特点 选频网络 Q \\(\\frac{\\Delta f}{f}\\) LC选频网络 \\(100\\sim 1000\\) \\(10^{-5}\\) 石英晶体 \\(10^4\\sim 10^6\\) \\(10^{-10}\\sim 10^{-11}\\) 等效 从端口看，等效电路中既有电容串联电感，可能产生串联谐振，又有电容并联电感，可能产生并联谐振。 \\(C_0=1\\sim 100\\text{pF}\\)：静态电容 \\(C=0.01\\sim 0.1\\text{pF}\\)：晶片弹性的等效电容 \\(L\\)：振动惯性等效的电感 \\(f_\\mathrm{s}\\)：串联谐振点 \\(f_\\mathrm{p}\\)：并联谐振点 \\(C\\ll C_0\\Rightarrow f_\\mathrm{s}\\approx f_\\mathrm{p}\\approx \\frac{1}{2\\pi\\sqrt{LC}}\\)。 连接方式 并联型电路 此时石英晶体取代了原来电容三点式电路中的电感，因此应工作在感性区。 串联型电路 由于石英晶体是串联接入反馈回路，因此就希望其上面的阻抗越小越好，所以应工作在串联谐振点上，既进行了选频（只有频率一定才可以工作在串联谐振点上），又引入了正反馈。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:5:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#石英晶体正弦波振荡电路"},{"categories":null,"content":"电压比较器电路 输入电压是模拟信号；输出电压表示比较的结果，只有高电平和低电平两种情况，为二值信号。 电压传输特性 \\[u_\\mathrm{O}=f(U_\\mathrm{I})\\] 输出电平 输出高电平\\(U_\\mathrm{OH}\\) 输出低电平\\(U_\\mathrm{OL}\\) 过阈值时的跃变向方 阈值电压\\(U_\\mathrm{T}\\) 特征 集成运放多处于开环或仅引入正反馈： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#电压比较器电路"},{"categories":null,"content":"单限比较器 过零比较器 直接将输入信号与运放的输入端相连。如果是理想运放，给予一个无穷小量的输入，就会产生跃变。 电压传输特性 \\[u_\\mathrm{O}=\\begin{cases} -U_\\mathrm{OM},\u0026u_\\mathrm{I}\u003e0 \\+U_\\mathrm{OM},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 即： \\(U_\\mathrm{T}=0\\) \\(U_\\mathrm{OH}=+U_\\mathrm{OM},U_\\mathrm{OL}=-U_\\mathrm{OM}\\) 保护电路 输入保护 输入电压一定会在正负二极管导通电压之间，必须要有限流电阻，否则会烧二极管。 输出保护 限幅 输出电压一定会在正负稳压二极管稳定电压之间。 \\(U_\\mathrm{OH}=+U_\\mathrm{Z1}+U_\\mathrm{D2}\\) \\(U_\\mathrm{OL}=-\\left(U_{Z2}+U_\\mathrm{D1}\\right)\\) 正电压 如果下一级只需要正的电压，可以使用一个稳压管并上一个锗材料的二极管，由于锗材料制作的二极管导通电压很低，通常为\\(0.1\\sim 0.3 \\text{V}\\)，可以近似地得到\\(0\\text{V}\\)。 \\(U_\\mathrm{OH}=U_\\mathrm{Z},U_\\mathrm{OL}=-U_\\mathrm{D}\\) 输入保护+限幅 只有当稳压二极管被击穿的时候才会引入负反馈，由于引入负反馈后，该运放的反相输入端相当于虚地，这样就保护了输入端；引入负反馈后，运放工作在线性区，运放内部的管子不会进入饱和区和截止区，可以加快转换速度。 一般单限比较器 通过叠加定理，求输入端与输入电压和参考电压的关系： \\[u_{\\mathrm{N}}=\\frac{R_{2}}{R_{1}+R_{2}} \\cdot U_{\\mathrm{REF}}+\\frac{R_{1}}{R_{1}+R_{2}}\\] 令\\(u_{\\mathrm{I}}=u_{\\mathrm{P}}=0\\)解得阈值电压\\(U_{\\mathrm{T}}=-\\frac{R_{2}}{R_{1}} \\cdot U_{\\mathrm{REF}}\\) 如果要改变输出电压的跃变方向，只需要互换同相输入端和反相输入端即可。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#单限比较器"},{"categories":null,"content":"单限比较器 过零比较器 直接将输入信号与运放的输入端相连。如果是理想运放，给予一个无穷小量的输入，就会产生跃变。 电压传输特性 \\[u_\\mathrm{O}=\\begin{cases} -U_\\mathrm{OM},\u0026u_\\mathrm{I}\u003e0 \\+U_\\mathrm{OM},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 即： \\(U_\\mathrm{T}=0\\) \\(U_\\mathrm{OH}=+U_\\mathrm{OM},U_\\mathrm{OL}=-U_\\mathrm{OM}\\) 保护电路 输入保护 输入电压一定会在正负二极管导通电压之间，必须要有限流电阻，否则会烧二极管。 输出保护 限幅 输出电压一定会在正负稳压二极管稳定电压之间。 \\(U_\\mathrm{OH}=+U_\\mathrm{Z1}+U_\\mathrm{D2}\\) \\(U_\\mathrm{OL}=-\\left(U_{Z2}+U_\\mathrm{D1}\\right)\\) 正电压 如果下一级只需要正的电压，可以使用一个稳压管并上一个锗材料的二极管，由于锗材料制作的二极管导通电压很低，通常为\\(0.1\\sim 0.3 \\text{V}\\)，可以近似地得到\\(0\\text{V}\\)。 \\(U_\\mathrm{OH}=U_\\mathrm{Z},U_\\mathrm{OL}=-U_\\mathrm{D}\\) 输入保护+限幅 只有当稳压二极管被击穿的时候才会引入负反馈，由于引入负反馈后，该运放的反相输入端相当于虚地，这样就保护了输入端；引入负反馈后，运放工作在线性区，运放内部的管子不会进入饱和区和截止区，可以加快转换速度。 一般单限比较器 通过叠加定理，求输入端与输入电压和参考电压的关系： \\[u_{\\mathrm{N}}=\\frac{R_{2}}{R_{1}+R_{2}} \\cdot U_{\\mathrm{REF}}+\\frac{R_{1}}{R_{1}+R_{2}}\\] 令\\(u_{\\mathrm{I}}=u_{\\mathrm{P}}=0\\)解得阈值电压\\(U_{\\mathrm{T}}=-\\frac{R_{2}}{R_{1}} \\cdot U_{\\mathrm{REF}}\\) 如果要改变输出电压的跃变方向，只需要互换同相输入端和反相输入端即可。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#过零比较器"},{"categories":null,"content":"单限比较器 过零比较器 直接将输入信号与运放的输入端相连。如果是理想运放，给予一个无穷小量的输入，就会产生跃变。 电压传输特性 \\[u_\\mathrm{O}=\\begin{cases} -U_\\mathrm{OM},\u0026u_\\mathrm{I}\u003e0 \\+U_\\mathrm{OM},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 即： \\(U_\\mathrm{T}=0\\) \\(U_\\mathrm{OH}=+U_\\mathrm{OM},U_\\mathrm{OL}=-U_\\mathrm{OM}\\) 保护电路 输入保护 输入电压一定会在正负二极管导通电压之间，必须要有限流电阻，否则会烧二极管。 输出保护 限幅 输出电压一定会在正负稳压二极管稳定电压之间。 \\(U_\\mathrm{OH}=+U_\\mathrm{Z1}+U_\\mathrm{D2}\\) \\(U_\\mathrm{OL}=-\\left(U_{Z2}+U_\\mathrm{D1}\\right)\\) 正电压 如果下一级只需要正的电压，可以使用一个稳压管并上一个锗材料的二极管，由于锗材料制作的二极管导通电压很低，通常为\\(0.1\\sim 0.3 \\text{V}\\)，可以近似地得到\\(0\\text{V}\\)。 \\(U_\\mathrm{OH}=U_\\mathrm{Z},U_\\mathrm{OL}=-U_\\mathrm{D}\\) 输入保护+限幅 只有当稳压二极管被击穿的时候才会引入负反馈，由于引入负反馈后，该运放的反相输入端相当于虚地，这样就保护了输入端；引入负反馈后，运放工作在线性区，运放内部的管子不会进入饱和区和截止区，可以加快转换速度。 一般单限比较器 通过叠加定理，求输入端与输入电压和参考电压的关系： \\[u_{\\mathrm{N}}=\\frac{R_{2}}{R_{1}+R_{2}} \\cdot U_{\\mathrm{REF}}+\\frac{R_{1}}{R_{1}+R_{2}}\\] 令\\(u_{\\mathrm{I}}=u_{\\mathrm{P}}=0\\)解得阈值电压\\(U_{\\mathrm{T}}=-\\frac{R_{2}}{R_{1}} \\cdot U_{\\mathrm{REF}}\\) 如果要改变输出电压的跃变方向，只需要互换同相输入端和反相输入端即可。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#一般单限比较器"},{"categories":null,"content":"滞回比较器 回差电压\\(\\Delta U=\\left|U_\\mathrm{T1}-U_\\mathrm{T2}\\right|\\) 电路图如下： 输出有限幅，即： \\[\\begin{aligned} U_{\\mathrm{OL}} \u0026=-U_{\\mathrm{z}} \\\\ U_{\\mathrm{OH}} \u0026=+U_{\\mathrm{z}} \\end{aligned}\\] 由于引入了正反馈，输入与输出有关，输出有两个值意味着输入也有两个值： \\[\\begin{aligned} u_{\\mathrm{N}} \u0026=u_{\\mathrm{I}} \\\\ u_{\\mathrm{p}} \u0026=\\frac{R_{1}}{R_{1}+R_{2}} \\cdot u_{\\mathrm{o}} \\end{aligned}\\] 解得： \\[u_{\\mathrm{N}}=u_{\\mathrm{p}} \\\\ \\pm U_{\\mathrm{T}}=\\pm \\frac{R_{1}}{R_{1}+R_{2}} \\cdot U_{\\mathrm{z}}\\] 电压传输特性 设\\(u_\\mathrm{I}\u003e-U_\\mathrm{T}\\)，则\\(u_\\mathrm{N}\u003eu_\\mathrm{P},u_\\mathrm{O}=-U_\\mathrm{Z}\\)，反馈到同相输入端后，\\(u_\\mathrm{P}=-U_\\mathrm{T}\\)，只有\\(u_\\mathrm{N}\u003cu_\\mathrm{P}\\)，即输入电压增大到\\(u_\\mathrm{I}\u003c+U_\\mathrm{T}\\)，才能使\\(u_\\mathrm{O}=+U_\\mathrm{Z}\\)，反之亦然。如果加的电压是0，则输出电压是随机的，但只要输入的电压是大于0或者小于0，就会因为正反馈达到阈值电压。 左右平移 平移电压的表达式为（右为正）： \\[\\frac{R_2}{R_1+R_2}\\cdot U_\\mathrm{REF}\\] 上下平移：改变稳压管的稳压值，如果不对称，需要用两个稳压值不同的稳压管。 改变跃变方向 由于引入了正反馈，不能随意交换同相输入端和反相输入端，只能改变信号源的位置。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#滞回比较器"},{"categories":null,"content":"窗口比较器 电路图如下： 当\\(u_\\mathrm{I}\u003eU_\\mathrm{RH}\\)或\\(u_\\mathrm{I}\u003cU_\\mathrm{RL}\\)时，两个运放的二极管分别导通，分别都输出\\(U_\\mathrm{OM}\\)，最后经过稳压管稳压，输出电压为\\(U_\\mathrm{Z}\\)；而当\\(U_\\mathrm{RL}\u003cu_\\mathrm{I}\u003cU_\\mathrm{RH}\\)时，两个二极管均截止，因此输出为0。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#窗口比较器"},{"categories":null,"content":"集成比较器 相当于由一个理想运放，和一个三极管组成。三极管作为开关管，集电极和发射极引脚被引出。 特点 无需限幅电路：根据高低电平直接决定电源电压。 直接驱动数字电路 运放供电与输出供电分开，输出供电可以直接使用后级数字电路的供电。 应用灵活 集电极输出 输出与运放的输出是反相的，因此运放的同相输入端和反相输入端需要调换位置。输出的低电平为三极管的饱和管压降。 发射极输出 输出的高电平为正的电源电压减去饱和管压降。 选通端 可以加上三极管的集电极或者发射极加上开关，决定电路是否工作。 并联使用 集成运放的输出端可以输入电流，因此不能并联使用，而集成比较器使用了三极管，基极与集电极有单向导电性，因此可以并联，达到与、或的效果。 响应速度快 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:6:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#集成比较器"},{"categories":null,"content":"波形发生电路 常见波形 矩形波可以通过各种变换得到其他波形。 矩形波 三角波 锯齿波 尖顶波 阶梯波 分析方法 设电路已振荡，且在某一暂态，看是否能自动翻转为另一暂态，并能再回到原暂态。 电路合闸通电，分析电路是否有两个暂态，而无稳态。 组成 开关电路 因为输出只有高电平和低电平两种情况，即两个暂态，故采用电压比较器。 延迟环节 要使两个暂态均维持一定的时间，故采用RC环节实现，从而决定振荡频率。 输出控制输入 因需自控，在输出为某一暂态时孕育翻转成另一暂态的条件，故应输出控制延时环节，延时电路的输出控制输入。 思路 从滞回比较器出发，加上 RC 回路控制比较器的输入来输出方波，通过控制电容充电和放电的速度来调节占空比，通过稳压管来得到想要的方波电压。三角波的发生需要对这个方波发生电路进行积分，但是观察到最后输出的三角波和滞回比较器上的 RC 回路电容的电压变化很相似，因此想要直接把三角波的输出接回滞回比较器的输入，由于要让滞回比较器工作在深度饱和状态，必须是正反馈，因此要引回同相输入端，而改让反相输入端接地。通过改变电容充放电的速度，可以在三角波和锯齿波之间过渡。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:7:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#波形发生电路"},{"categories":null,"content":"方波发生电路 由一个\\(RC\\)回路和一个滞回比较器构成： \\(RC\\)回路 当\\(u_\\mathrm{O}=+U_\\mathrm{Z}\\)时，电流从输出通过电容流向地；当\\(u_\\mathrm{O}=-U_\\mathrm{Z}\\)时，电流从地通过电容流向输出。两个过程都是在充电，区别是一个充的是正电，一个充的是负电。 滞回比较器 该电路是使得电容上的电压，两个阈值之间来回振荡的，振荡的幅度就是回差电压。下面分析该电路能否发生振荡： 合闸通电时，\\(u_\\mathrm{O}\\uparrow \\Rightarrow u_\\mathrm{P}\\uparrow \\Rightarrow u_\\mathrm{O}\\uparrow\\uparrow\\)，当\\(u_\\mathrm{O}=U_\\mathrm{Z}\\)时， \\(u_\\mathrm{P}=+U_\\mathrm{T}\\)，进入第一暂态，电容开始正向充电，由于通常\\(U_\\mathrm{T}\u003cU_\\mathrm{Z}\\)，当电容的电压升高到超过\\(u_\\mathrm{P}=+U_\\mathrm{T}\\)，输出电压跃变为\\(-U_\\mathrm{Z}\\)，进入第二暂态。第二暂态的分析同上，两个状态交替进入，电路就开始振荡： 参数 通过三要素法（始值 、终止值、时间常数），可以求出： 周期\\(T=2R_3C\\ln \\left(1+\\frac{2R_1}{R_2}\\right)\\) 占空比\\(q=\\frac{T_k}{T}=50\\%\\) 要调节占空比，就要调整电容正向充电和反向充电的时间常数，可以使用二极管串联不同阻值的电阻来实现： 要使得占空比调节范围更大，\\(R_3\\)应尽可能比\\(R_\\mathrm{w}\\)小。 脉冲宽度\\(T_\\mathrm{k}\\) ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:7:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#方波发生电路"},{"categories":null,"content":"三角波发生电路 可以使用一个方波发生电路和一个积分运算电路简单地进行连接： 电路中有两个\\(RC\\)环节，比较冗余。可以对上面的电路进行分析：电路振荡的关键是要把使得反相输入端的电位高于同相输入端，除了升高反相输入端的电位之外，也可以降低同相输入端的电位，由于积分运算电路的输出是负的，因此确实可以实现降低电位的功能，可以把两个电路的\\(RC\\)环节合二为一，使用同相输入的滞回比较器： 滞回比较器的阈值为： \\[\\pm U_{\\mathrm{T}}=\\pm \\frac{R_{1}}{R_{2}} \\cdot U_{\\mathrm{z}}\\] 由于滞回比较器的输出在暂态中是定值，因此可以用线性积分（相乘）得到积分运算电路的输出： \\[u_\\mathrm{O}=-\\frac{1}{R_3C}\\cdot u_\\mathrm{O1}(t_2-t_1)+u_\\mathrm{O}(t_1)\\] 参考一般单限比较器中使用的叠加定理，可以得到滞回比较器的输入： \\[u_{\\mathrm{P1}}=\\frac{R_{1}}{R_{1}+R_{2}} \\cdot u_{\\mathrm{O} 1}+\\frac{R_{2}}{R_{1}+R_{2}} \\cdot u_{\\mathrm{O}}\\] 合闸通电时，\\(u_\\mathrm{O1}\\uparrow \\Rightarrow u_\\mathrm{O2}\\uparrow \\Rightarrow u_\\mathrm{O1}\\uparrow\\uparrow\\)，当\\(u_\\mathrm{O1}=U_\\mathrm{Z}\\)时， \\(u_\\mathrm{P}=+U_\\mathrm{T}\\)，进入第一暂态。积分电路开始积分，输出电压下降，直到\\(u_\\mathrm{O}\u003c-U_\\mathrm{T}\\)时，\\(u_\\mathrm{O1}=-U_\\mathrm{Z}\\)，进入第二暂态。两个暂态相互转换，就形成了振荡： 参数 \\(u_\\mathrm{O1}\\)的振幅 如果要改变\\(u_\\mathrm{O1}\\)的振幅，可以改变限幅电路。如果还要求其余的参数不变，则还需要调整\\(R_1,R_2\\)。 \\(u_\\mathrm{O}\\)的振幅 如果要改变\\(u_\\mathrm{O}\\)的幅值，电容充放电的最大电压，也就是改变阈值电压，即改变滞回比较器的回差电压。 振荡周期\\(T=\\frac{4R_1R_3C}{R_2}\\) 如果要保证其他参数不变，则该参数需要最后调整。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:7:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#三角波发生电路"},{"categories":null,"content":"锯齿波发生电路 和改变方波发生电路占空比的思路一样，通过二极管和电位器改变电容的充放电时间： 产生锯齿波： 这里锯齿波上升和下降的斜率不同但幅值相同的原因是方波发生电路和积分运算电路使用了相同的\\(RC\\)环节，只有电容的电压阈值达到阈值输出才会跃变，因此改变充放电速度即可在幅值不变的情况下改变斜率。 压控振荡器 又称\\(u\\text{-}f\\)转换电路，完成从模拟量到数字量的转换。当锯齿波发生电路的电位器在最上方时，\\(T_2\\approx T\\)，如果让一个电压来控制\\(T_2\\)的话，就可以用电压控制电路的振荡频率： 翻转电路使得电压输入端移到左边： 通过三角波发生电路中的分析可以得到： \\[\\pm U_{\\mathrm{T}}=\\pm \\frac{R_{2}}{R_{3}} \\cdot U_{\\mathrm{z}}\\] 通过积分运算电路的分析可以列写方程： \\[U_{\\mathrm{T}}=-\\frac{1}{R_{1} C} \\cdot u_{\\mathrm{I}} T_{1}-U_{\\mathrm{T}} \\approx-\\frac{1}{R_{1} C} \\cdot u_{\\mathrm{I}} T-U_{\\mathrm{T}}\\] 得到频率关于电压的表达式： \\[f \\approx \\frac{1}{T_{1}}=\\frac{R_{3}}{2 R_{1} R_{2} C} \\cdot \\frac{u_{\\mathrm{I}}}{U_{\\mathrm{Z}}}\\] 单位时间内脉冲个数表示电压的数值，故实现A/D转换。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:7:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#锯齿波发生电路"},{"categories":null,"content":"锯齿波发生电路 和改变方波发生电路占空比的思路一样，通过二极管和电位器改变电容的充放电时间： 产生锯齿波： 这里锯齿波上升和下降的斜率不同但幅值相同的原因是方波发生电路和积分运算电路使用了相同的\\(RC\\)环节，只有电容的电压阈值达到阈值输出才会跃变，因此改变充放电速度即可在幅值不变的情况下改变斜率。 压控振荡器 又称\\(u\\text{-}f\\)转换电路，完成从模拟量到数字量的转换。当锯齿波发生电路的电位器在最上方时，\\(T_2\\approx T\\)，如果让一个电压来控制\\(T_2\\)的话，就可以用电压控制电路的振荡频率： 翻转电路使得电压输入端移到左边： 通过三角波发生电路中的分析可以得到： \\[\\pm U_{\\mathrm{T}}=\\pm \\frac{R_{2}}{R_{3}} \\cdot U_{\\mathrm{z}}\\] 通过积分运算电路的分析可以列写方程： \\[U_{\\mathrm{T}}=-\\frac{1}{R_{1} C} \\cdot u_{\\mathrm{I}} T_{1}-U_{\\mathrm{T}} \\approx-\\frac{1}{R_{1} C} \\cdot u_{\\mathrm{I}} T-U_{\\mathrm{T}}\\] 得到频率关于电压的表达式： \\[f \\approx \\frac{1}{T_{1}}=\\frac{R_{3}}{2 R_{1} R_{2} C} \\cdot \\frac{u_{\\mathrm{I}}}{U_{\\mathrm{Z}}}\\] 单位时间内脉冲个数表示电压的数值，故实现A/D转换。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:7:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#压控振荡器"},{"categories":null,"content":"波形变换电路 常见波形变换 正弦波变方波：过零比较器 正弦波变矩形波：一般单限比较器、滞回比较器 正弦波变二倍频：乘方运算电路+高通滤波器 方波变三角波：积分运算电路 三角波变方波：微分运算电路 固定频率的三角波变正弦波：低通滤波器、带通滤波器 三角波变二倍频锯齿波 也就是要在上升的时候比例系数是正的，下降的时候比例系数是负的。可以使用电子开关控制比例系数，在电压上升的时候关闭，在下降的时候打开，（微分运算电路可以实现这样的电子开关）： 开关闭合：\\(u_\\mathrm{O}=-u_\\mathrm{I}\\) 开关断开：\\(u_\\mathrm{O}=u_\\mathrm{I}\\) 三角波变正弦波 输入信号的频率变化不大：滤波法 三角波用傅立叶级数展开，除基波（基波是指在复杂的周期性振荡中与该振荡最长周期相等的正弦波分量）外，还含有奇数次谐波。在输入信号的频率变化不大的情况下，可以使用带通滤波器把基波过滤出来，就得到了正弦波。 输入信号的频率变化较大：折线法 使用电子开关，在不同段使用不同的比例系数。 例 负载可接地的压控电流源 输入先是一个同相求和运算电路以把电压跟随器从\\(R_\\mathrm{O}\\)反馈回来的电压与输入电压相加，使得\\(R_\\mathrm{O}\\)两端的电压恰好为\\(u_\\mathrm{I}\\)，虽然引入了正反馈，但是电路没有失控。 \\[u_{01}=u_{1}+u_{0} \\Rightarrow i_{0}=\\frac{u_{01}-u_{0}}{R_{0}}=i_{0}=\\frac{u_{1}}{R_{0}}\\] 相比于简单的电流并联负反馈电路或电流串联负反馈电路而言，负载可以接地，更安全： 压控锯齿波发生器 设三极管的饱和管压降为0： 分析滞回比较器可以得到： \\[\\begin{aligned} u_{0}\u0026=\\pm U_{z} \\\\ \\pm U_{T}\u0026=\\pm \\frac{U_{Z}}{2} \\end{aligned}\\] 滞回比较器的输出就影响着三极管的导通。接着分析积分运算电路可以得到： \\(T\\)截止时： \\[u_{01}=\\frac{1}{R_{1} C} \\cdot \\frac{u_{1}}{3}\\left(t_{1}-t_{0}\\right)+u_{01}\\left(t_{0}\\right)\\] \\(T\\)导通时： \\[u_{01}=-\\frac{1}{R_{1} C} \\cdot \\frac{u_{1}}{3}\\left(t_{1}-t_{0}\\right)+u_{01}\\left(t_{0}\\right)\\] 注意，由于无论三极管导通还是截止，流过\\(C\\)的电流都是一样的（\\(R_1\\)和\\(R_2\\)设计的巧妙之处），因此两个式子只差一个负号。通过上面两个式子可以得到： \\[f=\\frac{u_{1}}{6 R_{1} C U_{\\mathrm{z}}}\\] 输出的波形图为： 交流有效值电压表 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:8:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#波形变换电路"},{"categories":null,"content":"整流电路 单相半波整流电路 \\(u_2\\)的正半周：二极管导通 \\(u_2\\)的负半周：二极管截止波形图为： 先通过面积对电压的平均值： \\[U_{O(A V)}=\\frac{1}{2 \\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{\\sqrt{2} U_{2}}{\\pi} \\approx 0.45 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{O(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.45 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times \\frac{0.45U_2}{R_L} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 单相桥式整流电路 二极管的接法： 从负载角度看 电流是变化地往同一个方向流，因此一端是两支二极管的阴极，一端是两支二极管的阳极。 从变压器的角度看 一端既要流入，又要流出，因此两端应分别接两支二极管的阴极和阳极。分析电流的流向： \\(u_2\\)的正半周：\\(D_1,D_3\\)导通，\\(D_2,D_4\\)截止 \\(u_2\\)的负半周：\\(D_2,D_4\\)导通，\\(D_1,D_3\\)截止得到波形图： 通过面积求平均值： \\[U_{0(A V)}=\\frac{1}{\\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{2 \\sqrt{2} U_{2}}{\\pi} \\approx 0.9 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{0(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.9 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件，与单相半波整流电路相同： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times\\frac{0.45U_2}{R_\\mathrm{L}} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 精密整流电路 需要对小信号进行整流，而一般的整流电路无法做到： 半波精密整流电路 之所以被称为精密整流，是因为这个电路在输入电压很小的情况下，可以使得二极管导通。在运放的作用下，二极管的导通电压要除以开环放大倍数（理想运放为无穷），使得二极管很容易导通。 \\(u_\\mathrm{I}\u003e0\\) 由于输入在反相输入端，因此输出的电压是负的，判断出\\(D_2\\)导通，\\(D_1\\)截止，电流\\(\\frac{u_\\mathrm{I}}{R}\\)通过\\(R_\\mathrm{f}\\)流向输出，因此输出电压也为\\(u_\\mathrm{I}\\)。 \\(u_\\mathrm{I}\u003c0\\) \\(D_1\\)导通，\\(D_2\\)截止，引入了负反馈，\\(u_\\mathrm{O}^\\prime\\)电压的升高会带动反相输入端电位的升高，相当于电压跟随器，输出电压为0。由于反馈电流的是动态电流而不是真实电流，因此二极管和电阻一样，可以引入负反馈。整流后的波形为： 全波精密整流电路 半波精密整流电路中的\\(R_\\mathrm{f}\\)变为了\\(2R\\)，以便加倍输出电压： \\[u_\\mathrm{O1}=\\begin{cases} -2u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0\\\\ 0,\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 通过反相求和运算电路与原信号相加可以得到： \\[u_\\mathrm{O}=-u_\\mathrm{O1}-u_\\mathrm{I}=\\begin{cases} u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0 \\\\ -u_\\mathrm{I},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\Rightarrow u_\\mathrm{O}=\\left|u_\\mathrm{I}\\right|\\] 因此该电路也可以作为绝对值运算电路。 该电路可以将三角波二倍频： 输出的三角波是有直流分量的，可以通过下面这个电路去除： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:8:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#整流电路"},{"categories":null,"content":"整流电路 单相半波整流电路 \\(u_2\\)的正半周：二极管导通 \\(u_2\\)的负半周：二极管截止波形图为： 先通过面积对电压的平均值： \\[U_{O(A V)}=\\frac{1}{2 \\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{\\sqrt{2} U_{2}}{\\pi} \\approx 0.45 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{O(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.45 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times \\frac{0.45U_2}{R_L} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 单相桥式整流电路 二极管的接法： 从负载角度看 电流是变化地往同一个方向流，因此一端是两支二极管的阴极，一端是两支二极管的阳极。 从变压器的角度看 一端既要流入，又要流出，因此两端应分别接两支二极管的阴极和阳极。分析电流的流向： \\(u_2\\)的正半周：\\(D_1,D_3\\)导通，\\(D_2,D_4\\)截止 \\(u_2\\)的负半周：\\(D_2,D_4\\)导通，\\(D_1,D_3\\)截止得到波形图： 通过面积求平均值： \\[U_{0(A V)}=\\frac{1}{\\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{2 \\sqrt{2} U_{2}}{\\pi} \\approx 0.9 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{0(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.9 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件，与单相半波整流电路相同： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times\\frac{0.45U_2}{R_\\mathrm{L}} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 精密整流电路 需要对小信号进行整流，而一般的整流电路无法做到： 半波精密整流电路 之所以被称为精密整流，是因为这个电路在输入电压很小的情况下，可以使得二极管导通。在运放的作用下，二极管的导通电压要除以开环放大倍数（理想运放为无穷），使得二极管很容易导通。 \\(u_\\mathrm{I}\u003e0\\) 由于输入在反相输入端，因此输出的电压是负的，判断出\\(D_2\\)导通，\\(D_1\\)截止，电流\\(\\frac{u_\\mathrm{I}}{R}\\)通过\\(R_\\mathrm{f}\\)流向输出，因此输出电压也为\\(u_\\mathrm{I}\\)。 \\(u_\\mathrm{I}\u003c0\\) \\(D_1\\)导通，\\(D_2\\)截止，引入了负反馈，\\(u_\\mathrm{O}^\\prime\\)电压的升高会带动反相输入端电位的升高，相当于电压跟随器，输出电压为0。由于反馈电流的是动态电流而不是真实电流，因此二极管和电阻一样，可以引入负反馈。整流后的波形为： 全波精密整流电路 半波精密整流电路中的\\(R_\\mathrm{f}\\)变为了\\(2R\\)，以便加倍输出电压： \\[u_\\mathrm{O1}=\\begin{cases} -2u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0\\\\ 0,\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 通过反相求和运算电路与原信号相加可以得到： \\[u_\\mathrm{O}=-u_\\mathrm{O1}-u_\\mathrm{I}=\\begin{cases} u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0 \\\\ -u_\\mathrm{I},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\Rightarrow u_\\mathrm{O}=\\left|u_\\mathrm{I}\\right|\\] 因此该电路也可以作为绝对值运算电路。 该电路可以将三角波二倍频： 输出的三角波是有直流分量的，可以通过下面这个电路去除： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:8:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#单相半波整流电路"},{"categories":null,"content":"整流电路 单相半波整流电路 \\(u_2\\)的正半周：二极管导通 \\(u_2\\)的负半周：二极管截止波形图为： 先通过面积对电压的平均值： \\[U_{O(A V)}=\\frac{1}{2 \\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{\\sqrt{2} U_{2}}{\\pi} \\approx 0.45 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{O(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.45 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times \\frac{0.45U_2}{R_L} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 单相桥式整流电路 二极管的接法： 从负载角度看 电流是变化地往同一个方向流，因此一端是两支二极管的阴极，一端是两支二极管的阳极。 从变压器的角度看 一端既要流入，又要流出，因此两端应分别接两支二极管的阴极和阳极。分析电流的流向： \\(u_2\\)的正半周：\\(D_1,D_3\\)导通，\\(D_2,D_4\\)截止 \\(u_2\\)的负半周：\\(D_2,D_4\\)导通，\\(D_1,D_3\\)截止得到波形图： 通过面积求平均值： \\[U_{0(A V)}=\\frac{1}{\\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{2 \\sqrt{2} U_{2}}{\\pi} \\approx 0.9 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{0(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.9 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件，与单相半波整流电路相同： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times\\frac{0.45U_2}{R_\\mathrm{L}} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 精密整流电路 需要对小信号进行整流，而一般的整流电路无法做到： 半波精密整流电路 之所以被称为精密整流，是因为这个电路在输入电压很小的情况下，可以使得二极管导通。在运放的作用下，二极管的导通电压要除以开环放大倍数（理想运放为无穷），使得二极管很容易导通。 \\(u_\\mathrm{I}\u003e0\\) 由于输入在反相输入端，因此输出的电压是负的，判断出\\(D_2\\)导通，\\(D_1\\)截止，电流\\(\\frac{u_\\mathrm{I}}{R}\\)通过\\(R_\\mathrm{f}\\)流向输出，因此输出电压也为\\(u_\\mathrm{I}\\)。 \\(u_\\mathrm{I}\u003c0\\) \\(D_1\\)导通，\\(D_2\\)截止，引入了负反馈，\\(u_\\mathrm{O}^\\prime\\)电压的升高会带动反相输入端电位的升高，相当于电压跟随器，输出电压为0。由于反馈电流的是动态电流而不是真实电流，因此二极管和电阻一样，可以引入负反馈。整流后的波形为： 全波精密整流电路 半波精密整流电路中的\\(R_\\mathrm{f}\\)变为了\\(2R\\)，以便加倍输出电压： \\[u_\\mathrm{O1}=\\begin{cases} -2u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0\\\\ 0,\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 通过反相求和运算电路与原信号相加可以得到： \\[u_\\mathrm{O}=-u_\\mathrm{O1}-u_\\mathrm{I}=\\begin{cases} u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0 \\\\ -u_\\mathrm{I},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\Rightarrow u_\\mathrm{O}=\\left|u_\\mathrm{I}\\right|\\] 因此该电路也可以作为绝对值运算电路。 该电路可以将三角波二倍频： 输出的三角波是有直流分量的，可以通过下面这个电路去除： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:8:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#单相桥式整流电路"},{"categories":null,"content":"整流电路 单相半波整流电路 \\(u_2\\)的正半周：二极管导通 \\(u_2\\)的负半周：二极管截止波形图为： 先通过面积对电压的平均值： \\[U_{O(A V)}=\\frac{1}{2 \\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{\\sqrt{2} U_{2}}{\\pi} \\approx 0.45 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{O(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.45 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times \\frac{0.45U_2}{R_L} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 单相桥式整流电路 二极管的接法： 从负载角度看 电流是变化地往同一个方向流，因此一端是两支二极管的阴极，一端是两支二极管的阳极。 从变压器的角度看 一端既要流入，又要流出，因此两端应分别接两支二极管的阴极和阳极。分析电流的流向： \\(u_2\\)的正半周：\\(D_1,D_3\\)导通，\\(D_2,D_4\\)截止 \\(u_2\\)的负半周：\\(D_2,D_4\\)导通，\\(D_1,D_3\\)截止得到波形图： 通过面积求平均值： \\[U_{0(A V)}=\\frac{1}{\\pi} \\int_{0}^{\\pi} \\sqrt{2} U_{2} \\sin \\omega \\operatorname{td}(\\omega t)\\] 即可估算出\\(U_\\mathrm{O(AV)}\\)和\\(I_\\mathrm{L(AV)}\\)： \\[\\begin{aligned} U_{0(A V)}\u0026=\\frac{2 \\sqrt{2} U_{2}}{\\pi} \\approx 0.9 U_{2} \\\\ I_{L(A V)}\u0026=\\frac{U_{0(A V)}}{R_{\\mathrm{L}}} \\approx \\frac{0.9 U_{2}}{R_{\\mathrm{L}}} \\end{aligned}\\] 得到二极管的极限工作条件，与单相半波整流电路相同： \\[\\begin{aligned} U_\\mathrm{R\\max}\u0026=\\sqrt{2}U_2 \\\\ I_\\mathrm{D(AV)}\u0026=\\frac{I_\\mathrm{L(AV)}}{2}=\\approx \\frac{0.45U_2}{R_\\mathrm{L}} \\end{aligned}\\] 由于电网电压波动为\\(\\pm 10\\%\\)，二极管的参数应满足： \\[\\begin{cases} I_\\mathrm{F}\u0026\u003e1.1\\times\\frac{0.45U_2}{R_\\mathrm{L}} \\\\ U_\\mathrm{R}\u0026\u003e1.1\\sqrt{2}U_2 \\end{cases}\\] 精密整流电路 需要对小信号进行整流，而一般的整流电路无法做到： 半波精密整流电路 之所以被称为精密整流，是因为这个电路在输入电压很小的情况下，可以使得二极管导通。在运放的作用下，二极管的导通电压要除以开环放大倍数（理想运放为无穷），使得二极管很容易导通。 \\(u_\\mathrm{I}\u003e0\\) 由于输入在反相输入端，因此输出的电压是负的，判断出\\(D_2\\)导通，\\(D_1\\)截止，电流\\(\\frac{u_\\mathrm{I}}{R}\\)通过\\(R_\\mathrm{f}\\)流向输出，因此输出电压也为\\(u_\\mathrm{I}\\)。 \\(u_\\mathrm{I}\u003c0\\) \\(D_1\\)导通，\\(D_2\\)截止，引入了负反馈，\\(u_\\mathrm{O}^\\prime\\)电压的升高会带动反相输入端电位的升高，相当于电压跟随器，输出电压为0。由于反馈电流的是动态电流而不是真实电流，因此二极管和电阻一样，可以引入负反馈。整流后的波形为： 全波精密整流电路 半波精密整流电路中的\\(R_\\mathrm{f}\\)变为了\\(2R\\)，以便加倍输出电压： \\[u_\\mathrm{O1}=\\begin{cases} -2u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0\\\\ 0,\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\] 通过反相求和运算电路与原信号相加可以得到： \\[u_\\mathrm{O}=-u_\\mathrm{O1}-u_\\mathrm{I}=\\begin{cases} u_\\mathrm{I},\u0026u_\\mathrm{I}\u003e0 \\\\ -u_\\mathrm{I},\u0026u_\\mathrm{I}\u003c0 \\end{cases}\\Rightarrow u_\\mathrm{O}=\\left|u_\\mathrm{I}\\right|\\] 因此该电路也可以作为绝对值运算电路。 该电路可以将三角波二倍频： 输出的三角波是有直流分量的，可以通过下面这个电路去除： ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:8:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#精密整流电路"},{"categories":null,"content":"功率放大电路 性能指标 \\(P_\\mathrm{om}=\\frac{U_\\mathrm{om}^2}{R_\\mathrm{L}}\\)：最大输出功率 \\(U_\\mathrm{om}\\)：最大不失真输出电压（有效值，非最大值） \\(\\eta=\\frac{P_\\mathrm{om}}{P_\\mathrm{V(AV)}}\\)：电源效率 \\(P_\\mathrm{V(AV)}\\)：电源输入的平均功率 分析方法 由于要分析最大不失真输出电压，肯定不是小信号，之前的小信号等效电路如h参数等效模型、混合\\(\\Pi\\)模型等均不可用。分析功率放大电路应采用图解法。 要求 输出功率尽可能大 即在电源电压一定的情况下，最大不失真输出电压最大。 效率尽可能高 即电路损耗的直流功率尽可能小，静态时功放管的集电极电流近似为0。 晶体管 选用 根据极限参数选择晶体管。求最大功率是，要让放大电路工作在尽限状态： 集电极或发射极电流的最大值接近最大集电极电流\\(I_\\mathrm{CM}\\)。 管压降的最大值接近c-e反向击穿电压\\(U_\\mathrm{(BR)CEO}\\) 集电极消耗功率的最大值接近集电极最大耗散功率\\(P_\\mathrm{CM}\\) 工作方式 甲类方式 晶体管在信号的整个周期内均处于导通状态，上电就有静态电流，效率低。 乙类方式 晶体管仅在信号的半个周期处于导通状态，如多级放大电路互补输出级。 甲乙类方式 晶体管在信号的多半个周期处于导通状态，如在多级放大电路的互补输出级消除交越失真。 种类 种类 特点 变压器耦合功率放大电路 传统功放，应用至今 OTL 电路 (Output Trasfomerless) 无变压器，有大电容 OCL电路 (Output Capacitorless) 无大电容，但双电源供电 BTL 电路 (Balanced Transformerless) 单电源供电，管子多 例 读图 下图是一个音频功率放大电路： 放大部分 组成 集成运放 复合管组成的OCL电路 参数估算 \\(\\dot{A}_{u} \\approx=-\\frac{R_2}{R_1}=-10\\) \\(U_{\\text {om }}=\\frac{V_{\\mathrm{CC}}-U_{\\mathrm{CES}}}{\\sqrt{2}} \\cdot \\frac{R_{\\mathrm{L}}}{R_{8}+R_{\\mathrm{L}}}\\) 如果要输出最大功率，输入电压就必须满足： \\[U_{\\mathrm{i}}=\\frac{U_{0 \\mathrm{~m}}}{\\left|\\dot{A}_{u}\\right|}\\] \\(P_{\\mathrm{om}}=\\frac{U_{\\mathrm{om}}^{2}}{R_{\\mathrm{L}}}\\) \\(\\eta=\\frac{\\pi}{4} \\cdot \\frac{\\sqrt{2} U_{\\mathrm{om}}}{V_{\\mathrm{CC}}}\\) 反馈部分 级间电压并联负反馈（电路输出到输入） 其余部分 \\(D_1\\sim D_3, R_\\mathrm{W}\\)：消除交越失真 \\(C_1\\)：耦合电容 \\(C_2\\)：滞后补偿（密勒补偿） 电路中存在旁路电容、复合管的结电容，可能引起自激振荡。 \\(C_3\\sim C_4\\)：旁路电容 \\(T_1,T_2,R_7,R_8\\)：过流保护 当输出电流过大时，采样电阻\\(R_7,R_8\\)上分压使得\\(T_1,T_2\\)导通，从而把输入分流，减小输出电流。 \\(R_5,R_6\\)：泄露电阻 功放管的穿透电流较大，复合管之间串联泄露电阻使得穿透电流尽可能少流向下一级。 故障分析 \\(R_2\\)短路 导致\\(u_\\mathrm{O}V_\\mathrm{CC}-u_\\mathrm{BE1}-u_\\mathrm{BE2}\\) \\(R_2\\)断路 导致\\(D_2\\)的阴极和\\(T_2\\)的发射极可以视为断路，电路结构发生改变： 变成共射放大电路，\\(\\beta\\approx\\beta_5\\beta_3\\beta_4\\)，复合管的工作状态决定故障现象： 放大状态：功耗过大而烧坏 饱和状态：\\(u_\\mathrm{O}=U_\\mathrm{ECS3}+U_\\mathrm{BE4}\\) \\(D_1\\)短路 影响消除交越失真。 \\(D_1\\)断路 电源电压直接加在四个三极管的发射结上，功放管将损坏。 \\(T_1\\)集电极开路 \\(T_1,T_2\\)复合管的放大倍数减小，正负半周波形将不对称。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#功率放大电路"},{"categories":null,"content":"变压器耦合功率放大电路 单管甲类电路 使用图解法分析： 这里管压降会大于电源电压的原因是电感线圈产生的感应电动势可能与电源的输出叠加。电源的输入和输出是交流信号，当输入信号增大时： 输出功率增大 平均电流不变 电源功率不变 电源效率变高也就是说要想得到最大的电源效率，必须使输入信号最大。 乙类推挽电路 需要2个变压器和2个理想对称的晶体管。在理想情况下，信号的正半周\\(T_1\\)导通、\\(T_2\\)截止；负半周\\(T_2\\)导通、\\(T_1\\)截止。两只管子交替工作，称为“推挽 ”。静态时集电极电流为零，也就是静态时损耗为零，输入信号越大，电源提供的功率也越大。 理想情况下，最大不失真电压为： \\[U_\\mathrm{om}=\\frac{V_\\mathrm{CC}-U_\\mathrm{CES}}{\\sqrt{2}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#变压器耦合功率放大电路"},{"categories":null,"content":"变压器耦合功率放大电路 单管甲类电路 使用图解法分析： 这里管压降会大于电源电压的原因是电感线圈产生的感应电动势可能与电源的输出叠加。电源的输入和输出是交流信号，当输入信号增大时： 输出功率增大 平均电流不变 电源功率不变 电源效率变高也就是说要想得到最大的电源效率，必须使输入信号最大。 乙类推挽电路 需要2个变压器和2个理想对称的晶体管。在理想情况下，信号的正半周\\(T_1\\)导通、\\(T_2\\)截止；负半周\\(T_2\\)导通、\\(T_1\\)截止。两只管子交替工作，称为“推挽 ”。静态时集电极电流为零，也就是静态时损耗为零，输入信号越大，电源提供的功率也越大。 理想情况下，最大不失真电压为： \\[U_\\mathrm{om}=\\frac{V_\\mathrm{CC}-U_\\mathrm{CES}}{\\sqrt{2}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#单管甲类电路"},{"categories":null,"content":"变压器耦合功率放大电路 单管甲类电路 使用图解法分析： 这里管压降会大于电源电压的原因是电感线圈产生的感应电动势可能与电源的输出叠加。电源的输入和输出是交流信号，当输入信号增大时： 输出功率增大 平均电流不变 电源功率不变 电源效率变高也就是说要想得到最大的电源效率，必须使输入信号最大。 乙类推挽电路 需要2个变压器和2个理想对称的晶体管。在理想情况下，信号的正半周\\(T_1\\)导通、\\(T_2\\)截止；负半周\\(T_2\\)导通、\\(T_1\\)截止。两只管子交替工作，称为“推挽 ”。静态时集电极电流为零，也就是静态时损耗为零，输入信号越大，电源提供的功率也越大。 理想情况下，最大不失真电压为： \\[U_\\mathrm{om}=\\frac{V_\\mathrm{CC}-U_\\mathrm{CES}}{\\sqrt{2}}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#乙类推挽电路"},{"categories":null,"content":"OTL电路 全称推挽式无输出变压器功率放大电路（Output Trasfomerless）。 两个晶体管必须理想对称，并且如果要获得最大的输出电压，前级必须为其设置合适的静态工作点，使\\(U_\\mathrm{BQ}=\\frac{V_\\mathrm{CC}}{2}\\)，这样在静态时，电容的电压就是\\(\\frac{V_\\mathrm{CC}}{2}\\)，在信号的正负半周，电流的流向如上图所示。在信号的正半周，电容充电，而在信号的负半周，电容放电，因此电流流向是从电容正极流向地，再从地回到电容负极。假设电容在充放电过程中电压保持不变： \\[U_\\mathrm{om}=\\frac{\\frac{V_\\mathrm{CC}}{2}-U_\\mathrm{CES}}{\\sqrt 2}\\] OTL电路只需要单电源，这个电容就相当于临时的电源，给在负半周的信号使用，因此希望该电容越大越好，以在放电时电压保持不变，但是电解电容在做大的同时可能会增加它的电阻和电感值，因此OTL低频特性较差。 应用电路 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#otl电路"},{"categories":null,"content":"OCL电路 使用直接耦合取代OTL电路的阻容耦合，使用双电源供电，两只管子交替导通，两路电源交替供电，双向跟随，低频特性好。最大不失真输出电压为： \\[U_\\mathrm{om}=\\frac{V_\\mathrm{CC}-U_\\mathrm{CES}}{\\sqrt 2}\\] 例 电源效率的估算 可以算出最大输出功率： \\[\\begin{aligned} U_{o m}\u0026=\\frac{V_{\\mathrm{CC}}-U_{\\mathrm{CES}}}{\\sqrt{2}} \\\\ P_{\\mathrm{om}}\u0026=\\frac{\\left(V_{\\mathrm{CC}}-U_{\\mathrm{CES}}\\right)^{2}}{2 R_{\\mathrm{L}}} \\end{aligned}\\] 然后计算通过积分再求平均的方式计算平均输入功率： \\[\\begin{aligned} P_{V} \u0026=\\frac{1}{\\pi} \\int_{0}^{\\pi} \\frac{V_{\\mathrm{CC}}-U_{\\mathrm{CES}}}{R_{\\mathrm{L}}} \\cdot \\sin \\omega t \\cdot V_{\\mathrm{CC}} d(\\omega t) \\\\ \u0026=\\frac{2}{\\pi} \\cdot \\frac{V_{\\mathrm{CC}}\\left(V_{\\mathrm{CC}}-U_{\\mathrm{CES}}\\right)}{R_{\\mathrm{L}}} \\end{aligned}\\] 即可估算出电源效率： \\[\\eta =\\frac{P_{\\mathrm{om}}}{P_{\\mathrm{V}}}=\\frac{\\pi}{4} \\cdot \\frac{V_{\\mathrm{CC}}-U_{\\mathrm{CES}}}{V_{\\mathrm{CC}}}\\] 晶体管参数选择 \\(I_\\mathrm{CM}\\)和\\(U_\\mathrm{(BR)CEO}\\) 发射极电流最大时，忽略饱和管压降，因此最大发射极电流就是最大能从负载上流过的电流： \\[i_\\mathrm{C\\max}\\approx \\frac{V_\\mathrm{CC}}{R_\\mathrm{L}}\u003cI_\\mathrm{CM}\\] 当一个管子截止，另一个管子饱和，忽略饱和管压降，得到c-e反向击穿电压： \\[u_\\mathrm{CE\\max}\\approx 2V_\\mathrm{CC}\u003cU_\\mathrm{CEO(BR)}\\] \\(P_\\mathrm{cm}\\) 在输出功率最大时，因管压降最小，故管子损耗不大；输出功率最小时，因集电极电流最小，故管子损耗也不大。因此在饱和区和截止区之间，应存在一点使得管子的耗散功率最大，可以列出函数关系，求极值： \\[P_{\\mathrm{T}} \\approx \\frac{1}{2 \\pi} \\int_{0}^{\\pi}\\left(V_{\\mathrm{CC}}-U_{\\mathrm{OM}} \\sin \\omega t\\right) \\cdot \\frac{U_{\\mathrm{OM}} \\sin \\omega t}{R_{\\mathrm{L}}} \\mathrm{d} \\omega t\\] 其中： \\(\\left(V_{\\mathrm{CC}}-U_{\\mathrm{OM}} \\sin \\omega t\\right)\\)：管压降 \\(\\frac{U_{\\mathrm{OM}} \\sin \\omega t}{R_{\\mathrm{L}}}\\)：发射极电流 \\(U_\\mathrm{OM}\\) 这里应该就是输出电压，而不是最大输出电压。因为求导最根本的自变量应当是输入电压\\(u_\\mathrm{i}\\)，不一定能使输出电压最大。 \\(P_\\mathrm{T}\\)对\\(U_\\mathrm{OM}\\)求导，令导数为0，得： \\[U_{\\text {Oм}}=\\frac{2}{\\pi} \\cdot V_{\\mathrm{CC}} \\approx 0.6 V_{\\mathrm{CC}}\\] 将\\(U_\\mathrm{OM}\\)代入\\(P_\\mathrm{T}\\)表达式，得： \\[P_{\\mathrm{Tmax}}=\\frac{V_{\\mathrm{CC}}^{2}}{\\pi^{2} R_{L}}\\] 若\\(U_{\\text {CES }}=0\\)，则： \\[P_{\\mathrm{om}}=\\frac{V_{\\mathrm{CC}}^{2}}{2 R_{\\mathrm{L}}}\\Rightarrow P_{\\mathrm{T}\\max}=\\left.\\left.\\frac{2}{\\pi^{2}} \\cdot P_{o m}\\right|_{U_{\\mathrm{CEs}}=0} \\approx 0.2 P_{o m}\\right|_{U_{\\mathrm{CEs}}=0}\\] 综上，选择晶体管的参数应满足： \\[\\left\\{\\begin{array}{l} I_{\\mathrm{CM}}\u003ei_{\\mathrm{Cmax}} \\approx \\frac{V_{\\mathrm{CC}}}{R_{\\mathrm{L}}} \\\\ U_{\\mathrm{CEO}(\\mathrm{BR})}\u003eu_{\\mathrm{CE} \\max } \\approx 2 V_{\\mathrm{CC}} \\\\ P_{\\mathrm{CM}}\u003eP_{\\mathrm{Tmax}} \\approx 0.2 \\times \\frac{V_{\\mathrm{CC}}^{2}}{2 R_{\\mathrm{L}}} \\end{array}\\right.\\] ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#ocl电路"},{"categories":null,"content":"BTL电路 是双端输入、双端输出形式，输入信号、负载电阻均无接地点，并且管子多，损耗大，效率低。最大不失真输出电压为： \\[U_\\mathrm{om}=\\frac{V_\\mathrm{CC}-2U_\\mathrm{CES}}{\\sqrt 2}\\] 应用电路 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:4","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#btl电路"},{"categories":null,"content":"集成功率放大电路 种类 OTL OCL BTL 电路结构 双极型电路 双极型 单极型混合电路（VMOS管广泛应用） 特点 常内部引入负反馈，增益可调，失真度低。 主要参数 最大输出功率/W 输入阻抗/kΩ 总谐波失真/%或dB 电源电压范围/V 电源静态电流/mA 电压增益/dB频带宽/kHz ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:9:5","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#集成功率放大电路"},{"categories":null,"content":"稳压电路 性能指标 输出电压 在电网电压最低且负载电流最大的情况下，最大可输出的电压。 输出电流 在输出电压范围内的电压，均可输出的最大电流。 稳压系数 表明电网电压波动时电路的稳压性能，是在负载电流不变时，输出电压相对变化量与输入电压变化量之比： \\[S_{\\mathrm{r}}=\\left.\\frac{\\Delta U_{o} / U_{o}}{\\Delta U_{I} / U_{\\mathrm{I}}}\\right|_{R_{\\mathrm{L}}}=\\left.\\frac{\\Delta U_{o}}{\\Delta U_{\\mathrm{I}}} \\cdot \\frac{U_{\\mathrm{I}}}{U_{\\mathrm{o}}}\\right|_{R_{\\mathrm{L}}}\\] 输出电阻 表明负载电流变化时电路的稳压性能，是在电网电压不变时，负载变化引起的输出电压的变化量与输出电流的变化量之比： \\[R_\\mathrm{o}=\\left.\\left|\\frac{\\Delta U_\\mathrm{O}}{\\Delta I_\\mathrm{O}}\\right|\\right|_{U_1}\\] 纹波电压 输出电压的交流分量，通常由测试得出。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#稳压电路"},{"categories":null,"content":"稳压管稳压电路 稳压原理 \\[\\begin{cases} U_\\mathrm{I}=U_\\mathrm{R}+U_\\mathrm{O}\\\\ U_\\mathrm{R}=U_\\mathrm{D_z}+I_\\mathrm{L} \\end{cases}\\] 电网电压变化 假设电网电压上升，则\\(U_{\\mathrm{I}} \\uparrow \\rightarrow U_{\\mathrm{o}} \\uparrow\\left(U_{\\mathrm{Z}}\\right) \\uparrow \\rightarrow I_{\\mathrm{D}_{z}} \\uparrow \\rightarrow I_{R} \\uparrow \\rightarrow U_{R} \\uparrow \\rightarrow U_{\\mathrm{o}} \\downarrow\\)。 负载发生变化 假设负载电阻变小，则\\(\\left\\{\\begin{array}{l} R_{\\mathrm{L}} \\downarrow \\rightarrow U_{o} \\downarrow\\left(U_{\\mathrm{Z}} \\downarrow\\right) \\rightarrow I_{\\mathrm{D}_{\\mathrm{Z}}} \\downarrow \\rightarrow I_{R} \\downarrow \\\\ R_{\\mathrm{L}} \\downarrow \\rightarrow I_{\\mathrm{L}} \\uparrow \\rightarrow I_{R} \\uparrow \\end{array}\\right.\\) 性能指标 输出电压 \\[U_{\\mathrm{O}}=U_{\\mathrm{Z}}\\] 输出电流 \\[I_{\\mathrm{Lmax}}-I_{\\mathrm{Lmin}} \\leq I_{\\mathrm{ZM}}-I_{\\mathrm{Z}}\\] 也就是负载电流的变化范围要在稳压管的最大稳定电流和最小稳压电流之间。若要求电源能空载，则： \\[I_{\\mathrm{ZM}}\u003eI_{\\mathrm{Lmax}}+I_{\\mathrm{Z}}\\] 稳压系数 \\[S_{\\mathrm{r}}=\\left.\\frac{\\Delta U_{\\mathrm{O}}}{\\Delta U_{\\mathrm{I}}} \\cdot \\frac{U_{\\mathrm{I}}}{U_{\\mathrm{o}}}\\right|_{R_{\\mathrm{L}}}=\\frac{r_{\\mathrm{z}} / / R_{\\mathrm{L}}}{R+r_{\\mathrm{z}} / / R_{\\mathrm{L}}} \\cdot \\frac{U_{\\mathrm{I}}}{U_{\\mathrm{o}}} \\approx \\frac{r_{\\mathrm{z}}}{R} \\cdot \\frac{U_{\\mathrm{I}}}{U_{\\mathrm{o}}}\\] 越小越好。 输出电阻 \\[R_{\\mathrm{o}}=r_{\\mathrm{z}} / / R \\approx r_{\\mathrm{z}}\\] 小功率稳压管\\(r_\\mathrm{z}\\)为十几～上百欧姆 参数选择 思路 选择稳压管： \\(U_\\mathrm{Z}=U_\\mathrm{O}\\) \\(I_\\mathrm{ZM}-I_\\mathrm{Z}\u003eI_\\mathrm{L\\max}-I_\\mathrm{L\\min}\\) \\(r_\\mathrm{z}\\approx R_\\mathrm{O}\\) 确定稳压电路的输入电压：\\(U_\\mathrm{I}=2\\sim 3 U_\\mathrm{Z}\\) 求限流电阻： 通过稳压二极管电流满足： \\[\\begin{cases} I_{D_{z}\\min} \u003eI_{\\mathrm{z}} \\\\ I_{D_{z}\\max} \u003c I_{\\mathrm{ZM}} \\end{cases}\\] 电网电压最低且负载电流最大时，稳压管的电流最小： \\[I_{\\mathrm{D}_{\\mathrm{z}} \\min }=\\frac{U_{\\mathrm{Imin}}-U_{\\mathrm{Z}}}{R}-I_{\\mathrm{Lmax}}\u003eI_{\\mathrm{Z}} \\Rightarrow R\u003c\\frac{U_{\\mathrm{Imin}}-U_{\\mathrm{Z}}}{I_{\\mathrm{Z}}+I_{\\mathrm{Lmax}}}\\] 电网电压最高且负载电流最小时，稳压管的电流最大： \\[I_{\\mathrm{D}_{z} \\max }=\\frac{U_{\\mathrm{Imax}}-U_{\\mathrm{Z}}}{R}-I_{\\mathrm{Lmin}}\u003cI_{\\mathrm{ZM}} \\Rightarrow R\u003e\\frac{U_{\\operatorname{Imax}}-U_{\\mathrm{Z}}}{I_{\\mathrm{ZM}}+I_{\\mathrm{Lmin}}}\\] 得到限流电阻的范围： \\[\\frac{U_{\\mathrm{Imax}}-U_{\\mathrm{Z}}}{I_{\\mathrm{ZM}}+I_{\\mathrm{Lmin}}}\u003cR\u003c\\frac{U_{\\mathrm{Imin}}-U_{\\mathrm{Z}}}{I_{\\mathrm{Z}}+I_{\\mathrm{Lmax}}}\\] \\(R_{\\min}\u003cR_{\\max}\\) 根据稳压系数的计算公式，应当选\\(R_{\\max}\\)。 \\(R_{\\min}\u003eR_{\\max}\\) 如果求出来\\(\\frac{U_{\\mathrm{Imax}}-U_{\\mathrm{Z}}}{I_{\\mathrm{ZM}}+I_{\\mathrm{Lmin}}}\u003e\\frac{U_{\\mathrm{Imin}}-U_{\\mathrm{Z}}}{I_{\\mathrm{Z}}+I_{\\mathrm{Lmax}}}\\)，无法确定限流电阻的范围，就应当重新选择稳压管，增大\\(I_\\mathrm{Z}\\)。 求电容滤波电路的负载，确定电容：限流电阻上流过的电流： \\[I_\\mathrm{R}=\\left(U_\\mathrm{I}-U_\\mathrm{Z}\\right)/R\\] 等效负载为： \\[\\Rightarrow R_\\mathrm{L}^\\prime=U_\\mathrm{I}/I_\\mathrm{R}\\] 求出变压器的输出电压：\\(U_2=\\frac{U_I}{1.2}\\) 选择单相桥式整流电路中的整流二极管 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:1","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#稳压管稳压电路"},{"categories":null,"content":"串联型稳压电路 例 同相输入端和反相输入端分别是运算放大器的下端和上端。 \\(T_3\\)与\\(R_0\\)组成了过流保护电路，当输出电流过大时，\\(R_0\\)的分压升高，使得三极管导通，通集成运放的输出分走一部分电流，使输出电流减小，属于限流型保护电路。 由稳压管提供基准电压，\\(R_1\\)和滑动变阻器是采样电阻，通过\\(R_1\\)和滑动变阻器的分压来调整输出电压。注意稳压管只能稳定电压，而不能稳定电位，不然这里的输出就是个恒定值了，应当通过同相输入端的电位，然后根据虚短进行分析。如果滑动变阻器在最上端，那么同相输入端得到的电位就是\\(R_1\\)的分压，也就是\\(U_\\mathrm{Z}\\)。如果滑动变阻器在最下端，那么同相输入端得到的电位就是\\(0\\)，输出电压也是\\(0\\)。 跟踪电源 上方是个 W117 的基本电路，下方由一个PNP型三极管和运算放大器组成的放大电路。由于\\(R_3,R_4\\)之间是虚地，因此\\(U_\\mathrm{R_3}=U_\\mathrm{R_4}=U_\\mathrm{O1}\\)，那么： \\[U_{\\mathrm{O} 1}=-U_{O 2}=U_{\\mathrm{R}} \\sim\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\cdot U_{\\mathrm{R}}\\] \\(T_1\\)的集电极耗散功率最大时，就是输入电压最大，输出电压最小，并且电流也最大的时候，即： \\[\\begin{aligned} U_\\mathrm{CE\\max}\u0026=1.1U_\\mathrm{I2}-U_\\mathrm{R} \\\\ P_\\mathrm{CM}\u003eI_\\mathrm{O\\max}\\cdot U_\\mathrm{CE\\max} \\end{aligned}\\] 基本调整管稳压电路 不管什么原因引起\\(U_\\mathrm{O}\\)变化，都将通过\\(U_\\mathrm{CE}\\)的调节使\\(U_\\mathrm{O}\\)稳定，故称晶体管为调整管。因为调整管串联在输入与输出之间，故称这类电路为串联型稳压电路。基本调整管电路为射极输出器，反馈系数为1。若要提高电路的稳压性能，则应加深电路的负反馈，即提高放大电路的放大倍数。 调整管 参数选择 \\[\\begin{cases} I_\\mathrm{C}\u003cI_\\mathrm{CM}\\\\ U_\\mathrm{CE}\u003cU_\\mathrm{(BR)CEO}\\\\ P_\\mathrm{C}\u003cP_\\mathrm{CM}\\end{cases}\\Rightarrow \\begin{cases} I_{\\operatorname{Emax}}=I_{R 1}+I_{\\operatorname{Lmax}} \\approx I_{\\operatorname{Lmax}}\u003cI_{\\mathrm{CM}} \\\\ U_{\\text {CEmax }}=U_{\\text {Imax }}-U_{\\text {Omin }}\u003cU_{(B R) \\text { CEO }} \\\\ P_{\\operatorname{Tmax}}=I_{\\text {Emax }} U_{\\operatorname{CEmax}}\u003cP_{\\mathrm{CM}} \\end{cases}\\] \\(P_\\mathrm{C}\\)：调整管的耗散功率 \\(U_\\mathrm{(BR)CEO}\\)：c-e间的耐压值 工作状态 必须工作在放大状态且不损坏： 不饱和：\\(U_{O \\max } \\leq U_{\\operatorname{Imin}}-U_{\\mathrm{CES}}=\\mathbf{0 . 9} U_{I}-U_{\\mathrm{CES}}\\) \\(0.9=1.0-0.1\\)：电网电压的波动 不截止、不失控：\\(I_{R_{1}}\u003eI_{C E O}\\) 不过压：\\(U_{O_{\\min }}\u003eU_{\\operatorname{Imax}}-U_{( R) \\mathrm{CEO}}\\) 不过流：\\(I_{O \\max }\u003cI_{\\mathrm{CM}} \\text { 且 } I_{O_{\\max }}\u003cP_{M} / U_{\\mathrm{CEmax}}\\) 具有放大环节的串联型稳压电路 属于同相比例运算电路，输入电压就是稳压管的稳定电压，负反馈回路由\\(R_1,R_2,R_3\\)等输出电压采样电阻构成。 对电路进行瞬时极性分析，假设输出电压增大： 则会导致反相输入端的输入增大，运算放大器的输出减小，调整管的输出电压减小。 调节 \\[U_{o}=\\frac{R_{1}+R_{2}+R_{3}}{R_{2}^{\\prime}+R_{3}} \\cdot U_{Z}\\] 得到： \\[R_2^\\prime\\in[0,R_2]\\Rightarrow \\frac{R_{1}+R_{2}+R_{3}}{R_{2}+R_{3}} \\cdot U_{\\mathrm{z}} \\leq U_{o} \\leq \\frac{R_{1}+R_{2}+R_{3}}{R_{3}} \\cdot U_{\\mathrm{Z}}\\] 取样电阻即不能取得太大，也不能取得太小： 取得过小 电阻消耗功率，电路效率降低。 取得过大 空载时，调整管处于截止状态。由于大功率管的穿透电流很高，电压全部降落在取样电阻上，导致此时的调整管的管压降很小，又近似为饱和状态，此时无论怎么调节取样电阻的阻值，输出电压不会发生太大的变化，电路处于失控状态。 三端稳压器 串联型稳压电路，内部增加了过流、过压、过热保护电路。 基本使用 \\(C_\\mathrm{o}\\) 消除高频噪声。 \\(D\\) 使\\(C_0\\)不通过稳压器放电，保护稳压器。 \\(C_\\mathrm{i}\\) 抵销长线电感效应，消除自激振荡。 输出电流扩展电路 使用射极输出器进行电流放大： \\[I_\\mathrm{L}=(1+\\beta)(I_\\mathrm{O}-I_\\mathrm{R})\\] 输出的电压为： \\[U_\\mathrm{O}=U_\\mathrm{O}^\\prime +U_\\mathrm{D}-U_\\mathrm{BE}\\] \\(U_\\mathrm{O}^\\prime\\)：三段稳压器的稳定电压若\\(U_\\mathrm{BE}=U_\\mathrm{D}\\)，则\\(U_\\mathrm{O}=U_\\mathrm{O}^\\prime\\)。 输出电压扩展电路 \\[U_{o}=\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\cdot U_{o}^{\\prime}+I_{\\mathrm{w}} R_{2}\\] \\(I_\\mathrm{W}\\) 与三端稳压器参数有关，因此\\(U_\\mathrm{O}\\)也与三段稳压器的参数有关，为几毫安。只有\\(I_\\mathrm{R1}= I_\\mathrm{R2}\\)，才可以得到稳定的输出电压。 基准电压源三端稳压器 调整端电流很小，只有几微安，并且输出一个恒定的基准电压\\(U_\\mathrm{REF}\\)，因此可以很方便地使用输出电压扩展电路对这个基准电压进行倍增，得到想要的输出电压： 最终的输出电压为： \\[U_\\mathrm{O}=\\left(1+\\frac{R_2}{R_1}\\right)\\cdot U_\\mathrm{REF}\\] 可以增加二极管和滤波电容增强电路的稳定性和可靠性： 其中二极管的作用是使电容不通过稳压器放电，保护稳压器；电容\\(C\\)的作用是减小纹波电压。稳压器要正常工作，必须满足： \\[\\begin{cases} \\left(U_\\mathrm{I}-U_\\mathrm{O}\\right)_{\\min}\\leq U_\\mathrm{I}-U_\\mathrm{O}\\leq \\left(U_\\mathrm{I}-U_\\mathrm{O}\\right)_{\\max} \\\\ I_\\mathrm{O\\min}\u003cI_\\mathrm{O}\u003cI_\\mathrm{O\\max} \\end{cases}\\] \\(\\left(U_\\mathrm{I}-U_\\mathrm{O}\\right)_{\\min}\\)：调整管不饱和 \\(\\left(U_\\mathrm{I}-U_\\mathrm{O}\\right)_{\\max}\\)：调整管不过压 \\(I_\\mathrm{O\\min}\\)：调整管不截止、电路不失控 \\(I_\\mathrm{O\\max}\\)：调整管不过流因此\\(R_1\\)具有上限值\\(\\frac{U_\\mathrm{REF}}{I_\\mathrm{O\\min}}\\)，不能让调整管截止。 \\(U_\\mathrm{O}\\)的最大值为\\(0.9U_\\mathrm{I}-\\left(U_\\mathrm{I}-U_\\mathrm{O}\\right)_{\\min}\\)。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#串联型稳压电路"},{"categories":null,"content":"串联型稳压电路 例 同相输入端和反相输入端分别是运算放大器的下端和上端。 \\(T_3\\)与\\(R_0\\)组成了过流保护电路，当输出电流过大时，\\(R_0\\)的分压升高，使得三极管导通，通集成运放的输出分走一部分电流，使输出电流减小，属于限流型保护电路。 由稳压管提供基准电压，\\(R_1\\)和滑动变阻器是采样电阻，通过\\(R_1\\)和滑动变阻器的分压来调整输出电压。注意稳压管只能稳定电压，而不能稳定电位，不然这里的输出就是个恒定值了，应当通过同相输入端的电位，然后根据虚短进行分析。如果滑动变阻器在最上端，那么同相输入端得到的电位就是\\(R_1\\)的分压，也就是\\(U_\\mathrm{Z}\\)。如果滑动变阻器在最下端，那么同相输入端得到的电位就是\\(0\\)，输出电压也是\\(0\\)。 跟踪电源 上方是个 W117 的基本电路，下方由一个PNP型三极管和运算放大器组成的放大电路。由于\\(R_3,R_4\\)之间是虚地，因此\\(U_\\mathrm{R_3}=U_\\mathrm{R_4}=U_\\mathrm{O1}\\)，那么： \\[U_{\\mathrm{O} 1}=-U_{O 2}=U_{\\mathrm{R}} \\sim\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\cdot U_{\\mathrm{R}}\\] \\(T_1\\)的集电极耗散功率最大时，就是输入电压最大，输出电压最小，并且电流也最大的时候，即： \\[\\begin{aligned} U_\\mathrm{CE\\max}\u0026=1.1U_\\mathrm{I2}-U_\\mathrm{R} \\\\ P_\\mathrm{CM}\u003eI_\\mathrm{O\\max}\\cdot U_\\mathrm{CE\\max} \\end{aligned}\\] 基本调整管稳压电路 不管什么原因引起\\(U_\\mathrm{O}\\)变化，都将通过\\(U_\\mathrm{CE}\\)的调节使\\(U_\\mathrm{O}\\)稳定，故称晶体管为调整管。因为调整管串联在输入与输出之间，故称这类电路为串联型稳压电路。基本调整管电路为射极输出器，反馈系数为1。若要提高电路的稳压性能，则应加深电路的负反馈，即提高放大电路的放大倍数。 调整管 参数选择 \\[\\begin{cases} I_\\mathrm{C}","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#基本调整管稳压电路"},{"categories":null,"content":"串联型稳压电路 例 同相输入端和反相输入端分别是运算放大器的下端和上端。 \\(T_3\\)与\\(R_0\\)组成了过流保护电路，当输出电流过大时，\\(R_0\\)的分压升高，使得三极管导通，通集成运放的输出分走一部分电流，使输出电流减小，属于限流型保护电路。 由稳压管提供基准电压，\\(R_1\\)和滑动变阻器是采样电阻，通过\\(R_1\\)和滑动变阻器的分压来调整输出电压。注意稳压管只能稳定电压，而不能稳定电位，不然这里的输出就是个恒定值了，应当通过同相输入端的电位，然后根据虚短进行分析。如果滑动变阻器在最上端，那么同相输入端得到的电位就是\\(R_1\\)的分压，也就是\\(U_\\mathrm{Z}\\)。如果滑动变阻器在最下端，那么同相输入端得到的电位就是\\(0\\)，输出电压也是\\(0\\)。 跟踪电源 上方是个 W117 的基本电路，下方由一个PNP型三极管和运算放大器组成的放大电路。由于\\(R_3,R_4\\)之间是虚地，因此\\(U_\\mathrm{R_3}=U_\\mathrm{R_4}=U_\\mathrm{O1}\\)，那么： \\[U_{\\mathrm{O} 1}=-U_{O 2}=U_{\\mathrm{R}} \\sim\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\cdot U_{\\mathrm{R}}\\] \\(T_1\\)的集电极耗散功率最大时，就是输入电压最大，输出电压最小，并且电流也最大的时候，即： \\[\\begin{aligned} U_\\mathrm{CE\\max}\u0026=1.1U_\\mathrm{I2}-U_\\mathrm{R} \\\\ P_\\mathrm{CM}\u003eI_\\mathrm{O\\max}\\cdot U_\\mathrm{CE\\max} \\end{aligned}\\] 基本调整管稳压电路 不管什么原因引起\\(U_\\mathrm{O}\\)变化，都将通过\\(U_\\mathrm{CE}\\)的调节使\\(U_\\mathrm{O}\\)稳定，故称晶体管为调整管。因为调整管串联在输入与输出之间，故称这类电路为串联型稳压电路。基本调整管电路为射极输出器，反馈系数为1。若要提高电路的稳压性能，则应加深电路的负反馈，即提高放大电路的放大倍数。 调整管 参数选择 \\[\\begin{cases} I_\\mathrm{C}","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#具有放大环节的串联型稳压电路"},{"categories":null,"content":"串联型稳压电路 例 同相输入端和反相输入端分别是运算放大器的下端和上端。 \\(T_3\\)与\\(R_0\\)组成了过流保护电路，当输出电流过大时，\\(R_0\\)的分压升高，使得三极管导通，通集成运放的输出分走一部分电流，使输出电流减小，属于限流型保护电路。 由稳压管提供基准电压，\\(R_1\\)和滑动变阻器是采样电阻，通过\\(R_1\\)和滑动变阻器的分压来调整输出电压。注意稳压管只能稳定电压，而不能稳定电位，不然这里的输出就是个恒定值了，应当通过同相输入端的电位，然后根据虚短进行分析。如果滑动变阻器在最上端，那么同相输入端得到的电位就是\\(R_1\\)的分压，也就是\\(U_\\mathrm{Z}\\)。如果滑动变阻器在最下端，那么同相输入端得到的电位就是\\(0\\)，输出电压也是\\(0\\)。 跟踪电源 上方是个 W117 的基本电路，下方由一个PNP型三极管和运算放大器组成的放大电路。由于\\(R_3,R_4\\)之间是虚地，因此\\(U_\\mathrm{R_3}=U_\\mathrm{R_4}=U_\\mathrm{O1}\\)，那么： \\[U_{\\mathrm{O} 1}=-U_{O 2}=U_{\\mathrm{R}} \\sim\\left(1+\\frac{R_{2}}{R_{1}}\\right) \\cdot U_{\\mathrm{R}}\\] \\(T_1\\)的集电极耗散功率最大时，就是输入电压最大，输出电压最小，并且电流也最大的时候，即： \\[\\begin{aligned} U_\\mathrm{CE\\max}\u0026=1.1U_\\mathrm{I2}-U_\\mathrm{R} \\\\ P_\\mathrm{CM}\u003eI_\\mathrm{O\\max}\\cdot U_\\mathrm{CE\\max} \\end{aligned}\\] 基本调整管稳压电路 不管什么原因引起\\(U_\\mathrm{O}\\)变化，都将通过\\(U_\\mathrm{CE}\\)的调节使\\(U_\\mathrm{O}\\)稳定，故称晶体管为调整管。因为调整管串联在输入与输出之间，故称这类电路为串联型稳压电路。基本调整管电路为射极输出器，反馈系数为1。若要提高电路的稳压性能，则应加深电路的负反馈，即提高放大电路的放大倍数。 调整管 参数选择 \\[\\begin{cases} I_\\mathrm{C}","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:2","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#三端稳压器"},{"categories":null,"content":"开关型稳压电源 调整管工作在开关状态，管压降小，可以提高电源效率。 特点 效率高 开关型稳压电源的效率可达70%~95%。 体积小、重量轻 大负载电流、输出电压小范围调节 串联开关型稳压电路 \\(T,D\\)均工作在开关状态，近似分析时将它们看成理想开关： \\(u_\\mathrm{B}=U_\\mathrm{H}\\) \\(T\\)饱和导通，\\(D\\)截止，\\(u_\\mathrm{E}\\approx U_\\mathrm{I}\\)，\\(L\\)储能，\\(C\\)充电。 \\(u_\\mathrm{B}=U_\\mathrm{L}\\) \\(T\\)截止，\\(D\\)导通，\\(u_\\mathrm{E}=-U_\\mathrm{D}\\)，\\(L\\)释放能量，\\(C\\)放电。 因此\\(U_\\mathrm{O}\u003cU_\\mathrm{I}\\)，为降压型电路。 \\[U_{\\mathrm{o}} \\approx \\frac{T_{\\mathrm{on}}}{T} \\cdot U_{\\mathrm{I}}+\\frac{T_{\\mathrm{off}}}{T} \\cdot\\left(-U_{\\mathrm{D}}\\right) \\approx q U_{\\mathrm{I}}\\] 其中\\(q\\)为占空比。 稳压原理 若某种原因使输出电压升高，则应减小占空比，因此这些方式都是通过调节频率或脉宽来调节占空比的。调整管的开关频率越高越好，可以更方便地进行滤波。 脉冲宽度调制式 在频率不变的情况下更改脉宽调节占空比：\\(U_{o} \\uparrow \\rightarrow T_{\\text {on }} \\downarrow \\rightarrow q \\downarrow \\rightarrow U_{o} \\downarrow\\) 脉冲频率调制式 在脉宽不变的情况下更改频率调节占空比：\\(U_{O} \\uparrow \\rightarrow T \\uparrow \\rightarrow q \\downarrow \\rightarrow U_{o} \\downarrow\\) 混合调制式 同时更改频率和脉宽调节占空比：\\(U_{O} \\uparrow \\rightarrow T \\uparrow T_{n} \\downarrow \\rightarrow q \\downarrow \\rightarrow U_{o} \\downarrow\\) 并联开关型稳压电路 \\(T,D\\)均工作在开关状态，近似分析时将它们看成理想开关： \\(u_\\mathrm{B}=U_\\mathrm{H}\\) \\(T\\)饱和导通，\\(L\\)储能，\\(D\\)截止，\\(C\\)对负载放电。 \\(u_\\mathrm{B}=U_\\mathrm{L}\\) \\(T\\)截止，\\(L\\)产生感生电动势，\\(D\\)导通，\\(U_\\mathrm{I}\\)与\\(L\\)所产生的感生电动势叠加对\\(C\\)充电。 输入直流电压时，\\(L\\)负责升压，而只有\\(C\\)才负责滤波；输入交流电压时，\\(L,C\\)均可用于滤波，因此可以进行整流。在周期不变的情况下，\\(u_\\mathrm{B}\\)占空比越大，电感储能越多，输出电压平均值越高。 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#开关型稳压电源"},{"categories":null,"content":"开关型稳压电源 调整管工作在开关状态，管压降小，可以提高电源效率。 特点 效率高 开关型稳压电源的效率可达70%~95%。 体积小、重量轻 大负载电流、输出电压小范围调节 串联开关型稳压电路 \\(T,D\\)均工作在开关状态，近似分析时将它们看成理想开关： \\(u_\\mathrm{B}=U_\\mathrm{H}\\) \\(T\\)饱和导通，\\(D\\)截止，\\(u_\\mathrm{E}\\approx U_\\mathrm{I}\\)，\\(L\\)储能，\\(C\\)充电。 \\(u_\\mathrm{B}=U_\\mathrm{L}\\) \\(T\\)截止，\\(D\\)导通，\\(u_\\mathrm{E}=-U_\\mathrm{D}\\)，\\(L\\)释放能量，\\(C\\)放电。 因此\\(U_\\mathrm{O}","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#串联开关型稳压电路"},{"categories":null,"content":"开关型稳压电源 调整管工作在开关状态，管压降小，可以提高电源效率。 特点 效率高 开关型稳压电源的效率可达70%~95%。 体积小、重量轻 大负载电流、输出电压小范围调节 串联开关型稳压电路 \\(T,D\\)均工作在开关状态，近似分析时将它们看成理想开关： \\(u_\\mathrm{B}=U_\\mathrm{H}\\) \\(T\\)饱和导通，\\(D\\)截止，\\(u_\\mathrm{E}\\approx U_\\mathrm{I}\\)，\\(L\\)储能，\\(C\\)充电。 \\(u_\\mathrm{B}=U_\\mathrm{L}\\) \\(T\\)截止，\\(D\\)导通，\\(u_\\mathrm{E}=-U_\\mathrm{D}\\)，\\(L\\)释放能量，\\(C\\)放电。 因此\\(U_\\mathrm{O}","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:10:3","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#并联开关型稳压电路"},{"categories":null,"content":"直流电源 组成 电源变压器 改变电压值通常为降压。 整流电路 交流变脉动的直流。 滤波电路 无源的低通滤波，减小脉动。 稳压电路 负载变化输出电压基本不变 电网电压变化输出电压基本不变 ","date":"2022-03-02","objectID":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/:11:0","series":null,"tags":["电子","模拟电路"],"title":"模拟电子技术","uri":"/posts/notes/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/#直流电源"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%AE%97%E6%B3%95/:0:0","series":null,"tags":["编程"],"title":"算法","uri":"/posts/notes/%E7%AE%97%E6%B3%95/#"},{"categories":null,"content":"最佳匹配算法 ","date":"2022-03-02","objectID":"/posts/notes/%E7%AE%97%E6%B3%95/:1:0","series":null,"tags":["编程"],"title":"算法","uri":"/posts/notes/%E7%AE%97%E6%B3%95/#最佳匹配算法"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:0:0","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#"},{"categories":null,"content":"I2S ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:0","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#i2s"},{"categories":null,"content":"接口 SD(Serial Data)：串行数据线，用于发送或接收两个时分复用的数据通道上的数据（仅半双工模式），如果是全双工模式，该信号仅用于发送数据。 WS(Word Select)：字段选择线，也称帧时钟（LRC）线，表明当前传输数据的声道，不同标准有不同的定义。WS线的频率等于采样频率(FS)。 CK(Serial Clock)：串行时钟线，也称位时钟(BCLK)，数字音频的每一位数据都对应有一个CK脉冲，它的频率为：2*采样频率*量化位数，2代表左右两个通道数据。 ext_SD(extend Serial Data)：扩展串行数据线，用于全双工传输的数据接收。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:1","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#接口"},{"categories":null,"content":"时序图 I2S Philips标准 有效位：MSB（高位在前） 发送：在SCK的下降沿改变SD或WS的值。 接收：在SCK的上升沿读取SD或WS的值。 声道：一个WS线周期包括发送左声道和右声道数据。 填充：24bit信号放入32bit的帧中需要向左对齐，后面多余的8bit置零。该信号从当前通道数据的 第一个位（MSB）之前的一个时钟 开始有效。 WS为0：左声道 WS为1：右声道 左对齐标准 WS为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。在WS电平改变的那一刻便开始传输。 右对齐标准 PCM标准 WS不再作为声道数据选择（左声道的数据紧跟着右声道的数据），而是以高电平保持时间为判别依据作为两种模式的选择： 长帧模式：高电平保持13个CK周期。 短帧模式：高电平保持1个CK周期。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:2","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#时序图"},{"categories":null,"content":"时序图 I2S Philips标准 有效位：MSB（高位在前） 发送：在SCK的下降沿改变SD或WS的值。 接收：在SCK的上升沿读取SD或WS的值。 声道：一个WS线周期包括发送左声道和右声道数据。 填充：24bit信号放入32bit的帧中需要向左对齐，后面多余的8bit置零。该信号从当前通道数据的 第一个位（MSB）之前的一个时钟 开始有效。 WS为0：左声道 WS为1：右声道 左对齐标准 WS为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。在WS电平改变的那一刻便开始传输。 右对齐标准 PCM标准 WS不再作为声道数据选择（左声道的数据紧跟着右声道的数据），而是以高电平保持时间为判别依据作为两种模式的选择： 长帧模式：高电平保持13个CK周期。 短帧模式：高电平保持1个CK周期。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:2","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#i2s-philips标准"},{"categories":null,"content":"时序图 I2S Philips标准 有效位：MSB（高位在前） 发送：在SCK的下降沿改变SD或WS的值。 接收：在SCK的上升沿读取SD或WS的值。 声道：一个WS线周期包括发送左声道和右声道数据。 填充：24bit信号放入32bit的帧中需要向左对齐，后面多余的8bit置零。该信号从当前通道数据的 第一个位（MSB）之前的一个时钟 开始有效。 WS为0：左声道 WS为1：右声道 左对齐标准 WS为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。在WS电平改变的那一刻便开始传输。 右对齐标准 PCM标准 WS不再作为声道数据选择（左声道的数据紧跟着右声道的数据），而是以高电平保持时间为判别依据作为两种模式的选择： 长帧模式：高电平保持13个CK周期。 短帧模式：高电平保持1个CK周期。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:2","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#左对齐标准"},{"categories":null,"content":"时序图 I2S Philips标准 有效位：MSB（高位在前） 发送：在SCK的下降沿改变SD或WS的值。 接收：在SCK的上升沿读取SD或WS的值。 声道：一个WS线周期包括发送左声道和右声道数据。 填充：24bit信号放入32bit的帧中需要向左对齐，后面多余的8bit置零。该信号从当前通道数据的 第一个位（MSB）之前的一个时钟 开始有效。 WS为0：左声道 WS为1：右声道 左对齐标准 WS为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。在WS电平改变的那一刻便开始传输。 右对齐标准 PCM标准 WS不再作为声道数据选择（左声道的数据紧跟着右声道的数据），而是以高电平保持时间为判别依据作为两种模式的选择： 长帧模式：高电平保持13个CK周期。 短帧模式：高电平保持1个CK周期。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:2","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#右对齐标准"},{"categories":null,"content":"时序图 I2S Philips标准 有效位：MSB（高位在前） 发送：在SCK的下降沿改变SD或WS的值。 接收：在SCK的上升沿读取SD或WS的值。 声道：一个WS线周期包括发送左声道和右声道数据。 填充：24bit信号放入32bit的帧中需要向左对齐，后面多余的8bit置零。该信号从当前通道数据的 第一个位（MSB）之前的一个时钟 开始有效。 WS为0：左声道 WS为1：右声道 左对齐标准 WS为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。在WS电平改变的那一刻便开始传输。 右对齐标准 PCM标准 WS不再作为声道数据选择（左声道的数据紧跟着右声道的数据），而是以高电平保持时间为判别依据作为两种模式的选择： 长帧模式：高电平保持13个CK周期。 短帧模式：高电平保持1个CK周期。 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:2","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#pcm--org2b96237--标准"},{"categories":null,"content":"奈奎斯特采样定理 ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:3","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#奈奎斯特采样定理"},{"categories":null,"content":"PCM（脉冲编码调制） ","date":"2022-03-02","objectID":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/:1:4","series":null,"tags":["嵌入式"],"title":"通信协议","uri":"/posts/notes/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/#pcm-脉冲编码调制"},{"categories":null,"content":" 警告 该部分尚未完成，可能会影响您的阅读体验。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:0:0","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#"},{"categories":null,"content":"方差 \\[\\sigma_{x}^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(x_{i}-\\bar{x}\\right)^{2}\\] ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:1:0","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#方差"},{"categories":null,"content":"协方差 公式 \\[\\sigma(x, y)=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)\\] 意义协方差反映了： 两个变量是同向变化还是反向变化（正负） 运动方向 同向运动 反向运动 能正确反映同向/反向的原因：正负以平均值为界限 正负不一定为同向/反向 两个变量同向变化或蛮像变化的程度是多少（数值包括正负） ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:2:0","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#协方差"},{"categories":null,"content":"相关系数 ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:3:0","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#相关系数"},{"categories":null,"content":"公式 \\(\\rho=\\frac{\\boldsymbol{Cov}(X,Y)}{\\sigma_X\\sigma_Y}\\) \\(\\sigma_X\\)、\\(\\sigma_Y\\)：标准差 ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:3:1","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#公式"},{"categories":null,"content":"意义 特殊（标准化的）协方差，可以： 用正负表示两个变量变化是同向还是反向 消除了变化幅度的影响，单纯反映变化的相似程度 ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:3:2","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#意义"},{"categories":null,"content":"协方差矩阵 ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:4:0","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#协方差矩阵"},{"categories":null,"content":"表示 \\[\\Sigma=\\left[\\begin{array}{ccc} \\sigma\\left(x_{1}, x_{1}\\right) \u0026 \\cdots \u0026 \\sigma\\left(x_{1}, x_{d}\\right) \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\sigma\\left(x_{d}, x_{1}\\right) \u0026 \\cdots \u0026 \\sigma\\left(x_{d}, x_{d}\\right) \\end{array}\\right] \\in \\mathbb{R}^{d \\times d}\\] 根据协方差的定义，\\(\\sigma(x, y)\\)中的\\(x\\)和\\(y\\)可互换，不影响结果，所以该矩阵为对称矩阵。 ","date":"2022-03-02","objectID":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/:4:1","series":null,"tags":["数学"],"title":"统计学","uri":"/posts/notes/%E7%BB%9F%E8%AE%A1%E5%AD%A6/#表示"}]